<!-- d3db63df-7dac-4729-9354-da3e6fc9246f 0f97cb4a-6787-496e-bfb5-62bc5d24aeab -->
# Финальная архитектура приложения

## Общая архитектура

```
User → Frontend → Backend API
                      ↓
            ┌─────────┴─────────┐
            ↓                   ↓
      Sync Service        Analytics Service
            ↓                   ↓
    Bank APIs (VBank,    Database (SQLite)
     ABank, SBank)             ↓
            ↓                   ↓
         Database ──────→  Metrics (STS, etc)
```

## База данных (SQLite)

### Таблица: users

```sql
CREATE TABLE users (
  user_id TEXT PRIMARY KEY,        -- team260-3
  display_name TEXT NOT NULL,      -- "Иван"
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)
```

### Таблица: consents

```sql
CREATE TABLE consents (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  bank_id TEXT NOT NULL,           -- vbank, abank, sbank
  consent_type TEXT NOT NULL,      -- accounts, products, payments
  consent_id TEXT NOT NULL,        -- consent-abc123 (после одобрения)
  request_id TEXT,                 -- req-xyz (если был pending)
  status TEXT NOT NULL,            -- APPROVED, PENDING, REJECTED
  approval_url TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  expires_at TIMESTAMP,
  UNIQUE(user_id, bank_id, consent_type)
)
```

### Таблица: bank_datasets

```sql
CREATE TABLE bank_datasets (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  dataset_type TEXT NOT NULL,      -- accounts, transactions, credits, deposits
  data_json TEXT NOT NULL,         -- Весь JSON целиком
  fetched_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  banks_included TEXT,             -- "vbank,abank,sbank" - какие банки включены
  UNIQUE(user_id, dataset_type)    -- Один датасет каждого типа на юзера
)
```

### Таблица: sync_status

```sql
CREATE TABLE sync_status (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,
  bank_id TEXT NOT NULL,
  last_sync_at TIMESTAMP,
  status TEXT,                     -- ok, error
  error_message TEXT,
  UNIQUE(user_id, bank_id)
)
```

## Процесс 1: Онбординг (Step 1-3)

### Step 1: Ввод имени

```
User вводит: "Иван"
Backend генерирует: user_id = "team260-3" (или team260-{counter})
Сохраняет в таблицу users
```

### Step 2: Выбор банков и типов согласий

```
User выбирает:
- VBank: ✓ accounts, ✓ products, ✓ payments
- ABank: ✓ accounts, ✓ products
```

### Step 3: Создание согласий

**Для каждого банка последовательно:**

#### 3.1 Account Consent (ОБЯЗАТЕЛЬНО первым)

```http
POST https://vbank.open.bankingapi.ru/account-consents/request
Headers:
  Authorization: Bearer {bank_token_vbank}
  X-Requesting-Bank: team260
Body:
{
  "client_id": "team260-3",
  "permissions": ["ReadAccountsDetail", "ReadBalances", "ReadTransactionsDetail"],
  "reason": "Financial analysis",
  "requesting_bank": "team260",
  "requesting_bank_name": "Team 260 App"
}
```

**Ответы:**

- Автоодобрение (VBank, ABank): `{"status": "approved", "consent_id": "consent-abc", "auto_approved": true}`

→ Сразу сохраняем в БД со статусом APPROVED

- Требует одобрения (SBank): `{"status": "pending", "request_id": "req-xyz", "approval_url": "https://..."}`

→ Сохраняем в БД со статусом PENDING

→ **Polling каждые 5 секунд:**

  ```http
  GET https://sbank.open.bankingapi.ru/account-consents/{request_id}
  Headers:
    Authorization: Bearer {bank_token_sbank}
  ```

→ Когда `status: "approved"` → обновляем БД, получаем consent_id

#### 3.2 Product Agreement Consent (после одобрения account)

```http
POST https://vbank.open.bankingapi.ru/product-agreement-consents/request?client_id=team260-3
Headers:
  Authorization: Bearer {bank_token_vbank}
Body:
{
  "requesting_bank": "team260",
  "read_product_agreements": true,
  "open_product_agreements": false,
  "close_product_agreements": false,
  "allowed_product_types": ["deposit", "loan", "card"],
  "reason": "Read user's credits and deposits"
}
```

→ Сохраняем consent_id в БД

#### 3.3 Payment Consent

```http
POST https://vbank.open.bankingapi.ru/payment-consents/request
Headers:
  Authorization: Bearer {bank_token_vbank}
  X-Requesting-Bank: team260
Body:
{
  "requesting_bank": "team260",
  "client_id": "team260-3",
  "consent_type": "vrp",
  "debtor_account": "account-team260-3-vbank",
  "vrp_max_individual_amount": 100000.0,
  "vrp_daily_limit": 500000.0,
  "vrp_monthly_limit": 10000000.0
}
```

→ Сохраняем consent_id в БД

**Когда все account consents approved** → переходим к Step 4 (загрузка данных)

## Процесс 2: Синхронизация данных (Sync Service)

### Сервис: `services/data_sync.py`

**Функция: `sync_user_data(user_id: str, force_refresh: bool = False)`**

Для каждого банка с одобренным согласием:

#### 2.1 Получение счетов

```python
async def fetch_all_accounts(user_id: str) -> List[Dict]:
    """Собирает счета из всех банков пользователя"""
    all_accounts = []
    consents = get_user_consents(user_id, consent_type="accounts", status="APPROVED")
    
    for consent in consents:
        bank_id = consent.bank_id
        consent_id = consent.consent_id
        
        try:
            async with bank_client(bank_id) as client:
                # GET /accounts?client_id=team260-3
                accounts = await client.fetch_accounts_with_consent(
                    user_id=user_id,
                    consent_id=consent_id
                )
                
                # Добавляем банк к каждому счету
                for acc in accounts:
                    acc["bank_id"] = bank_id
                    all_accounts.append(acc)
                
                update_sync_status(user_id, bank_id, "ok", None)
        except Exception as e:
            logger.error(f"Failed to fetch accounts from {bank_id}: {e}")
            update_sync_status(user_id, bank_id, "error", str(e))
    
    # Сохраняем в БД
    save_dataset(user_id, "accounts", all_accounts, banks_included=[c.bank_id for c in consents])
    return all_accounts
```

#### 2.2 Получение транзакций

```python
async def fetch_all_transactions(user_id: str) -> List[Dict]:
    """Собирает транзакции из всех счетов всех банков"""
    all_transactions = []
    accounts = get_dataset(user_id, "accounts")  # Читаем из БД
    consents = get_user_consents(user_id, consent_type="accounts", status="APPROVED")
    
    for account in accounts:
        bank_id = account["bank_id"]
        account_id = account["account_id"]
        consent = find_consent_by_bank(consents, bank_id)
        
        if not consent:
            continue
        
        try:
            async with bank_client(bank_id) as client:
                # GET /accounts/{account_id}/transactions?client_id=team260-3
                transactions = await client.fetch_transactions_with_consent(
                    user_id=user_id,
                    account_id=account_id,
                    consent_id=consent.consent_id
                )
                
                # Добавляем метаданные
                for tx in transactions:
                    tx["bank_id"] = bank_id
                    tx["account_id"] = account_id
                    all_transactions.append(tx)
        except Exception as e:
            logger.error(f"Failed to fetch transactions from {bank_id}/{account_id}: {e}")
    
    # Сортируем по дате
    all_transactions.sort(key=lambda x: x.get("bookingDateTime", ""), reverse=True)
    
    # Сохраняем в БД
    save_dataset(user_id, "transactions", all_transactions, banks_included=[c.bank_id for c in consents])
    return all_transactions
```

#### 2.3 Получение кредитов

```python
async def fetch_all_credits(user_id: str) -> List[Dict]:
    """Собирает кредиты и кредитные карты из всех банков"""
    all_credits = []
    consents = get_user_consents(user_id, consent_type="products", status="APPROVED")
    
    for consent in consents:
        bank_id = consent.bank_id
        
        try:
            async with bank_client(bank_id) as client:
                # GET /product-agreements?client_id=team260-3
                # Headers: X-Product-Agreement-Consent-Id: {consent_id}
                agreements = await client.fetch_product_agreements(
                    user_id=user_id,
                    consent_id=consent.consent_id
                )
                
                # Фильтруем только кредиты
                credits = [a for a in agreements if a.get("product_type") in ["loan", "credit_card"]]
                
                for credit in credits:
                    credit["bank_id"] = bank_id
                    all_credits.append(credit)
                
        except Exception as e:
            logger.error(f"Failed to fetch credits from {bank_id}: {e}")
    
    save_dataset(user_id, "credits", all_credits, banks_included=[c.bank_id for c in consents])
    return all_credits
```

#### 2.4 Получение депозитов

```python
async def fetch_all_deposits(user_id: str) -> List[Dict]:
    """Собирает депозиты из всех банков"""
    all_deposits = []
    consents = get_user_consents(user_id, consent_type="products", status="APPROVED")
    
    for consent in consents:
        bank_id = consent.bank_id
        
        try:
            async with bank_client(bank_id) as client:
                agreements = await client.fetch_product_agreements(
                    user_id=user_id,
                    consent_id=consent.consent_id
                )
                
                deposits = [a for a in agreements if a.get("product_type") == "deposit"]
                
                for deposit in deposits:
                    deposit["bank_id"] = bank_id
                    all_deposits.append(deposit)
        except Exception as e:
            logger.error(f"Failed to fetch deposits from {bank_id}: {e}")
    
    save_dataset(user_id, "deposits", all_deposits, banks_included=[c.bank_id for c in consents])
    return all_deposits
```

### Главная функция синхронизации

```python
async def sync_user_data(user_id: str) -> Dict[str, Any]:
    """
    Синхронизирует все данные пользователя из всех банков.
    Вызывается:
 1. После онбординга (первый раз)
 2. При нажатии кнопки "Обновить"
    """
    logger.info(f"Starting data sync for user {user_id}")
    
    # Собираем данные параллельно
    accounts = await fetch_all_accounts(user_id)
    transactions = await fetch_all_transactions(user_id)
    credits = await fetch_all_credits(user_id)
    deposits = await fetch_all_deposits(user_id)
    
    # Получаем статус синхронизации
    sync_statuses = get_sync_statuses(user_id)
    
    return {
        "user_id": user_id,
        "synced_at": datetime.now().isoformat(),
        "accounts_count": len(accounts),
        "transactions_count": len(transactions),
        "credits_count": len(credits),
        "deposits_count": len(deposits),
        "sync_statuses": sync_statuses
    }
```

## Процесс 3: Аналитика (Analytics Service)

### Сервис: `services/analytics.py`

**Функция: `calculate_metrics(user_id: str) -> Dict[str, Any]`**

```python
def calculate_metrics(user_id: str) -> Dict[str, Any]:
    """
    Рассчитывает все метрики на основе данных из БД.
    НЕ обращается к банкам - только читает из БД!
    """
    # Читаем датасеты из БД
    accounts = get_dataset(user_id, "accounts")
    transactions = get_dataset(user_id, "transactions")
    credits = get_dataset(user_id, "credits")
    deposits = get_dataset(user_id, "deposits")
    
    # Получаем timestamp актуальности данных
    accounts_meta = get_dataset_meta(user_id, "accounts")
    transactions_meta = get_dataset_meta(user_id, "transactions")
    
    # 1. STS (Safe to Spend)
    sts_today = calculate_sts(transactions, accounts, credits)
    
    # 2. Loan Summary
    total_outstanding = sum(c.get("balance", 0) for c in credits)
    monthly_payments = sum(c.get("monthly_payment", 0) for c in credits)
    
    loan_summary = {
        "total_outstanding": total_outstanding,
        "mandatory_daily_payment": monthly_payments / 30,
        "additional_daily_payment": 0,  # Рассчитывается отдельно
        "total_monthly_payment": monthly_payments
    }
    
    # 3. Savings Summary
    total_saved = sum(d.get("balance", 0) for d in deposits)
    savings_summary = {
        "total_saved": total_saved,
        "daily_payment": 0,
        "target": 1000000,
        "progress_percent": (total_saved / 1000000) * 100 if total_saved else 0
    }
    
    # 4. Total debit cards balance
    debit_balance = sum(
        acc.get("balance", 0) 
        for acc in accounts 
        if acc.get("account_type") in ["checking", "savings"]
    )
    
    # 5. Health Score
    health_score = calculate_health_score(total_outstanding, debit_balance, transactions)
    
    return {
        "sts_today": sts_today,
        "loan_summary": loan_summary,
        "savings_summary": savings_summary,
        "total_debit_cards_balance": debit_balance,
        "health_score": health_score,
        "data_freshness": {
            "accounts_at": accounts_meta["fetched_at"],
            "transactions_at": transactions_meta["fetched_at"],
            "age_minutes": get_data_age_minutes(transactions_meta["fetched_at"])
        }
    }
```

## API Endpoints

### POST /api/sync/refresh

```python
@router.post("/api/sync/refresh")
async def refresh_data(user_id: str):
    """
    Кнопка "Обновить" - синхронизирует данные и пересчитывает метрики.
    """
    # 1. Синхронизация данных
    sync_result = await sync_user_data(user_id)
    
    # 2. Пересчет метрик
    metrics = calculate_metrics(user_id)
    
    return {
        "sync": sync_result,
        "metrics": metrics
    }
```

### GET /api/dashboard

```python
@router.get("/api/dashboard")
async def get_dashboard(user_id: str, force_refresh: bool = False):
    """
    Главный экран - показывает метрики.
    Если force_refresh=true, сначала синхронизирует данные.
    """
    if force_refresh:
        await sync_user_data(user_id)
    
    # Читаем метрики (из кэша или пересчитываем)
    metrics = calculate_metrics(user_id)
    
    # Статусы банков
    bank_statuses = get_sync_statuses(user_id)
    
    return {
        **metrics,
        "bank_statuses": bank_statuses,
        "user_mode": "loans" if metrics["loan_summary"]["total_outstanding"] > 0 else "deposits"
    }
```

## Frontend: Кнопка обновления

```typescript
const handleRefresh = async () => {
  setRefreshing(true);
  try {
    const response = await fetch(
      `${API_BASE_URL}/api/sync/refresh?user_id=${userId}`,
      { method: "POST" }
    );
    const data = await response.json();
    
    // Обновляем UI
    setDashboardData(data.metrics);
    setSyncStatus(data.sync);
    
    toast.success(`Обновлено ${data.sync.transactions_count} транзакций`);
  } catch (err) {
    toast.error("Не удалось обновить данные");
  } finally {
    setRefreshing(false);
  }
};
```

## Обработка ошибок

**Если банк недоступен:**

```python
# В sync_status сохраняется:
{
  "user_id": "team260-3",
  "bank_id": "vbank",
  "status": "error",
  "error_message": "Connection timeout",
  "last_sync_at": "2025-11-20T12:30:00"
}
```

**На фронте показывается:**

```
⚠️ VBank недоступен (обновлено 2 часа назад)
✓ ABank OK (обновлено только что)
✓ SBank OK (обновлено только что)
```

## Файлы для создания/изменения

1. **backend/services/data_sync.py** (новый)

            - `sync_user_data()`
            - `fetch_all_accounts()`
            - `fetch_all_transactions()`
            - `fetch_all_credits()`
            - `fetch_all_deposits()`

2. **backend/services/analytics.py** (новый)

            - `calculate_metrics()`
            - `calculate_sts()`
            - `calculate_health_score()`

3. **backend/database.py** (дополнить)

            - `save_dataset()`
            - `get_dataset()`
            - `get_dataset_meta()`
            - `update_sync_status()`
            - `get_sync_statuses()`

4. **backend/routers/sync.py** (новый)

            - `POST /api/sync/refresh`

5. **backend/services/consents.py** (упростить)

            - Убрать автополинг из `get_consents_status`
            - Добавить `poll_pending_consent` для явного polling

6. **core/obr_client.py** (проверить методы)

            - `fetch_accounts_with_consent()`
            - `fetch_transactions_with_consent()`
            - `fetch_product_agreements()`

7. **frontend: Step2ConsentProgress.tsx**

            - Упростить polling: только для pending, каждые 5 с