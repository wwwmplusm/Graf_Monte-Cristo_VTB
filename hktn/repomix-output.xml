This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/
  routers/
    __init__.py
    analytics.py
    banks.py
    consents.py
  services/
    analytics.py
    banking.py
    consents.py
  __init__.py
  app.py
  config.py
  schemas.py
  state.py
core/
  __init__.py
  data_models.py
  database.py
  obr_client.py
src/
  api/
    client.js
    client.ts
  components/
    __tests__/
      BanksList.test.js
      BanksList.test.tsx
      UserIdForm.test.js
      UserIdForm.test.tsx
    BanksList.js
    BanksList.tsx
    BanksOverviewCard.js
    BanksOverviewCard.tsx
    UserIdForm.js
    UserIdForm.tsx
  pages/
    __tests__/
      DashboardPage.test.js
      DashboardPage.test.tsx
    BanksCatalogPage.js
    BanksCatalogPage.tsx
    DashboardPage.js
    DashboardPage.tsx
    UserIdPage.js
    UserIdPage.tsx
  state/
    notifications.js
    notifications.tsx
    useUser.js
    useUser.tsx
  styles/
    global.css
  test/
    setup.js
    setup.ts
  types/
    dashboard.js
    dashboard.ts
  App.js
  App.tsx
  main.js
  main.tsx
  vite-env.d.ts
tests/
  test_api_aliases.py
  test_consents.py
backend_app.py
finpulse_consents.db
index.html
jest.config.ts
package.json
README.md
requirements.txt
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/routers/__init__.py">
from . import analytics, banks, consents

__all__ = ["analytics", "banks", "consents"]
</file>

<file path="backend/routers/analytics.py">
from __future__ import annotations

from fastapi import APIRouter

from ..services import analytics

router = APIRouter(prefix="/api", tags=["analytics"])


@router.get("/dashboard")
async def get_dashboard_metrics(user_id: str):
    return await analytics.get_dashboard_metrics(user_id)
</file>

<file path="backend/routers/banks.py">
from __future__ import annotations

from fastapi import APIRouter

from ..services import banking

router = APIRouter(prefix="/api", tags=["banks"])


@router.get("/banks")
async def list_banks(user_id: str | None = None):
    return banking.list_banks(user_id)


@router.get("/banks/{bank_id}/bootstrap")
async def bootstrap_bank(bank_id: str, user_id: str):
    return await banking.bootstrap_bank(bank_id, user_id)
</file>

<file path="backend/routers/consents.py">
from __future__ import annotations

from fastapi import APIRouter, Request
from fastapi.responses import RedirectResponse

from ..config import settings
from ..schemas import ConsentInitiateRequest
from ..services import consents

router = APIRouter(prefix="/api", tags=["consents"])


@router.post("/consent/initiate")
async def initiate_consent(req: ConsentInitiateRequest):
    return await consents.initiate_consent(req)


@router.post("/consent/initiate/product")
async def initiate_product_consent(req: ConsentInitiateRequest):
    return await consents.initiate_product_consent(req)


@router.post("/consents/start")
async def start_consent_alias(req: ConsentInitiateRequest):
    """Specification-friendly alias for /api/consent/initiate."""
    return await consents.initiate_consent(req)


@router.get("/consent/callback")
async def consent_callback(request: Request, consent_id: str):
    consents.mark_consent_from_callback(consent_id)
    return RedirectResponse(url=f"{settings.frontend_url}/callback")


@router.get("/consent/status")
async def get_consent_status(user_id: str, bank_id: str, request_id: str):
    return await consents.poll_consent_status(user_id=user_id, bank_id=bank_id, request_id=request_id)


@router.get("/consents/status")
async def get_consent_status_alias(user_id: str, bank_id: str, request_id: str):
    """Specification-friendly alias for /api/consent/status."""
    return await consents.poll_consent_status(user_id=user_id, bank_id=bank_id, request_id=request_id)
</file>

<file path="backend/services/analytics.py">
from __future__ import annotations

import asyncio
import logging
from datetime import date, datetime, timedelta
from typing import Dict, List, Optional

from fastapi import HTTPException, status

from hktn.core.database import StoredConsent, find_approved_consents, get_user_financial_inputs

from ..config import settings
from .banking import _sum_balance_amounts, fetch_bank_balances_with_consent

logger = logging.getLogger("finpulse.backend.analytics")


def _require_consents(user_id: str) -> List[StoredConsent]:
    consents = find_approved_consents(user_id, consent_type="accounts")
    if not consents:
        raise HTTPException(
            status_code=status.HTTP_424_FAILED_DEPENDENCY,
            detail="No approved consents found.",
        )
    return list(consents)


def _parse_iso_date(value: Optional[str]) -> Optional[date]:
    if not value:
        return None
    try:
        return datetime.fromisoformat(value).date()
    except ValueError:
        return None


def _future_date_or_fallback(raw_value: Optional[str], fallback_days: int) -> date:
    parsed = _parse_iso_date(raw_value)
    today = date.today()
    if parsed and parsed > today:
        return parsed
    return today + timedelta(days=max(fallback_days, 1))


def _load_financial_inputs(user_id: str) -> Dict[str, object]:
    payload = get_user_financial_inputs(user_id) or {}
    salary_amount = float(payload.get("salary_amount") or settings.default_salary_amount or 0.0)
    salary_date = _future_date_or_fallback(payload.get("next_salary_date"), settings.default_next_salary_days)
    credit_amount = float(payload.get("credit_payment_amount") or settings.default_credit_payment_amount or 0.0)
    credit_date = _future_date_or_fallback(payload.get("credit_payment_date"), settings.default_credit_payment_days)
    return {
        "salary_amount": salary_amount,
        "salary_date": salary_date,
        "credit_payment_amount": credit_amount,
        "credit_payment_date": credit_date,
    }


def _calculate_safe_to_spend(
    balance: float,
    salary_amount: float,
    salary_date: date,
    credit_payment_amount: float,
    credit_payment_date: date,
) -> Dict[str, object]:
    today = date.today()
    if salary_date <= today:
        salary_date = today + timedelta(days=max(settings.default_next_salary_days, 1))
    days_until_salary = max((salary_date - today).days, 1)

    credit_obligation = 0.0
    if credit_payment_amount and credit_payment_date and credit_payment_date <= salary_date:
        credit_obligation = credit_payment_amount

    safe_total = balance + salary_amount - credit_obligation
    safe_daily = max(0.0, round(safe_total / days_until_salary, 2))
    return {"value": safe_daily, "days": days_until_salary}


async def get_dashboard_metrics(user_id: str) -> Dict[str, object]:
    consents = _require_consents(user_id)
    balance_tasks = [
        fetch_bank_balances_with_consent(consent.bank_id, consent.consent_id, user_id)
        for consent in consents
    ]
    balance_results = await asyncio.gather(*balance_tasks)

    total_balance = 0.0
    fetched_at = datetime.utcnow().isoformat()
    bank_statuses: List[Dict[str, object]] = []

    for consent, result in zip(consents, balance_results):
        config = settings.banks.get(consent.bank_id)
        bank_name = config.display_name if config else consent.bank_id
        entry = {
            "bank_id": consent.bank_id,
            "bank_name": bank_name,
            "status": result.get("status", "error"),
            "fetched_at": None,
        }
        if result.get("status") == "ok":
            total_balance += _sum_balance_amounts(result.get("balances") or [])
            entry["fetched_at"] = fetched_at
        bank_statuses.append(entry)

    financial_inputs = _load_financial_inputs(user_id)
    safe = _calculate_safe_to_spend(
        balance=total_balance,
        salary_amount=financial_inputs["salary_amount"],
        salary_date=financial_inputs["salary_date"],
        credit_payment_amount=financial_inputs["credit_payment_amount"],
        credit_payment_date=financial_inputs["credit_payment_date"],
    )

    logger.info(
        "Dashboard payload for %s generated (balance=%.2f, sts=%.2f)",
        user_id,
        total_balance,
        safe["value"],
    )

    return {
        "total_balance": round(total_balance, 2),
        "bank_statuses": bank_statuses,
        "safe_to_spend_daily": safe["value"],
        "salary_amount": round(financial_inputs["salary_amount"], 2),
        "next_salary_date": financial_inputs["salary_date"].isoformat(),
        "days_until_next_salary": safe["days"],
        "upcoming_credit_payment": {
            "amount": round(financial_inputs["credit_payment_amount"], 2),
            "next_payment_date": financial_inputs["credit_payment_date"].isoformat(),
        },
    }
</file>

<file path="backend/services/banking.py">
from __future__ import annotations

import asyncio
import logging
from contextlib import asynccontextmanager
from typing import Any, Dict, List, Optional, Sequence, Tuple

from fastapi import HTTPException, status

from hktn.core.database import add_bank_status_log, find_approved_consents
from hktn.core.obr_client import OBRAPIClient

from ..config import BankConfig, settings
from ..state import api_cache

logger = logging.getLogger("finpulse.backend.banking")


BALANCE_FIELDS = (
    "amount",
    "balance",
    "availableBalance",
    "currentBalance",
    "ledgerBalance",
    "available_balance",
    "current_balance",
    "clearedBalance",
    "cleared_balance",
)


def _coerce_to_float(value: Any) -> Optional[float]:
    if value is None:
        return None
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return float(value)
    if isinstance(value, str):
        try:
            normalized = value.strip().replace("\u00a0", "").replace(",", ".")
            return float(normalized)
        except ValueError:
            return None
    if isinstance(value, dict):
        for field in ("amount", "value", "balance", "current"):
            candidate = value.get(field)
            numeric = _coerce_to_float(candidate)
            if numeric is not None:
                return numeric
        return None
    return None


def _extract_balance_entries(payload: Any) -> List[Dict[str, Any]]:
    if isinstance(payload, dict):
        for candidate in ("balances", "items", "data", "accountBalances"):
            section = payload.get(candidate)
            if isinstance(section, list):
                return section
        if isinstance(payload.get("data"), dict):
            nested = payload["data"].get("balances")
            if isinstance(nested, list):
                return nested
    if isinstance(payload, list):
        return payload
    return []


def _normalize_balance_entry(entry: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    if not isinstance(entry, dict):
        return None

    amount = None
    for key in BALANCE_FIELDS:
        if key in entry:
            amount = _coerce_to_float(entry[key])
            if amount is not None:
                break
    if amount is None and "balanceAmount" in entry and isinstance(entry["balanceAmount"], dict):
        amount = _coerce_to_float(entry["balanceAmount"].get("amount"))

    if amount is None:
        return None

    account_id = (
        entry.get("accountId")
        or entry.get("account_id")
        or entry.get("resource_id")
        or entry.get("id")
    )

    return {
        "bank_id": entry.get("bank_id") or entry.get("bankId"),
        "account_id": account_id,
        "amount": amount,
        "currency": entry.get("currency") or entry.get("currency_code"),
    }


def _sum_balance_amounts(entries: List[Dict[str, Any]]) -> float:
    total = 0.0
    for entry in entries:
        normalized = _normalize_balance_entry(entry)
        if normalized and normalized.get("amount") is not None:
            total += normalized["amount"]
    return round(total, 2)


def _ensure_team_credentials() -> Tuple[str, str]:
    if not settings.team_client_id or not settings.team_client_secret:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Server is missing TEAM credentials.",
        )
    return settings.team_client_id, settings.team_client_secret


def _require_bank(bank_id: str, require_url: bool = True) -> BankConfig:
    config = settings.banks.get(bank_id)
    if not config:
        raise HTTPException(status_code=404, detail=f"Bank '{bank_id}' is not supported.")
    if require_url and not config.url:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Bank endpoint URL is not configured.",
        )
    return config


def get_bank_config(bank_id: str, require_url: bool = False) -> BankConfig:
    """Return bank configuration ensuring it exists."""
    return _require_bank(bank_id, require_url=require_url)


@asynccontextmanager
async def bank_client(bank_id: str):
    config = _require_bank(bank_id, require_url=True)
    client_id, client_secret = _ensure_team_credentials()
    client = OBRAPIClient(
        api_base_url=config.url,
        team_client_id=client_id,
        team_client_secret=client_secret,
    )
    try:
        yield client
    finally:
        await client.close()


def list_banks(user_id: Optional[str] = None) -> Dict[str, List[Dict[str, Any]]]:
    connected_bank_ids = set()
    if user_id:
        connected_bank_ids = {
            consent.bank_id for consent in find_approved_consents(user_id, consent_type="accounts")
        }

    banks = []
    for bank_id, config in settings.banks.items():
        entry: Dict[str, Any] = {
            "id": bank_id,
            "name": config.display_name,
            "connected": bank_id in connected_bank_ids,
            "baseUrl": config.url,
            "status": "configured" if config.url else "missing_url",
        }
        if not config.url:
            entry["error"] = "Bank endpoint URL is not configured."
        banks.append(entry)
    return {"banks": banks}


async def fetch_bank_data_with_consent(bank_id: str, consent_id: str, user_id: str) -> Dict[str, Any]:
    cache_key = f"{user_id}:{bank_id}:{consent_id}"
    if cache_key in api_cache:
        logger.info("Serving data from cache for bank %s", bank_id)
        return api_cache[cache_key]

    _require_bank(bank_id)
    async with bank_client(bank_id) as client:
        try:
            transactions = await client.fetch_transactions_with_consent(user_id, consent_id)
            message = f"Fetched {len(transactions)} transactions"
            result = {
                "bank_id": bank_id,
                "status": "ok",
                "transactions": transactions,
                "message": message,
            }
            api_cache[cache_key] = result
            add_bank_status_log(user_id, bank_id, "fetch_transactions", "ok", message)
            return result
        except Exception as exc:  # noqa: BLE001
            error_message = str(exc)
            logger.error("Failed to fetch data for bank %s: %s", bank_id, error_message)
            add_bank_status_log(user_id, bank_id, "fetch_transactions", "error", error_message)
            return {"bank_id": bank_id, "status": "error", "transactions": [], "message": error_message}


async def fetch_bank_credits(
    bank_id: str,
    consent_id: str,
    user_id: str,
    user_name: Optional[str] = None,
    create_product_consent: bool = False,
) -> Dict[str, Any]:
    _require_bank(bank_id)
    async with bank_client(bank_id) as client:
        try:
            prod_consent_id = consent_id
            if create_product_consent:
                prod_consent_meta = await client.initiate_product_consent(user_id, user_display_name=user_name)
                if prod_consent_meta and prod_consent_meta.consent_id:
                    prod_consent_id = prod_consent_meta.consent_id

            credits = await client.fetch_credits_with_consent(user_id, prod_consent_id)
            for credit in credits or []:
                if isinstance(credit, dict):
                    credit.setdefault("bank_id", bank_id)
                    credit.setdefault("bank_name", settings.banks[bank_id].display_name)
            message = f"Fetched {len(credits)} credits"
            add_bank_status_log(user_id, bank_id, "fetch_credits", "ok", message)
            return {
                "bank_id": bank_id,
                "status": "ok",
                "credits": credits,
                "message": message,
            }
        except Exception as exc:  # noqa: BLE001
            error_message = str(exc)
            logger.error("Failed to fetch credits for bank %s: %s", bank_id, error_message)
            add_bank_status_log(user_id, bank_id, "fetch_credits", "error", error_message)
            return {"bank_id": bank_id, "status": "error", "credits": [], "message": error_message}


async def fetch_bank_accounts_with_consent(bank_id: str, consent_id: str, user_id: str) -> Dict[str, Any]:
    _require_bank(bank_id)
    async with bank_client(bank_id) as client:
        try:
            accounts = await client.fetch_accounts_with_consent(user_id, consent_id)
            for account in accounts or []:
                if isinstance(account, dict):
                    account.setdefault("bank_id", bank_id)
                    account.setdefault("bank_name", settings.banks[bank_id].display_name)
            message = f"Fetched {len(accounts)} accounts"
            add_bank_status_log(user_id, bank_id, "fetch_accounts", "ok", message)
            return {
                "bank_id": bank_id,
                "status": "ok",
                "accounts": accounts,
                "message": message,
            }
        except Exception as exc:  # noqa: BLE001
            error_message = str(exc)
            logger.error("Failed to fetch accounts for bank %s: %s", bank_id, error_message)
            add_bank_status_log(user_id, bank_id, "fetch_accounts", "error", error_message)
            return {"bank_id": bank_id, "status": "error", "accounts": [], "message": error_message}


async def fetch_bank_balances_with_consent(bank_id: str, consent_id: str, user_id: str) -> Dict[str, Any]:
    _require_bank(bank_id)
    async with bank_client(bank_id) as client:
        try:
            balances_data = await client.fetch_balances_with_consent(user_id, consent_id)
            entries = balances_data.get("balances", [])
            message = f"Fetched {len(entries)} balance records"
            add_bank_status_log(user_id, bank_id, "fetch_balances", "ok", message)
            return {
                "bank_id": bank_id,
                "status": "ok",
                "balances": entries,
                "message": message,
            }
        except Exception as exc:  # noqa: BLE001
            error_message = str(exc)
            logger.error("Failed to fetch balances for bank %s: %s", bank_id, error_message)
            add_bank_status_log(user_id, bank_id, "fetch_balances", "error", error_message)
            return {"bank_id": bank_id, "status": "error", "balances": [], "message": error_message}


async def bootstrap_bank(bank_id: str, user_id: str) -> Dict[str, Any]:
    """Aggregate initial payload for a connected bank."""
    config = _require_bank(bank_id)
    if not config.url:
        message = "Bank endpoint URL is not configured."
        add_bank_status_log(user_id, bank_id, "bootstrap", "error", message)
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=message,
        )

    approved_consents = find_approved_consents(user_id, consent_type="accounts")
    consent = next((entry for entry in approved_consents if entry.bank_id == bank_id), None)
    if not consent:
        message = "No approved consents found."
        add_bank_status_log(user_id, bank_id, "bootstrap", "error", message)
        raise HTTPException(status_code=status.HTTP_424_FAILED_DEPENDENCY, detail=message)

    accounts_task = fetch_bank_accounts_with_consent(bank_id, consent.consent_id, user_id)
    transactions_task = fetch_bank_data_with_consent(bank_id, consent.consent_id, user_id)
    credits_task = fetch_bank_credits(bank_id, consent.consent_id, user_id)
    balances_task = fetch_bank_balances_with_consent(bank_id, consent.consent_id, user_id)

    accounts_res, transactions_res, credits_res, balances_res = await asyncio.gather(
        accounts_task,
        transactions_task,
        credits_task,
        balances_task,
    )

    transactions_snapshot = list(transactions_res.get("transactions") or [])[:100]
    status_block = {
        "accounts": {
            "state": accounts_res.get("status"),
            "message": accounts_res.get("message"),
        },
        "transactions": {
            "state": transactions_res.get("status"),
            "message": transactions_res.get("message"),
        },
        "credits": {
            "state": credits_res.get("status"),
            "message": credits_res.get("message"),
        },
        "balances": {
            "state": balances_res.get("status"),
            "message": balances_res.get("message"),
        },
    }

    result = {
        "bank_id": bank_id,
        "user_id": user_id,
        "baseUrl": config.url,
        "accounts": accounts_res.get("accounts") or [],
        "credits": credits_res.get("credits") or [],
        "transactions": transactions_snapshot,
        "status": status_block,
        "balances": balances_res.get("balances") or [],
    }
    add_bank_status_log(user_id, bank_id, "bootstrap", "ok", "Bootstrap payload generated.")
    return result
</file>

<file path="backend/services/consents.py">
from __future__ import annotations

import logging
from typing import Any, Dict

from fastapi import HTTPException, status

from hktn.core.database import (
    get_consent_by_request_id,
    save_consent,
    update_consent_from_request,
    update_consent_status,
)
from hktn.core.obr_client import AUTHORIZED_CONSENT_STATUSES, FAILED_CONSENT_STATUSES

from ..schemas import ConsentInitiateRequest
from .banking import bank_client, get_bank_config

logger = logging.getLogger("finpulse.backend.consents")


async def initiate_consent(req: ConsentInitiateRequest) -> Dict[str, Any]:
    bank_config = get_bank_config(req.bank_id, require_url=True)
    async with bank_client(req.bank_id) as client:
        try:
            logger.info("Initiating consent for user '%s' with bank '%s'", req.user_id, req.bank_id)
            consent_meta = await client.initiate_consent(req.user_id)
            consent_identifier = consent_meta.consent_id or consent_meta.request_id
            if not consent_identifier:
                raise HTTPException(
                    status_code=502,
                    detail="Bank did not provide consent or request identifier.",
                )

            initial_status = "APPROVED" if consent_meta.auto_approved else "AWAITING_USER"
            save_consent(
                req.user_id,
                req.bank_id,
                consent_identifier,
                initial_status,
                request_id=consent_meta.request_id,
                approval_url=consent_meta.approval_url,
                consent_type="accounts",
            )

            if consent_meta.consent_id and consent_meta.auto_approved:
                update_consent_status(consent_meta.consent_id, "APPROVED")

            response_payload: Dict[str, Any] = {
                "bank_id": req.bank_id,
                "bank_name": bank_config.display_name,
                "user_id": req.user_id,
                "state": "approved" if consent_meta.auto_approved else "pending",
                "status": consent_meta.status,
                "consent_id": consent_meta.consent_id,
                "request_id": consent_meta.request_id,
                "approval_url": consent_meta.approval_url,
                "auto_approved": consent_meta.auto_approved,
            }

            if consent_meta.auto_approved:
                logger.info("Consent %s auto-approved for user '%s'.", consent_meta.consent_id, req.user_id)
            else:
                logger.info(
                    "Consent awaiting user action (request_id=%s) for user '%s'.",
                    consent_meta.request_id,
                    req.user_id,
                )
            return response_payload
        except HTTPException:
            raise
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to initiate consent for bank %s: %s", req.bank_id, exc)
            raise HTTPException(status_code=502, detail=f"Could not initiate consent with bank: {exc}") from exc


async def initiate_product_consent(req: ConsentInitiateRequest) -> Dict[str, Any]:
    """Initiate product-agreement consent for the selected bank."""
    bank_config = get_bank_config(req.bank_id, require_url=True)
    async with bank_client(req.bank_id) as client:
        try:
            logger.info("Initiating PRODUCT consent for user '%s' with bank '%s'", req.user_id, req.bank_id)
            consent_meta = await client.initiate_product_consent(req.user_id)
            if not consent_meta or not (consent_meta.consent_id or consent_meta.request_id):
                raise HTTPException(status_code=502, detail="Bank did not provide product consent identifier.")

            consent_identifier = consent_meta.consent_id or consent_meta.request_id
            initial_status = "APPROVED" if consent_meta.auto_approved else "AWAITING_USER"
            save_consent(
                req.user_id,
                req.bank_id,
                consent_identifier,
                initial_status,
                request_id=consent_meta.request_id,
                approval_url=consent_meta.approval_url,
                consent_type="products",
            )

            if consent_meta.consent_id and consent_meta.auto_approved:
                update_consent_status(consent_meta.consent_id, "APPROVED")

            return {
                "bank_id": req.bank_id,
                "bank_name": bank_config.display_name,
                "type": "product",
                "state": "approved" if consent_meta.auto_approved else "pending",
                "status": consent_meta.status,
                "consent_id": consent_meta.consent_id,
                "request_id": consent_meta.request_id,
                "approval_url": consent_meta.approval_url,
                "auto_approved": consent_meta.auto_approved,
            }
        except HTTPException as exc:
            logger.error("Failed to initiate PRODUCT consent for bank %s: %s", req.bank_id, exc)
            return {
                "bank_id": req.bank_id,
                "bank_name": bank_config.display_name,
                "type": "product",
                "state": "error",
                "status": "error",
                "error_message": str(exc.detail if hasattr(exc, "detail") else exc),
            }
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to initiate PRODUCT consent for bank %s: %s", req.bank_id, exc)
            return {
                "bank_id": req.bank_id,
                "bank_name": bank_config.display_name,
                "type": "product",
                "state": "error",
                "status": "error",
                "error_message": str(exc),
            }


async def poll_consent_status(user_id: str, bank_id: str, request_id: str) -> Dict[str, Any]:
    if not request_id:
        raise HTTPException(status_code=400, detail="request_id is required.")
    get_bank_config(bank_id, require_url=True)

    async with bank_client(bank_id) as client:
        try:
            logger.info("Polling consent status for request_id=%s at bank %s", request_id, bank_id)
            payload = await client.get_consent_status_by_request_id(request_id)
            data_section = payload.get("data", {}) if isinstance(payload, dict) else {}
            consent_id = (
                data_section.get("consentId")
                or data_section.get("consent_id")
                or payload.get("consent_id")
            )
            status_value = (
                data_section.get("status")
                or payload.get("status")
                or "unknown"
            )
            response: Dict[str, Any] = {
                "state": "pending",
                "status": status_value,
                "bank_id": bank_id,
                "request_id": request_id,
            }
            stored = get_consent_by_request_id(request_id)
            if stored and stored.get("approval_url"):
                response["approval_url"] = stored["approval_url"]
            approval_link = (
                payload.get("links", {}).get("consentApproval")
                if isinstance(payload, dict)
                else None
            )
            if approval_link:
                response["approval_url"] = approval_link

            if status_value in FAILED_CONSENT_STATUSES:
                response["state"] = "failed"
                if consent_id:
                    update_consent_from_request(request_id, consent_id, status_value)
                return response

            if consent_id:
                response["consent_id"] = consent_id
                if status_value in AUTHORIZED_CONSENT_STATUSES:
                    updated = update_consent_from_request(request_id, consent_id, "APPROVED")
                    if not updated:
                        consent_kind = (stored or {}).get("consent_type") or "accounts"
                        save_consent(
                            user_id,
                            bank_id,
                            consent_id,
                            "APPROVED",
                            request_id=request_id,
                            consent_type=consent_kind,
                        )
                    update_consent_status(consent_id, "APPROVED")
                    response["state"] = "approved"
            return response
        except HTTPException:
            raise
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to fetch consent status for bank %s: %s", bank_id, exc)
            raise HTTPException(status_code=502, detail=f"Failed to fetch consent status: {exc}") from exc


def mark_consent_from_callback(consent_id: str) -> bool:
    """Mark consent as approved when redirected back from bank."""
    return update_consent_status(consent_id, "APPROVED")
</file>

<file path="backend/__init__.py">
from .app import create_app

__all__ = ["create_app"]
</file>

<file path="backend/app.py">
from __future__ import annotations

import logging

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from hktn.core.database import init_db
from .config import settings
from .routers import analytics, banks, consents

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("finpulse.backend")


def create_app() -> FastAPI:
    app = FastAPI(title=settings.title, version=settings.version)

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    app.include_router(banks.router)
    app.include_router(consents.router)
    app.include_router(analytics.router)

    @app.on_event("startup")
    def _on_startup() -> None:
        logger.info("Bootstrapping FinPulse backend")
        init_db()

    return app


app = create_app()
</file>

<file path="backend/config.py">
from __future__ import annotations

import os
from pathlib import Path
from typing import Dict, List, Optional

from dotenv import load_dotenv

BASE_DIR = Path(__file__).resolve().parent.parent
load_dotenv(BASE_DIR / ".env")


class BankConfig(dict):
    """Dictionary-backed bank configuration with attribute helpers."""

    def __init__(self, display_name: str, url: Optional[str]):
        super().__init__(display_name=display_name, url=url)

    @property
    def display_name(self) -> str:
        return self.get("display_name", "")

    @display_name.setter
    def display_name(self, value: str) -> None:
        self["display_name"] = value

    @property
    def url(self) -> Optional[str]:
        return self.get("url")

    @url.setter
    def url(self, value: Optional[str]) -> None:
        self["url"] = value


def _build_bank_configs() -> Dict[str, BankConfig]:
    """Load partner bank configuration from environment variables."""
    return {
        "vbank": BankConfig(display_name="VBank", url=os.getenv("VBANK_API_URL")),
        "abank": BankConfig(display_name="ABank", url=os.getenv("ABANK_API_URL")),
        "sbank": BankConfig(display_name="SBank", url=os.getenv("SBANK_API_URL")),
    }


class Settings:
    """Runtime settings shared across the backend application."""

    def __init__(self) -> None:
        self.title: str = "FinPulse Experience API"
        self.version: str = "4.0.0"
        self.frontend_url: str = os.getenv("FRONTEND_URL", "http://localhost:5173")
        self.cors_origins: List[str] = [
            "http://localhost:3000",
            "http://localhost:5173",
            "http://127.0.0.1:5173",
        ]
        self.api_cache_ttl: int = int(os.getenv("API_CACHE_TTL", "300"))
        self.api_cache_size: int = int(os.getenv("API_CACHE_SIZE", "100"))
        self.team_client_id: Optional[str] = os.getenv("CLIENT_ID")
        self.team_client_secret: Optional[str] = os.getenv("CLIENT_SECRET")
        self.banks: Dict[str, BankConfig] = _build_bank_configs()
        self.default_salary_amount: float = float(os.getenv("DEFAULT_SALARY_AMOUNT", "0"))
        self.default_next_salary_days: int = int(os.getenv("DEFAULT_NEXT_SALARY_DAYS", "14"))
        self.default_credit_payment_amount: float = float(os.getenv("DEFAULT_CREDIT_PAYMENT_AMOUNT", "0"))
        self.default_credit_payment_days: int = int(os.getenv("DEFAULT_CREDIT_PAYMENT_DAYS", "10"))


settings = Settings()
</file>

<file path="backend/schemas.py">
from __future__ import annotations

from pydantic import BaseModel


class ConsentInitiateRequest(BaseModel):
    user_id: str
    bank_id: str
</file>

<file path="backend/state.py">
from __future__ import annotations

from cachetools import TTLCache

from .config import settings

# Shared cache for expensive banking API calls.
api_cache: TTLCache[str, dict] = TTLCache(maxsize=settings.api_cache_size, ttl=settings.api_cache_ttl)
</file>

<file path="core/__init__.py">
"""Core package exposing primary interfaces for the FinPulse project."""

from .data_models import Transaction
from .obr_client import ConsentInitResult, OBRAPIClient

__all__ = [
    "OBRAPIClient",
    "ConsentInitResult",
    "Transaction",
]
</file>

<file path="core/data_models.py">
"""Data models for the hackathon project core."""
from __future__ import annotations

from datetime import date
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class Transaction(BaseModel):
    """Represents a single bank transaction with optional merchant context."""

    transactionId: str
    amount: float
    currency: str
    description: Optional[str] = None
    bookingDate: date
    creditDebitIndicator: Optional[str] = None
    bankTransactionCode: Optional[str] = None
    merchant: Dict[str, Optional[str]] = Field(default_factory=dict)
    mccCode: Optional[str] = None
    category: Optional[str] = None
    transactionInformation: Optional[str] = None
    transactionLocation: Dict[str, Any] = Field(default_factory=dict)
    card: Dict[str, Optional[str]] = Field(default_factory=dict)


class Account(BaseModel):
    """Represents a user's account."""

    accountId: str
    nickname: Optional[str] = None
    # Extend with additional fields once API contract is finalized.


class BankConsent(BaseModel):
    """Stores consent metadata for a bank."""

    bank_id: str
    consent_id: str


class AnalysisResult(BaseModel):
    """Outcome structure returned by analytics engine."""

    payment_date: date
    payment_amount: float
    success_probability_percent: int
    recommendation: str
    color_zone: str = Field(description="green, yellow, or red")
</file>

<file path="core/database.py">
import json
import logging
import sqlite3
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

DB_FILE = "finpulse_consents.db"
logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class StoredConsent:
    """Lightweight view of a consent record used by service layers."""

    bank_id: str
    consent_id: str
    consent_type: str = "accounts"


def get_db_connection() -> sqlite3.Connection:
    """Open a connection to the consent state database."""
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    return conn


def _ensure_column(conn: sqlite3.Connection, table: str, column: str, definition: str) -> None:
    """Ensure the given column exists on the table, adding it if necessary."""
    cursor = conn.execute(f"PRAGMA table_info({table})")
    columns = {row[1] for row in cursor.fetchall()}
    if column not in columns:
        logger.info("Adding column %s to table %s", column, table)
        conn.execute(f"ALTER TABLE {table} ADD COLUMN {column} {definition};")


def init_db() -> None:
    """Create all required tables for the application if they are absent."""
    try:
        with get_db_connection() as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS consents (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    bank_id TEXT NOT NULL,
                    consent_id TEXT NOT NULL UNIQUE,
                    status TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                """
            )
            _ensure_column(conn, "consents", "request_id", "TEXT")
            _ensure_column(conn, "consents", "approval_url", "TEXT")
            _ensure_column(conn, "consents", "consent_type", "TEXT")
            # Backfill consent type for legacy rows.
            conn.execute(
                """
                UPDATE consents
                SET bank_id = substr(bank_id, 1, length(bank_id) - 9),
                    consent_type = COALESCE(consent_type, 'products')
                WHERE bank_id LIKE '%\_products' ESCAPE '\\'
                """
            )
            conn.execute(
                """
                UPDATE consents
                SET consent_type = COALESCE(consent_type, 'accounts')
                WHERE consent_type IS NULL
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS user_profiles (
                    user_id TEXT PRIMARY KEY,
                    goal_type TEXT,
                    goal_details TEXT
                );
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS user_product_consents (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    bank_id TEXT NOT NULL,
                    product_id TEXT NOT NULL,
                    product_type TEXT,
                    consented BOOLEAN NOT NULL,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(user_id, bank_id, product_id)
                );
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS bank_status_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    bank_id TEXT NOT NULL,
                    operation TEXT NOT NULL,
                    status TEXT NOT NULL,
                    message TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS onboarding_sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    banks_connected TEXT,
                    products_consented TEXT,
                    goal_profile TEXT,
                    completed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS user_financial_inputs (
                    user_id TEXT PRIMARY KEY,
                    salary_amount REAL,
                    next_salary_date TEXT,
                    credit_payment_amount REAL,
                    credit_payment_date TEXT,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                """
            )
            conn.commit()
        logger.info("All database tables ensured.")
    except sqlite3.Error as exc:
        logger.error("Database initialization failed: %s", exc)
        raise


def save_consent(
    user_id: str,
    bank_id: str,
    consent_id: str,
    status: str,
    request_id: Optional[str] = None,
    approval_url: Optional[str] = None,
    consent_type: str = "accounts",
) -> None:
    """Persist or update a consent record."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO consents (user_id, bank_id, consent_id, status, request_id, approval_url, consent_type)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(consent_id) DO UPDATE SET
                status=excluded.status,
                user_id=excluded.user_id,
                bank_id=excluded.bank_id,
                request_id=COALESCE(excluded.request_id, consents.request_id),
                approval_url=COALESCE(excluded.approval_url, consents.approval_url),
                consent_type=COALESCE(excluded.consent_type, consents.consent_type)
            """,
            (user_id, bank_id, consent_id, status, request_id, approval_url, consent_type),
        )
        conn.commit()


def update_consent_status(consent_id: str, status: str) -> bool:
    """Set consent status; returns True if a row was updated."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "UPDATE consents SET status = ? WHERE consent_id = ?",
            (status, consent_id),
        )
        conn.commit()
        return cursor.rowcount > 0


def update_consent_from_request(request_id: str, consent_id: str, status: str) -> bool:
    """Update a pending consent row once the real consent_id becomes available."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            """
            UPDATE consents
            SET consent_id = ?, status = ?
            WHERE request_id = ?
            """,
            (consent_id, status, request_id),
        )
        conn.commit()
        return cursor.rowcount > 0


def get_consent_by_request_id(request_id: str) -> Optional[Dict[str, Any]]:
    """Return consent row by request_id if it exists."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "SELECT * FROM consents WHERE request_id = ?",
            (request_id,),
        )
        row = cursor.fetchone()
    return dict(row) if row else None


def find_approved_consents(user_id: str, consent_type: Optional[str] = None) -> List[StoredConsent]:
    """Return structured consents filtered by approval status (and optionally type)."""
    with get_db_connection() as conn:
        sql = "SELECT bank_id, consent_id, consent_type FROM consents WHERE user_id = ? AND status = 'APPROVED'"
        params: List[Any] = [user_id]
        if consent_type:
            sql += " AND consent_type = ?"
            params.append(consent_type)
        cursor = conn.execute(sql, params)
        rows = cursor.fetchall()
    return [
        StoredConsent(
            bank_id=row["bank_id"],
            consent_id=row["consent_id"],
            consent_type=row["consent_type"] or "accounts",
        )
        for row in rows
    ]


def upsert_product_consents(user_id: str, items: List[Dict[str, Any]]) -> None:
    """Upsert multiple product consent records for a user."""
    if not items:
        return
    with get_db_connection() as conn:
        cursor = conn.cursor()
        for item in items:
            cursor.execute(
                """
                INSERT INTO user_product_consents (user_id, bank_id, product_id, product_type, consented, updated_at)
                VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                ON CONFLICT(user_id, bank_id, product_id) DO UPDATE SET
                    consented = excluded.consented,
                    product_type = excluded.product_type,
                    updated_at = CURRENT_TIMESTAMP;
                """,
                (
                    user_id,
                    item["bank_id"],
                    item["product_id"],
                    item.get("product_type"),
                    bool(item["consented"]),
                ),
            )
        conn.commit()
    logger.info("Upserted %d product consents for user %s", len(items), user_id)


def get_product_consents_for_user(user_id: str) -> List[Dict[str, Any]]:
    """Fetch all product consents for a given user."""
    with get_db_connection() as conn:
        cursor = conn.execute("SELECT * FROM user_product_consents WHERE user_id = ?", (user_id,))
        rows = cursor.fetchall()
    return [dict(row) for row in rows]


def get_user_consents(user_id: str) -> List[Dict[str, Any]]:
    """Return all stored consents (any status) for the user."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "SELECT bank_id, consent_id, status, request_id, approval_url, created_at, consent_type FROM consents WHERE user_id = ?",
            (user_id,),
        )
        rows = cursor.fetchall()
    return [dict(row) for row in rows]


def add_bank_status_log(user_id: str, bank_id: str, operation: str, status: str, message: str) -> None:
    """Log the status of a bank operation."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO bank_status_log (user_id, bank_id, operation, status, message)
            VALUES (?, ?, ?, ?, ?);
            """,
            (user_id, bank_id, operation, status, message),
        )
        conn.commit()


def get_recent_bank_status_logs(user_id: str, limit: int = 10) -> List[Dict[str, Any]]:
    """Fetch recent bank operation logs for a user."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "SELECT * FROM bank_status_log WHERE user_id = ? ORDER BY timestamp DESC LIMIT ?",
            (user_id, limit),
        )
        rows = cursor.fetchall()
    return [dict(row) for row in rows]


def commit_onboarding_session(user_id: str, banks: List[str], products: List[Dict[str, Any]], goal: Dict[str, Any]) -> None:
    """Save a summary of the completed onboarding session."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO onboarding_sessions (user_id, banks_connected, products_consented, goal_profile)
            VALUES (?, ?, ?, ?);
            """,
            (user_id, json.dumps(banks), json.dumps(products), json.dumps(goal)),
        )
        conn.commit()
    logger.info("Committed onboarding session for user %s", user_id)


def get_latest_onboarding_session(user_id: str) -> Optional[Dict[str, Any]]:
    """Return the most recent onboarding session snapshot if it exists."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            """
            SELECT user_id, banks_connected, products_consented, goal_profile, completed_at
            FROM onboarding_sessions
            WHERE user_id = ?
            ORDER BY completed_at DESC
            LIMIT 1;
            """,
            (user_id,),
        )
        row = cursor.fetchone()

    if not row:
        return None

    def _safe_parse(value: Optional[str], default: Any) -> Any:
        if not value:
            return default
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return default

    return {
        "user_id": row["user_id"],
        "banks_connected": _safe_parse(row["banks_connected"], []),
        "products_consented": _safe_parse(row["products_consented"], []),
        "goal_profile": _safe_parse(row["goal_profile"], {}),
        "completed_at": row["completed_at"],
    }


def get_user_goal(user_id: str) -> Optional[Dict[str, Any]]:
    """Fetch the last saved user goal."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "SELECT goal_type, goal_details FROM user_profiles WHERE user_id = ?",
            (user_id,),
        )
        row = cursor.fetchone()
    if not row:
        return None
    goal_details = json.loads(row["goal_details"]) if row["goal_details"] else {}
    return {"goal_type": row["goal_type"], "goal_details": goal_details}


def save_user_profile(user_id: str, goal_type: str, goal_details: Dict[str, Any]) -> None:
    """Upsert the user's selected goal details."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO user_profiles (user_id, goal_type, goal_details)
            VALUES (?, ?, ?)
            ON CONFLICT(user_id) DO UPDATE SET
                goal_type = excluded.goal_type,
                goal_details = excluded.goal_details
            """,
            (user_id, goal_type, json.dumps(goal_details)),
        )
        conn.commit()
    logger.info("Saved profile for user %s (goal=%s)", user_id, goal_type)


def upsert_user_financial_inputs(
    user_id: str,
    salary_amount: Optional[float] = None,
    next_salary_date: Optional[str] = None,
    credit_payment_amount: Optional[float] = None,
    credit_payment_date: Optional[str] = None,
) -> None:
    """Persist salary/credit metadata used by the simplified analytics flow."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO user_financial_inputs (user_id, salary_amount, next_salary_date, credit_payment_amount, credit_payment_date, updated_at)
            VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
            ON CONFLICT(user_id) DO UPDATE SET
                salary_amount = excluded.salary_amount,
                next_salary_date = excluded.next_salary_date,
                credit_payment_amount = excluded.credit_payment_amount,
                credit_payment_date = excluded.credit_payment_date,
                updated_at = CURRENT_TIMESTAMP
            """,
            (user_id, salary_amount, next_salary_date, credit_payment_amount, credit_payment_date),
        )
        conn.commit()


def get_user_financial_inputs(user_id: str) -> Optional[Dict[str, Any]]:
    """Return stored salary/payment metadata for a user if present."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            """
            SELECT user_id, salary_amount, next_salary_date, credit_payment_amount, credit_payment_date
            FROM user_financial_inputs
            WHERE user_id = ?
            """,
            (user_id,),
        )
        row = cursor.fetchone()
    return dict(row) if row else None
</file>

<file path="core/obr_client.py">
import asyncio
import json
import logging
import uuid
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional
from urllib.parse import urljoin

import httpx
import jwt
from tenacity import retry, retry_if_exception, stop_after_attempt, wait_exponential

from .data_models import Transaction

logger = logging.getLogger(__name__)
DEFAULT_TIMEOUT = httpx.Timeout(20.0, connect=5.0)

# ,      
RETRYABLE_EXCEPTIONS = (
    httpx.TimeoutException,
    httpx.ConnectError,
    httpx.NetworkError,
)


def _is_retryable(exc: BaseException) -> bool:
    """Retry only on transport errors and HTTP 5xx per API docs."""
    if isinstance(exc, httpx.HTTPStatusError):
        return exc.response.status_code >= 500
    return isinstance(exc, RETRYABLE_EXCEPTIONS)


#   retry   
api_retry = retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=5),
    retry=retry_if_exception(_is_retryable),
)

AUTHORIZED_CONSENT_STATUSES = {"Authorized", "AuthorizedConsent", "Active", "Approved"}
PENDING_CONSENT_STATUSES = {"AwaitingAuthorization", "Pending", "AwaitingApproval"}
FAILED_CONSENT_STATUSES = {"Rejected", "Expired", "Revoked", "Cancelled"}
_AUTHORIZED_STATUS_SET = {item.lower() for item in AUTHORIZED_CONSENT_STATUSES}
_FAILED_STATUS_SET = {item.lower() for item in FAILED_CONSENT_STATUSES}
RSA_JWT_ALGS = {"RS256", "RS384", "RS512"}


def _normalize_status_value(value: Any) -> str:
    if value is None:
        return ""
    return str(value).strip()


@dataclass
class ConsentInitResult:
    consent_id: Optional[str]
    status: str
    auto_approved: bool
    approval_url: Optional[str] = None
    request_id: Optional[str] = None

    @property
    def requires_manual_action(self) -> bool:
        return not self.auto_approved and self.status not in AUTHORIZED_CONSENT_STATUSES


class OBRAPIClient:
    """Implements the multi-step OBR consent flow."""

    def __init__(self, api_base_url: str, team_client_id: str, team_client_secret: str):
        if not all([api_base_url, team_client_id, team_client_secret]):
            raise ValueError("api_base_url, team_client_id, and team_client_secret are required.")

        self.api_base_url = api_base_url.rstrip("/")
        self.team_id = team_client_id
        self.team_secret = team_client_secret
        self._client = httpx.AsyncClient(base_url=self.api_base_url, timeout=DEFAULT_TIMEOUT)
        self._bank_token: Optional[str] = None
        self._token_expires_at: Optional[datetime] = None
        self._jwks_keys: Optional[List[Dict[str, Any]]] = None
        self._token_lock = asyncio.Lock()

    async def _get_common_headers(self, bank_token: str) -> Dict[str, str]:
        """Header block shared by most outbound calls."""
        return {
            "Authorization": f"Bearer {bank_token}",
            "X-Requesting-Bank": self.team_id,
            "x-fapi-interaction-id": str(uuid.uuid4()),
        }

    @api_retry
    async def _get_jwks_keys(self) -> List[Dict[str, Any]]:
        if self._jwks_keys:
            return self._jwks_keys

        logger.info("Fetching JWKS from %s/.well-known/jwks.json", self.api_base_url)
        response = await self._client.get("/.well-known/jwks.json")
        response.raise_for_status()
        self._jwks_keys = response.json().get("keys", [])
        if not self._jwks_keys:
            raise ValueError("JWKS endpoint did not return any keys.")
        return self._jwks_keys

    def invalidate_jwks_cache(self) -> None:
        """Allow callers to force JWKS refresh (e.g., after key rotation)."""
        self._jwks_keys = None

    async def _validate_jwt(self, token: str) -> Dict[str, Any]:
        """
        Decode JWT payload and verify signature when the bank provides an RSA key.
        Some sandbox banks issue HS256 tokens without a shared secret in docs, so we
        fall back to skipping signature verification in that case.
        """
        try:
            unverified_header = jwt.get_unverified_header(token)
            alg = unverified_header.get("alg", "RS256")
            options = {"verify_aud": False}
            key: Optional[Any] = None

            if alg in RSA_JWT_ALGS:
                kid = unverified_header.get("kid")
                if not kid:
                    raise jwt.InvalidTokenError("JWT header is missing required 'kid' for RSA algorithms.")

                jwks_keys = await self._get_jwks_keys()
                if not jwks_keys:
                    raise jwt.InvalidTokenError("No keys found in JWKS endpoint.")

                key_data: Optional[Dict[str, Any]] = next(
                    (jwks_key for jwks_key in jwks_keys if jwks_key.get("kid") == kid),
                    None,
                )
                if key_data is None:
                    raise jwt.InvalidTokenError(f"Unknown 'kid' {kid} in JWT header.")

                public_key = jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(key_data))
                key = public_key
                options["verify_signature"] = True
            else:
                options["verify_signature"] = False
                logger.warning(
                    "Bank %s issued JWT with unsupported alg '%s'; skipping signature verification.",
                    self.api_base_url,
                    alg,
                )

            payload = jwt.decode(
                token,
                key,
                algorithms=[alg] if options.get("verify_signature") else None,
                options=options,
            )
            return payload
        except jwt.PyJWTError as exc:
            logger.error("JWT validation failed: %s", exc)
            raise

    async def _get_bank_token(self) -> str:
        async with self._token_lock:
            if self._bank_token and self._token_expires_at and datetime.now(timezone.utc) < self._token_expires_at:
                return self._bank_token

            logger.info("Requesting new bank token from %s", self.api_base_url)

            @api_retry
            async def _fetch_token_with_retry():
                response = await self._client.post(
                    "/auth/bank-token",
                    params={"client_id": self.team_id, "client_secret": self.team_secret},
                )
                response.raise_for_status()
                return response.json()

            token_data = await _fetch_token_with_retry()
            access_token = token_data["access_token"]

            payload = await self._validate_jwt(access_token)
            self._bank_token = access_token
            
            expires_at_timestamp = payload.get("exp", 0)
            self._token_expires_at = datetime.fromtimestamp(expires_at_timestamp, tz=timezone.utc) - timedelta(minutes=1)

            logger.info("Successfully obtained and validated new bank token.")
            return self._bank_token

    # !!!  @retry  !!!
    async def initiate_consent(self, user_id: str) -> ConsentInitResult:
        """
        Step 1: Create an account access consent request at the bank.
        Returns metadata about the consent, including approval URL when provided.
        """
        bank_token = await self._get_bank_token()
        headers = await self._get_common_headers(bank_token)
        body = {
            "client_id": user_id,
            "permissions": ["ReadAccountsDetail", "ReadBalances", "ReadTransactionsDetail"],
            "reason": "Financial analysis for FinPulse Hackathon",
            "requesting_bank": self.team_id,
            "requesting_bank_name": f"{self.team_id} App",
            "redirect_uri": "http://localhost:5173/callback",
        }

        logger.info("Initiating consent for user '%s' at %s", user_id, self.api_base_url)
        
        @api_retry
        async def _post_consent_request():
            response = await self._client.post("/account-consents/request", headers=headers, json=body)
            response.raise_for_status()
            return response.json()

        response_data = await _post_consent_request()

        data_section = response_data.get("data") if isinstance(response_data, dict) else {}
        if not isinstance(data_section, dict):
            data_section = {}

        consent_id = (
            data_section.get("consentId")
            or data_section.get("consent_id")
            or (response_data.get("consentId") if isinstance(response_data, dict) else None)
            or (response_data.get("consent_id") if isinstance(response_data, dict) else None)
        )
        request_id = (
            data_section.get("requestId")
            or data_section.get("request_id")
            or (response_data.get("request_id") if isinstance(response_data, dict) else None)
            or (response_data.get("requestId") if isinstance(response_data, dict) else None)
        )

        approval_url = (
            response_data.get("links", {}).get("consentApproval")
            or response_data.get("links", {}).get("consentApprovalUrl")
            or response_data.get("links", {}).get("approvalUrl")
            or response_data.get("approvalUrl")
            or response_data.get("approval_url")
        )

        status = (
            data_section.get("status")
            or response_data.get("status") if isinstance(response_data, dict) else None
            or ("Authorized" if response_data.get("auto_approved") else "AwaitingAuthorization")
        )
        auto_approved = bool(
            response_data.get("auto_approved")
            or data_section.get("autoApproved")
            or (status in AUTHORIZED_CONSENT_STATUSES)
        )

        if not consent_id and not request_id:
            raise ValueError("API did not return a consent or request identifier.")

        if not approval_url and auto_approved:
            logger.info(
                "Consent %s appears auto-approved at %s (no approval URL).",
                consent_id,
                self.api_base_url,
            )

        logger.info(
            "Consent initiated with consent_id=%s request_id=%s (status=%s)",
            consent_id,
            request_id,
            status,
        )
        return ConsentInitResult(
            consent_id=consent_id,
            approval_url=approval_url,
            status=status,
            auto_approved=auto_approved,
            request_id=request_id,
        )

    async def initiate_product_consent(
        self, user_id: str, user_display_name: Optional[str] = None
    ) -> Optional[ConsentInitResult]:
        """Tries multiple payloads to create a product agreement consent, inspired by hndmd.py."""
        bank_token = await self._get_bank_token()
        headers = await self._get_common_headers(bank_token)
        url = "/product-agreement-consents/request"

        valid_until = (
            datetime.now(timezone.utc) + timedelta(days=365)
        ).replace(microsecond=0).isoformat().replace("+00:00", "Z")

        base_payload = {
            "requesting_bank": self.team_id,
            "requesting_bank_name": f"{self.team_id} App",
            "client_id": user_id,
            "reason": "CreditGuard: credit analysis",
            "customer_name": user_display_name or user_id,
        }

        payloads_to_try = [
            {
                **base_payload,
                "read_product_agreements": True,
                "open_product_agreements": False,
                "close_product_agreements": False,
                "allowed_product_types": ["deposit", "loan", "credit_card"],
                "max_amount": 5_000_000,
                "valid_until": valid_until,
            },
            {
                **base_payload,
                "permissions": ["ReadProductAgreements"],
            },
            {
                **base_payload,
                "read_product_agreements": True,
            },
        ]

        for body in payloads_to_try:
            try:
                response = await self._client.post(
                    url,
                    headers=headers,
                    params={"client_id": user_id},
                    json=body,
                )
                if response.status_code >= 400:
                    logger.warning("Payload failed with status %s: %s", response.status_code, body)
                    continue

                data = response.json()
                consent_id = data.get("consent_id") or self._jget(data, ["data", "consentId"])
                request_id = data.get("request_id") or self._jget(data, ["data", "requestId"])
                status_raw = data.get("status") or self._jget(data, ["data", "status"])
                approval_url = self._jget(data, ["links", "consentApproval"])

                # SBank   request_id  consent_id
                final_id = consent_id or request_id
                if final_id:
                    normalized_status = _normalize_status_value(status_raw).lower()
                    auto_approved = bool(
                        data.get("auto_approved")
                        or (normalized_status and normalized_status in _AUTHORIZED_STATUS_SET)
                    )
                    if not auto_approved and not approval_url and normalized_status not in _FAILED_STATUS_SET:
                        auto_approved = True
                        status_raw = "Approved"

                    status_value = status_raw or ("Approved" if auto_approved else "Pending")

                    logger.info("Product consent initiated successfully with payload: %s", body)
                    return ConsentInitResult(
                        consent_id=final_id,
                        status=status_value,
                        auto_approved=auto_approved,
                        approval_url=approval_url,
                        request_id=request_id,
                    )
            except httpx.RequestError as e:  # noqa: PERF203
                logger.warning("Request failed for product consent payload %s: %s", body, e)

        logger.error("All attempts to create product consent failed for user %s at %s", user_id, self.api_base_url)
        return None

    @api_retry
    async def get_consent_details(self, consent_id: str) -> Dict[str, Any]:
        """Fetch consent status from /account-consents/{consent_id}."""
        response = await self._client.get(f"/account-consents/{consent_id}")
        response.raise_for_status()
        return response.json()

    @api_retry
    async def get_consent_status_by_request_id(self, request_id: str) -> Dict[str, Any]:
        """Fetch consent status when only request_id is available."""
        bank_token = await self._get_bank_token()
        headers = await self._get_common_headers(bank_token)
        response = await self._client.get(f"/account-consents/{request_id}", headers=headers)
        response.raise_for_status()
        return response.json()

    async def wait_for_consent_authorization(
        self,
        consent_id: str,
        timeout_seconds: float = 300,
        poll_interval_seconds: float = 5,
    ) -> str:
        """Poll consent status until it becomes authorized or fails."""
        logger.info("Waiting for consent %s to be authorized...", consent_id)
        deadline = asyncio.get_running_loop().time() + timeout_seconds

        while True:
            consent_payload = await self.get_consent_details(consent_id)
            data_section = consent_payload.get("data", {}) if isinstance(consent_payload, dict) else {}
            status = data_section.get("status") or consent_payload.get("status") or "unknown"

            if status in AUTHORIZED_CONSENT_STATUSES:
                logger.info("Consent %s authorized with status %s.", consent_id, status)
                return status
            if status in FAILED_CONSENT_STATUSES:
                raise RuntimeError(f"Consent {consent_id} failed with status '{status}'.")

            if asyncio.get_running_loop().time() >= deadline:
                raise TimeoutError(f"Timed out waiting for consent {consent_id} authorization (last status {status}).")

            await asyncio.sleep(poll_interval_seconds)

    async def fetch_transactions_with_consent(self, user_id: str, consent_id: str) -> List[Transaction]:
        """
        Step 2: Retrieve transactions for the user using an approved consent.
        """
        bank_token = await self._get_bank_token()
        base_headers = await self._get_common_headers(bank_token)

        logger.info("Fetching accounts for user '%s' with consent '%s'", user_id, consent_id)
        headers = {**base_headers, "X-Consent-Id": consent_id}
        
        @api_retry
        async def _get_accounts():
            acc_response = await self._client.get(f"/accounts?client_id={user_id}", headers=headers)
            acc_response.raise_for_status()
            return acc_response.json()

        accounts_data = await _get_accounts()
        accounts = self._extract_accounts(accounts_data)

        all_transactions: List[Transaction] = []
        for account in accounts:
            account_id = self._extract_account_id(account)
            if not account_id:
                continue

            next_page_url: Optional[str] = f"/accounts/{account_id}/transactions?client_id={user_id}"
            page_num = 1
            while next_page_url:
                logger.info(
                    "Fetching transactions for account '%s', page %d (next=%s)",
                    account_id,
                    page_num,
                    next_page_url,
                )
                paginated_headers = {**headers, "x-fapi-interaction-id": str(uuid.uuid4())}

                @api_retry
                async def _get_transactions_page(url):
                    tx_response = await self._client.get(url, headers=paginated_headers)
                    tx_response.raise_for_status()
                    return tx_response.json()
                
                response_data = await _get_transactions_page(next_page_url)

                raw_txs = self._extract_transactions(response_data)

                for raw in raw_txs:
                    tx_model = self._to_transaction_model(raw)
                    if tx_model:
                        all_transactions.append(tx_model)
                    else:
                        logger.warning("Failed to normalize transaction payload: %s", raw)

                next_page_url = self._extract_next_link(response_data)
                logger.info(
                    "Pagination checkpoint account=%s page=%d next=%s",
                    account_id,
                    page_num,
                    next_page_url,
                )
                page_num += 1

        logger.info("Fetched %d transactions for user '%s' from %s", len(all_transactions), user_id, self.api_base_url)
        return all_transactions

    async def close(self) -> None:
        """Dispose the underlying HTTP client."""
        await self._client.aclose()

    async def fetch_accounts_with_consent(self, user_id: str, consent_id: str) -> List[Dict[str, Any]]:
        """Fetch accounts list for the user with the granted consent."""
        bank_token = await self._get_bank_token()
        headers = {**(await self._get_common_headers(bank_token)), "X-Consent-Id": consent_id}

        logger.info("Fetching accounts overview for user '%s' (consent %s)", user_id, consent_id)

        @api_retry
        async def _get_accounts():
            response = await self._client.get(f"/accounts?client_id={user_id}", headers=headers)
            response.raise_for_status()
            return response.json()

        payload = await _get_accounts()
        accounts = self._extract_accounts(payload)
        logger.info("Retrieved %d accounts for user '%s' from %s", len(accounts), user_id, self.api_base_url)
        return accounts

    async def fetch_balances_with_consent(self, user_id: str, consent_id: str) -> Dict[str, Any]:
        """Fetch balance totals for the user with the granted consent."""
        bank_token = await self._get_bank_token()
        base_headers = await self._get_common_headers(bank_token)

        logger.info("Fetching balances for user '%s' (consent %s)", user_id, consent_id)

        async def _accounts_headers() -> Dict[str, str]:
            headers = {**base_headers, "x-fapi-interaction-id": str(uuid.uuid4())}
            headers["X-Consent-Id"] = consent_id
            return headers

        @api_retry
        async def _get_accounts():
            response = await self._client.get(f"/accounts?client_id={user_id}", headers=await _accounts_headers())
            response.raise_for_status()
            return response.json()

        accounts_payload = await _get_accounts()
        accounts = self._extract_accounts(accounts_payload)

        all_balance_entries: List[Dict[str, Any]] = []
        for account in accounts:
            account_id = self._extract_account_id(account)
            if not account_id:
                continue

            url = f"/accounts/{account_id}/balances"

            @api_retry
            async def _get_account_balances():
                response = await self._client.get(url, headers=await _accounts_headers())
                response.raise_for_status()
                return response.json()

            balance_payload = await _get_account_balances()
            entries = self._jget(balance_payload, ["data", "Balance"], [])
            if not entries:
                logger.warning("No balance entries found for account %s at %s", account_id, self.api_base_url)
                continue

            for entry in entries:
                if isinstance(entry, dict):
                    entry.setdefault("accountId", account_id)
                    all_balance_entries.append(entry)

        logger.info(
            "Retrieved %d balance entries for user '%s' from %s",
            len(all_balance_entries),
            user_id,
            self.api_base_url,
        )
        return {"balances": all_balance_entries}

    async def fetch_credits_with_consent(self, user_id: str, consent_id: str) -> List[Dict[str, Any]]:
        """
        Fetches credit agreements using multiple header variations and pagination,
        inspired by hndmd.py.
        """
        if not consent_id:
            logger.warning("fetch_credits_with_consent called without consent_id for user %s", user_id)
            return []

        bank_token = await self._get_bank_token()
        common_headers = await self._get_common_headers(bank_token)
        params: Dict[str, Any] = {"client_id": user_id}

        urls_to_try = ["/credits", "/product-agreements"]

        headers_variations = [
            {"X-Product-Agreement-Consent-Id": consent_id},
            {"x-product-agreement-consent-id": consent_id},
            {"X-Consent-Id": consent_id},
        ]

        for url in urls_to_try:
            for header_variant in headers_variations:
                headers = {**common_headers, **header_variant}
                try:
                    response = await self._client.get(url, headers=headers, params=params)
                    if response.status_code in (400, 401, 403, 404):
                        logger.warning(
                            "Request to %s failed with status %s using header %s",
                            url,
                            response.status_code,
                            list(header_variant.keys())[0],
                        )
                        continue

                    response.raise_for_status()

                    all_agreements = await self._paginate(response, headers, params)
                    credits = [ag for ag in all_agreements if self._is_credit(ag)]

                    logger.info(
                        "Successfully fetched %d credits from %s using header %s",
                        len(credits),
                        url,
                        list(header_variant.keys())[0],
                    )
                    return credits
                except httpx.RequestError as e:
                    logger.error("Network error while fetching from %s: %s", url, e)
                    raise

        logger.error("All attempts to fetch credits/agreements failed for consent %s.", consent_id)
        return []

    async def _paginate(self, first_response: httpx.Response, headers: Dict[str, str], params: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Paginates through API results using the 'next' link."""
        body = first_response.json()
        items = self._extract_agreements(body) or self._extract_accounts(body)
        items = list(items) if items else []

        next_url = self._extract_next_link(body)
        while next_url:
            paginated_params = {k: v for k, v in (params or {}).items() if f"{k}=" not in next_url}

            response = await self._client.get(next_url, headers=headers, params=paginated_params or None)
            if response.status_code != 200:
                logger.warning("Pagination failed at URL %s with status %s", next_url, response.status_code)
                break

            body = response.json()
            items.extend(self._extract_agreements(body) or self._extract_accounts(body))
            next_url = self._extract_next_link(body)

        return items

    @staticmethod
    def _jget(d: Dict[str, Any], path: List[str], default: Any = None) -> Any:
        cur = d
        for p in path:
            if isinstance(cur, dict) and p in cur:
                cur = cur[p]
            else:
                return default
        return cur

    @staticmethod
    def _is_credit(agreement: Dict[str, Any]) -> bool:
        """Checks if a product agreement is a credit product."""
        prod_type = (agreement.get("product_type") or "").lower()
        name = (agreement.get("product_name") or "").lower()
        return "credit" in prod_type or "loan" in prod_type or "" in name

    @staticmethod
    def _extract_accounts(payload: Any) -> List[Dict[str, Any]]:
        if isinstance(payload, dict):
            if isinstance(payload.get("accounts"), list):
                return payload["accounts"]
            data = payload.get("data")
            if isinstance(data, dict):
                if isinstance(data.get("accounts"), list):
                    return data["accounts"]
                if isinstance(data.get("account"), list):
                    return data["account"]
        return []

    @staticmethod
    def _extract_transactions(payload: Any) -> List[Dict[str, Any]]:
        if isinstance(payload, dict):
            if isinstance(payload.get("transactions"), list):
                return payload["transactions"]
            data = payload.get("data")
            if isinstance(data, dict):
                if isinstance(data.get("transactions"), list):
                    return data["transactions"]
                if isinstance(data.get("transaction"), list):
                    return data["transaction"]
        return []

    @staticmethod
    def _extract_agreements(payload: Any) -> List[Dict[str, Any]]:
        if isinstance(payload, dict):
            if isinstance(payload.get("agreements"), list):
                return payload["agreements"]
            if isinstance(payload.get("items"), list):
                return payload["items"]
            if isinstance(payload.get("credits"), list):
                return payload["credits"]
            data = payload.get("data")
            if isinstance(data, dict):
                if isinstance(data.get("agreements"), list):
                    return data["agreements"]
                if isinstance(data.get("credits"), list):
                    return data["credits"]
        return []

    @staticmethod
    def _extract_balance_entries(payload: Any) -> List[Dict[str, Any]]:
        if isinstance(payload, list):
            return [entry for entry in payload if isinstance(entry, dict)]
        if not isinstance(payload, dict):
            return []

        for candidate in ("balances", "items", "accountBalances", "account_balances"):
            section = payload.get(candidate)
            if isinstance(section, list):
                return [entry for entry in section if isinstance(entry, dict)]

        nested_data = payload.get("data")
        if isinstance(nested_data, dict):
            for candidate in ("balances", "accountBalances", "account_balances"):
                section = nested_data.get(candidate)
                if isinstance(section, list):
                    return [entry for entry in section if isinstance(entry, dict)]
        return []

    def _extract_next_link(self, payload: Any) -> Optional[str]:
        if not isinstance(payload, dict):
            return None

        next_url = (
            self._jget(payload, ["links", "next"])
            or self._jget(payload, ["Links", "next"])
            or self._jget(payload, ["data", "links", "next"])
        )

        if not next_url:
            return None

        #     URL
        return urljoin(self.api_base_url + "/", str(next_url))

    @staticmethod
    def _extract_account_id(account_payload: Any) -> Optional[str]:
        if not isinstance(account_payload, dict):
            return None
        for key in ("accountId", "account_id", "id"):
            value = account_payload.get(key)
            if value:
                return str(value)
        return None

    @staticmethod
    def _parse_booking_datetime(raw_value: Any) -> Optional[datetime]:
        if not isinstance(raw_value, str):
            return None

        value = raw_value.strip()
        if not value:
            return None

        try:
            if value.endswith("Z"):
                value = value.replace("Z", "+00:00")
            return datetime.fromisoformat(value)
        except ValueError:
            try:
                return datetime.fromisoformat(value + "+00:00")
            except ValueError:
                return None

    @staticmethod
    def _safe_str(value: Any) -> Optional[str]:
        if value is None:
            return None
        text = str(value).strip()
        return text or None

    @staticmethod
    def _normalize_merchant_payload(raw: Any) -> Dict[str, Optional[str]]:
        if not isinstance(raw, dict):
            return {}
        merchant = {
            "merchantId": OBRAPIClient._safe_str(
                raw.get("merchantId") or raw.get("id") or raw.get("merchant_id")
            ),
            "name": OBRAPIClient._safe_str(raw.get("name")),
            "mccCode": OBRAPIClient._safe_str(raw.get("mccCode") or raw.get("mcc")),
            "category": OBRAPIClient._safe_str(raw.get("category")),
            "city": OBRAPIClient._safe_str(raw.get("city")),
            "country": OBRAPIClient._safe_str(raw.get("country")),
            "address": OBRAPIClient._safe_str(raw.get("address") or raw.get("street")),
        }
        return {key: value for key, value in merchant.items() if value}

    @staticmethod
    def _normalize_card_payload(raw: Any) -> Dict[str, Optional[str]]:
        if not isinstance(raw, dict):
            return {}
        card = {
            "maskedPan": OBRAPIClient._safe_str(raw.get("maskedPan") or raw.get("masked_pan")),
            "type": OBRAPIClient._safe_str(raw.get("type") or raw.get("scheme")),
            "name": OBRAPIClient._safe_str(raw.get("name")),
        }
        return {key: value for key, value in card.items() if value}

    @staticmethod
    def _extract_bank_transaction_code(raw: Any) -> Optional[str]:
        if raw is None:
            return None
        if isinstance(raw, str):
            return OBRAPIClient._safe_str(raw)
        if isinstance(raw, dict):
            code = OBRAPIClient._safe_str(raw.get("code"))
            subcode = OBRAPIClient._safe_str(raw.get("subCode") or raw.get("subcode"))
            if code and subcode:
                return f"{code}:{subcode}"
            return code or subcode
        return None

    def _to_transaction_model(self, raw: Any) -> Optional[Transaction]:
        if not isinstance(raw, dict):
            return None

        transaction_id = (
            raw.get("transactionId")
            or raw.get("transaction_id")
            or raw.get("id")
            or str(uuid.uuid4())
        )

        amount_payload = raw.get("amount") or raw.get("transactionAmount") or raw.get("transaction_amount")
        currency = "RUB"
        amount_value: Optional[str] = None
        if isinstance(amount_payload, dict):
            currency = amount_payload.get("currency", currency)
            amount_value = amount_payload.get("amount")
        elif amount_payload is not None:
            amount_value = amount_payload

        if amount_value is None:
            amount_value = raw.get("amount")
        if "currency" in raw and not isinstance(amount_payload, dict):
            currency = raw.get("currency") or currency

        try:
            amount = float(amount_value)
        except (TypeError, ValueError):
            return None

        indicator = raw.get("creditDebitIndicator") or raw.get("direction")
        if isinstance(indicator, str) and indicator.lower().startswith("debit"):
            amount = -abs(amount)
        elif isinstance(indicator, str) and indicator.lower().startswith("credit"):
            amount = abs(amount)

        booking_value = (
            raw.get("bookingDate")
            or raw.get("bookingDateTime")
            or raw.get("valueDate")
            or raw.get("valueDateTime")
        )
        booking_dt = self._parse_booking_datetime(booking_value)
        if booking_dt is None:
            return None

        description = (
            raw.get("transactionInformation")
            or raw.get("description")
            or raw.get("narration")
            or raw.get("statementDescription")
        )
        transaction_information = raw.get("transactionInformation")

        merchant_payload = self._normalize_merchant_payload(raw.get("merchant"))
        mcc_code = merchant_payload.get("mccCode") or self._safe_str(raw.get("mccCode") or raw.get("mcc_code"))

        bank_transaction_code = self._extract_bank_transaction_code(
            raw.get("bankTransactionCode") or raw.get("bank_transaction_code")
        )

        transaction_location = raw.get("transactionLocation") or raw.get("transaction_location") or raw.get("location")
        if not isinstance(transaction_location, dict):
            transaction_location = {}

        card_payload = self._normalize_card_payload(
            raw.get("card") or raw.get("cardInstrument") or raw.get("card_instrument")
        )

        category = self._safe_str(raw.get("category") or raw.get("transactionCategory") or raw.get("categoryCode"))

        return Transaction(
            transactionId=str(transaction_id),
            amount=amount,
            currency=str(currency),
            description=description,
            bookingDate=booking_dt.date(),
            creditDebitIndicator=self._safe_str(indicator),
            bankTransactionCode=bank_transaction_code,
            merchant=merchant_payload or {},
            mccCode=mcc_code,
            category=category,
            transactionInformation=transaction_information,
            transactionLocation=transaction_location or {},
            card=card_payload or {},
        )
</file>

<file path="src/api/client.js">
const API_BASE = import.meta.env.VITE_API_BASE ?? '';
async function fetchJson(path, options = {}) {
    const url = `${API_BASE}${path}`;
    const headers = new Headers(options.headers);
    if (options.body && !headers.get('Content-Type')) {
        headers.set('Content-Type', 'application/json');
    }
    const response = await fetch(url, { ...options, headers });
    if (!response.ok) {
        let message = `Request failed with status ${response.status}`;
        try {
            const payload = await response.json();
            if (payload?.detail) {
                message = Array.isArray(payload.detail) ? payload.detail[0]?.msg ?? message : payload.detail;
            }
        }
        catch {
            // ignore JSON parse errors
        }
        const error = new Error(message);
        error.status = response.status;
        throw error;
    }
    if (response.status === 204) {
        return {};
    }
    return (await response.json());
}
export const getBanks = (userId) => {
    const query = userId ? `?user_id=${encodeURIComponent(userId)}` : '';
    return fetchJson(`/api/banks${query}`);
};
export const getDashboard = (userId) => fetchJson(`/api/dashboard?user_id=${encodeURIComponent(userId)}`);
export { fetchJson };
</file>

<file path="src/api/client.ts">
import type { DashboardResponse } from '../types/dashboard';

const API_BASE = import.meta.env.VITE_API_BASE ?? '';

type FetchOptions = RequestInit & { skipAuth?: boolean };

async function fetchJson<T = any>(path: string, options: FetchOptions = {}): Promise<T> {
  const url = `${API_BASE}${path}`;
  const headers = new Headers(options.headers);
  if (options.body && !headers.get('Content-Type')) {
    headers.set('Content-Type', 'application/json');
  }

  const response = await fetch(url, { ...options, headers });
  if (!response.ok) {
    let message = `Request failed with status ${response.status}`;
    try {
      const payload = await response.json();
      if (payload?.detail) {
        message = Array.isArray(payload.detail) ? payload.detail[0]?.msg ?? message : payload.detail;
      }
    } catch {
      // ignore JSON parse errors
    }
    const error = new Error(message);
    (error as Error & { status?: number }).status = response.status;
    throw error;
  }
  if (response.status === 204) {
    return {} as T;
  }
  return (await response.json()) as T;
}

export type BankResponse = {
  banks: Array<{
    id: string;
    name: string;
    connected: boolean;
    baseUrl?: string | null;
    status?: string;
    error?: string;
  }>;
};

export const getBanks = (userId?: string) => {
  const query = userId ? `?user_id=${encodeURIComponent(userId)}` : '';
  return fetchJson<BankResponse>(`/api/banks${query}`);
};

export const getDashboard = (userId: string) =>
  fetchJson<DashboardResponse>(`/api/dashboard?user_id=${encodeURIComponent(userId)}`);

export type { DashboardResponse };

export { fetchJson };
</file>

<file path="src/components/__tests__/BanksList.test.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { render, screen } from '@testing-library/react';
import { describe, expect, it } from 'vitest';
import { BanksList } from '../BanksList';
describe('BanksList', () => {
    it('renders empty state', () => {
        render(_jsx(BanksList, { banks: [] }));
        expect(screen.getByText(/  /i)).toBeInTheDocument();
    });
    it('shows connected status label', () => {
        const banks = [{ id: 'demo', name: 'Demo', connected: true }];
        render(_jsx(BanksList, { banks: banks }));
        expect(screen.getByText(/ /i)).toBeInTheDocument();
    });
});
</file>

<file path="src/components/__tests__/BanksList.test.tsx">
import { render, screen } from '@testing-library/react';
import { describe, expect, it } from 'vitest';
import { BanksList } from '../BanksList';
import type { BankSummary } from '../../state/useUser';

describe('BanksList', () => {
  it('renders empty state', () => {
    render(<BanksList banks={[]} />);
    expect(screen.getByText(/  /i)).toBeInTheDocument();
  });

  it('shows connected status label', () => {
    const banks: BankSummary[] = [{ id: 'demo', name: 'Demo', connected: true }];
    render(<BanksList banks={banks} />);
    expect(screen.getByText(/ /i)).toBeInTheDocument();
  });
});
</file>

<file path="src/components/__tests__/UserIdForm.test.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { fireEvent, render, screen } from '@testing-library/react';
import { describe, expect, it, vi } from 'vitest';
import { UserIdForm } from '../UserIdForm';
describe('UserIdForm', () => {
    it('validates demo-XXX format', () => {
        const handleSubmit = vi.fn();
        render(_jsx(UserIdForm, { onSubmit: handleSubmit }));
        const input = screen.getByLabelText(/user id/i);
        fireEvent.change(input, { target: { value: 'foo' } });
        const nameInput = screen.getByLabelText(/ /i);
        fireEvent.change(nameInput, { target: { value: '' } });
        const consentCheckbox = screen.getByLabelText(/ /i);
        fireEvent.click(consentCheckbox);
        fireEvent.click(screen.getByRole('button', { name: //i }));
        expect(screen.getByRole('alert')).toHaveTextContent(' team260-X');
        expect(handleSubmit).not.toHaveBeenCalled();
    });
});
</file>

<file path="src/components/__tests__/UserIdForm.test.tsx">
import { fireEvent, render, screen } from '@testing-library/react';
import { describe, expect, it, vi } from 'vitest';
import { UserIdForm } from '../UserIdForm';

describe('UserIdForm', () => {
  it('validates demo-XXX format', () => {
    const handleSubmit = vi.fn();
    render(<UserIdForm onSubmit={handleSubmit} />);

    const input = screen.getByLabelText(/user id/i);
    fireEvent.change(input, { target: { value: 'foo' } });
    const nameInput = screen.getByLabelText(/ /i);
    fireEvent.change(nameInput, { target: { value: '' } });
    const consentCheckbox = screen.getByLabelText(/ /i);
    fireEvent.click(consentCheckbox);
    fireEvent.click(screen.getByRole('button', { name: //i }));

    expect(screen.getByRole('alert')).toHaveTextContent(' team260-X');
    expect(handleSubmit).not.toHaveBeenCalled();
  });
});
</file>

<file path="src/components/BanksList.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
export const BanksList = ({ banks }) => {
    if (!banks.length) {
        return (_jsx("div", { className: "card", children: _jsx("p", { children: "\u041A\u0430\u0442\u0430\u043B\u043E\u0433 \u0431\u0430\u043D\u043A\u043E\u0432 \u043F\u0443\u0441\u0442. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0431\u044D\u043A\u0435\u043D\u0434\u0430." }) }));
    }
    return (_jsx("div", { className: "grid grid-two", children: banks.map((bank) => (_jsxs("div", { className: "card", children: [_jsx("h3", { children: bank.name }), _jsxs("p", { style: { marginTop: 4, color: '#475569' }, children: ["Base URL: ", bank.baseUrl || ' '] }), bank.error ? (_jsx("p", { style: { color: '#dc2626' }, children: bank.error })) : (_jsx("p", { style: { color: bank.connected ? '#16a34a' : '#475569' }, children: bank.connected ? ' ' : ' ' }))] }, bank.id))) }));
};
</file>

<file path="src/components/BanksList.tsx">
import React from 'react';
import type { BankSummary } from '../state/useUser';

type BanksListProps = {
  banks: BankSummary[];
};

export const BanksList: React.FC<BanksListProps> = ({ banks }) => {
  if (!banks.length) {
    return (
      <div className="card">
        <p>  .   .</p>
      </div>
    );
  }

  return (
    <div className="grid grid-two">
      {banks.map((bank) => (
        <div key={bank.id} className="card">
          <h3>{bank.name}</h3>
          <p style={{ marginTop: 4, color: '#475569' }}>Base URL: {bank.baseUrl || ' '}</p>
          {bank.error ? (
            <p style={{ color: '#dc2626' }}>{bank.error}</p>
          ) : (
            <p style={{ color: bank.connected ? '#16a34a' : '#475569' }}>
              {bank.connected ? ' ' : ' '}
            </p>
          )}
        </div>
      ))}
    </div>
  );
};
</file>

<file path="src/components/BanksOverviewCard.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
const formatCurrency = (value) => {
    if (value === null || value === undefined)
        return '';
    return new Intl.NumberFormat('ru-RU', {
        style: 'currency',
        currency: 'RUB',
        maximumFractionDigits: 0,
    }).format(value);
};
const formatTimestamp = (value) => {
    if (!value)
        return '';
    const date = new Date(value);
    if (Number.isNaN(date.getTime()))
        return value;
    return date.toLocaleString('ru-RU', {
        hour: '2-digit',
        minute: '2-digit',
        day: 'numeric',
        month: 'long',
    });
};
const STATUS_LABELS = {
    ok: { label: 'OK', tone: 'ok' },
    error: { label: '', tone: 'error' },
};
const toneClass = (tone) => (tone === 'error' ? 'status-pill status-pill--error' : 'status-pill');
export const BanksOverviewCard = ({ totalBalance, bankStatuses }) => {
    const entries = bankStatuses ?? [];
    return (_jsxs("div", { className: "card banks-overview", children: [_jsx("h2", { children: "\u0411\u0430\u043B\u0430\u043D\u0441 \u0438 \u0438\u0441\u0442\u043E\u0447\u043D\u0438\u043A\u0438 \u0434\u0430\u043D\u043D\u044B\u0445" }), _jsx("p", { className: "muted", children: "\u0421\u0443\u043C\u043C\u0430 \u043D\u0430 \u0432\u0441\u0435\u0445 \u0441\u0447\u0435\u0442\u0430\u0445 \u0432 \u0431\u0430\u043D\u043A\u0430\u0445, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u0442\u0432\u0435\u0442\u0438\u043B\u0438 \u043D\u0430 \u043D\u0430\u0448 \u0437\u0430\u043F\u0440\u043E\u0441." }), _jsx("div", { className: "banks-overview__summary", children: _jsxs("div", { children: [_jsx("p", { className: "muted", children: "\u0422\u0435\u043A\u0443\u0449\u0438\u0439 \u0431\u0430\u043B\u0430\u043D\u0441" }), _jsx("p", { className: "metric", children: formatCurrency(totalBalance) })] }) }), _jsx("div", { className: "banks-overview__list", children: entries.length === 0 ? (_jsx("p", { className: "muted", children: "\u041D\u0435\u0442 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0451\u043D\u043D\u044B\u0445 \u0431\u0430\u043D\u043A\u043E\u0432." })) : (entries.map((entry) => {
                    const statusInfo = STATUS_LABELS[entry.status] ?? { label: '', tone: 'error' };
                    return (_jsxs("div", { className: "banks-overview__row", children: [_jsxs("div", { children: [_jsx("p", { className: "banks-overview__bank", children: entry.bank_name }), _jsxs("p", { className: "banks-overview__message", children: ["\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043E: ", formatTimestamp(entry.fetched_at)] })] }), _jsx("span", { className: toneClass(statusInfo.tone), children: statusInfo.label })] }, entry.bank_id));
                })) })] }));
};
export default BanksOverviewCard;
</file>

<file path="src/components/BanksOverviewCard.tsx">
import React from 'react';

import type { BankStatus } from '../types/dashboard';

type BanksOverviewCardProps = {
  totalBalance: number;
  bankStatuses: BankStatus[];
};

const formatCurrency = (value?: number | null) => {
  if (value === null || value === undefined) return '';
  return new Intl.NumberFormat('ru-RU', {
    style: 'currency',
    currency: 'RUB',
    maximumFractionDigits: 0,
  }).format(value);
};

const formatTimestamp = (value?: string | null) => {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return value;
  return date.toLocaleString('ru-RU', {
    hour: '2-digit',
    minute: '2-digit',
    day: 'numeric',
    month: 'long',
  });
};

const STATUS_LABELS: Record<string, { label: string; tone: 'ok' | 'error' }> = {
  ok: { label: 'OK', tone: 'ok' },
  error: { label: '', tone: 'error' },
};

const toneClass = (tone: 'ok' | 'error') => (tone === 'error' ? 'status-pill status-pill--error' : 'status-pill');

export const BanksOverviewCard: React.FC<BanksOverviewCardProps> = ({ totalBalance, bankStatuses }) => {
  const entries = bankStatuses ?? [];

  return (
    <div className="card banks-overview">
      <h2>   </h2>
      <p className="muted">     ,      .</p>
      <div className="banks-overview__summary">
        <div>
          <p className="muted"> </p>
          <p className="metric">{formatCurrency(totalBalance)}</p>
        </div>
      </div>

      <div className="banks-overview__list">
        {entries.length === 0 ? (
          <p className="muted">  .</p>
        ) : (
          entries.map((entry) => {
            const statusInfo = STATUS_LABELS[entry.status] ?? { label: '', tone: 'error' };
            return (
              <div key={entry.bank_id} className="banks-overview__row">
                <div>
                  <p className="banks-overview__bank">{entry.bank_name}</p>
                  <p className="banks-overview__message">: {formatTimestamp(entry.fetched_at)}</p>
                </div>
                <span className={toneClass(statusInfo.tone)}>{statusInfo.label}</span>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};

export default BanksOverviewCard;
</file>

<file path="src/components/UserIdForm.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState } from 'react';
export const USER_ID_PATTERN = /^team260-([1-9]|10)$/i;
export const validateUserId = (value) => USER_ID_PATTERN.test(value.trim());
export const UserIdForm = ({ defaultUserId = '', defaultUserName = '', onSubmit, isSubmitting, }) => {
    const [userId, setUserId] = useState(defaultUserId ?? '');
    const [userName, setUserName] = useState(defaultUserName ?? '');
    const [agreed, setAgreed] = useState(false);
    const [error, setError] = useState(null);
    const handleSubmit = async (event) => {
        event.preventDefault();
        const trimmedId = userId.trim();
        const trimmedName = userName.trim();
        if (!validateUserId(trimmedId)) {
            setError('ID     team260-X,  X  1  10');
            return;
        }
        if (!trimmedName) {
            setError(',   ');
            return;
        }
        if (!agreed) {
            setError('     ');
            return;
        }
        setError(null);
        await onSubmit(trimmedId, trimmedName);
    };
    return (_jsxs("form", { className: "card", onSubmit: handleSubmit, children: [_jsx("h2", { children: "\u0428\u0430\u0433 1. \u0418\u0434\u0435\u043D\u0442\u0438\u0444\u0438\u043A\u0430\u0446\u0438\u044F" }), _jsx("p", { children: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u0448 ID \u0438 \u0438\u043C\u044F \u0434\u043B\u044F \u043D\u0430\u0447\u0430\u043B\u0430 \u0440\u0430\u0431\u043E\u0442\u044B." }), _jsx("label", { htmlFor: "user-id-input", children: "User ID" }), _jsx("input", { id: "user-id-input", value: userId, onChange: (e) => setUserId(e.target.value), placeholder: "team260-1", className: "text-input", disabled: isSubmitting }), _jsx("label", { htmlFor: "user-name-input", children: "\u0412\u0430\u0448\u0435 \u0438\u043C\u044F" }), _jsx("input", { id: "user-name-input", value: userName, onChange: (e) => setUserName(e.target.value), placeholder: "\u0418\u0432\u0430\u043D \u0418\u0432\u0430\u043D\u043E\u0432", className: "text-input", disabled: isSubmitting }), _jsxs("label", { style: { display: 'flex', gap: 12, alignItems: 'center', margin: '16px 0' }, children: [_jsx("input", { type: "checkbox", checked: agreed, onChange: (e) => setAgreed(e.target.checked) }), _jsx("span", { children: "\u042F \u0441\u043E\u0433\u043B\u0430\u0441\u0435\u043D \u043D\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0443 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u044C\u043D\u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445" })] }), error ? (_jsx("p", { role: "alert", style: { color: '#dc2626', marginTop: 8 }, children: error })) : null, _jsx("button", { type: "submit", className: "btn", disabled: isSubmitting || !agreed, children: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C" })] }));
};
</file>

<file path="src/components/UserIdForm.tsx">
import React, { useState } from 'react';

export const USER_ID_PATTERN = /^team260-([1-9]|10)$/i;
export const validateUserId = (value: string): boolean => USER_ID_PATTERN.test(value.trim());

type UserIdFormProps = {
  defaultUserId?: string | null;
  defaultUserName?: string | null;
  onSubmit: (userId: string, userName: string) => void | Promise<void>;
  isSubmitting?: boolean;
};

export const UserIdForm: React.FC<UserIdFormProps> = ({
  defaultUserId = '',
  defaultUserName = '',
  onSubmit,
  isSubmitting,
}) => {
  const [userId, setUserId] = useState(defaultUserId ?? '');
  const [userName, setUserName] = useState(defaultUserName ?? '');
  const [agreed, setAgreed] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    const trimmedId = userId.trim();
    const trimmedName = userName.trim();

    if (!validateUserId(trimmedId)) {
      setError('ID     team260-X,  X  1  10');
      return;
    }
    if (!trimmedName) {
      setError(',   ');
      return;
    }
    if (!agreed) {
      setError('     ');
      return;
    }
    setError(null);
    await onSubmit(trimmedId, trimmedName);
  };

  return (
    <form className="card" onSubmit={handleSubmit}>
      <h2> 1. </h2>
      <p>  ID     .</p>

      <label htmlFor="user-id-input">User ID</label>
      <input
        id="user-id-input"
        value={userId}
        onChange={(e) => setUserId(e.target.value)}
        placeholder="team260-1"
        className="text-input"
        disabled={isSubmitting}
      />

      <label htmlFor="user-name-input"> </label>
      <input
        id="user-name-input"
        value={userName}
        onChange={(e) => setUserName(e.target.value)}
        placeholder=" "
        className="text-input"
        disabled={isSubmitting}
      />

      <label style={{ display: 'flex', gap: 12, alignItems: 'center', margin: '16px 0' }}>
        <input type="checkbox" checked={agreed} onChange={(e) => setAgreed(e.target.checked)} />
        <span>     </span>
      </label>

      {error ? (
        <p role="alert" style={{ color: '#dc2626', marginTop: 8 }}>
          {error}
        </p>
      ) : null}
      <button type="submit" className="btn" disabled={isSubmitting || !agreed}>
        
      </button>
    </form>
  );
};
</file>

<file path="src/pages/__tests__/DashboardPage.test.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { render, screen, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { DashboardPage } from '../DashboardPage.tsx';
const dashboardStub = {
    total_balance: 150000,
    bank_statuses: [
        { bank_id: 'vbank', bank_name: 'VBank', status: 'ok', fetched_at: new Date().toISOString() },
        { bank_id: 'abank', bank_name: 'ABank', status: 'error', fetched_at: null },
    ],
    safe_to_spend_daily: 3500,
    salary_amount: 80000,
    next_salary_date: '2025-12-25',
    days_until_next_salary: 10,
    upcoming_credit_payment: {
        amount: 12000,
        next_payment_date: '2025-12-18',
    },
};
vi.mock('../../state/useUser', () => ({
    useUser: () => ({
        userId: 'demo-user',
    }),
}));
const notifyError = vi.fn();
vi.mock('../../state/notifications', () => ({
    useNotifications: () => ({
        notifyError,
    }),
}));
const mockGetDashboard = vi.fn();
vi.mock('../../api/client', () => ({
    getDashboard: (...args) => mockGetDashboard(...args),
}));
describe('DashboardPage', () => {
    beforeEach(() => {
        mockGetDashboard.mockResolvedValue(dashboardStub);
    });
    afterEach(() => {
        vi.clearAllMocks();
    });
    it('renders Safe-to-Spend metric with salary metadata', async () => {
        render(_jsx(DashboardPage, {}));
        await waitFor(() => expect(mockGetDashboard).toHaveBeenCalledWith('demo-user'));
        expect(screen.getByRole('heading', { name: /Safe-to-Spend/i })).toBeInTheDocument();
        expect(screen.getByText(/3.?500/)).toBeInTheDocument();
        expect(screen.getByText(/:/i)).toBeInTheDocument();
        expect(screen.getByText(/   /i)).toBeInTheDocument();
    });
    it('renders the bank overview card with each status', async () => {
        render(_jsx(DashboardPage, {}));
        await waitFor(() => expect(mockGetDashboard).toHaveBeenCalled());
        expect(screen.getByRole('heading', { name: /   /i })).toBeInTheDocument();
        expect(screen.getByText('VBank')).toBeInTheDocument();
        expect(screen.getByText('ABank')).toBeInTheDocument();
        expect(screen.getByText('OK')).toBeInTheDocument();
        expect(screen.getByText('')).toBeInTheDocument();
    });
    it('shows an error notification if the API call fails', async () => {
        const error = new Error('API is down');
        mockGetDashboard.mockRejectedValueOnce(error);
        render(_jsx(DashboardPage, {}));
        await waitFor(() => expect(notifyError).toHaveBeenCalledWith('     .'));
    });
});
</file>

<file path="src/pages/__tests__/DashboardPage.test.tsx">
import { render, screen, waitFor } from '@testing-library/react';
import React from 'react';
import { vi } from 'vitest';
import type { DashboardResponse } from '../../types/dashboard';
import { DashboardPage } from '../DashboardPage.tsx';

const dashboardStub: DashboardResponse = {
  total_balance: 150000,
  bank_statuses: [
    { bank_id: 'vbank', bank_name: 'VBank', status: 'ok', fetched_at: new Date().toISOString() },
    { bank_id: 'abank', bank_name: 'ABank', status: 'error', fetched_at: null },
  ],
  safe_to_spend_daily: 3500,
  salary_amount: 80000,
  next_salary_date: '2025-12-25',
  days_until_next_salary: 10,
  upcoming_credit_payment: {
    amount: 12000,
    next_payment_date: '2025-12-18',
  },
};

vi.mock('../../state/useUser', () => ({
  useUser: () => ({
    userId: 'demo-user',
  }),
}));

const notifyError = vi.fn();

vi.mock('../../state/notifications', () => ({
  useNotifications: () => ({
    notifyError,
  }),
}));

const mockGetDashboard = vi.fn();

vi.mock('../../api/client', () => ({
  getDashboard: (...args: unknown[]) => mockGetDashboard(...args),
}));

describe('DashboardPage', () => {
  beforeEach(() => {
    mockGetDashboard.mockResolvedValue(dashboardStub);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('renders Safe-to-Spend metric with salary metadata', async () => {
    render(<DashboardPage />);
    await waitFor(() => expect(mockGetDashboard).toHaveBeenCalledWith('demo-user'));

    expect(screen.getByRole('heading', { name: /Safe-to-Spend/i })).toBeInTheDocument();
    expect(screen.getByText(/3.?500/)).toBeInTheDocument();
    expect(screen.getByText(/:/i)).toBeInTheDocument();
    expect(screen.getByText(/   /i)).toBeInTheDocument();
  });

  it('renders the bank overview card with each status', async () => {
    render(<DashboardPage />);
    await waitFor(() => expect(mockGetDashboard).toHaveBeenCalled());

    expect(screen.getByRole('heading', { name: /   /i })).toBeInTheDocument();
    expect(screen.getByText('VBank')).toBeInTheDocument();
    expect(screen.getByText('ABank')).toBeInTheDocument();
    expect(screen.getByText('OK')).toBeInTheDocument();
    expect(screen.getByText('')).toBeInTheDocument();
  });

  it('shows an error notification if the API call fails', async () => {
    const error = new Error('API is down');
    mockGetDashboard.mockRejectedValueOnce(error);
    render(<DashboardPage />);
    await waitFor(() =>
      expect(notifyError).toHaveBeenCalledWith('     .'),
    );
  });
});
</file>

<file path="src/pages/BanksCatalogPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect } from 'react';
import { BanksList } from '../components/BanksList';
import { useUser } from '../state/useUser';
export const BanksCatalogPage = () => {
    const { userId, banks, refreshBanks, isFetchingBanks } = useUser();
    useEffect(() => {
        if (userId) {
            refreshBanks();
        }
    }, [userId, refreshBanks]);
    return (_jsxs("div", { className: "app-main", children: [_jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0411\u0430\u043D\u043A\u043E\u0432\u0441\u043A\u0438\u0435 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u044F" }), _jsx("p", { children: "\u0421\u043F\u0438\u0441\u043E\u043A \u0431\u0430\u043D\u043A\u043E\u0432, \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u044B\u0445 \u0434\u043B\u044F \u0440\u0430\u0441\u0447\u0451\u0442\u0430 Safe-to-Spend." })] }), isFetchingBanks ? (_jsx("div", { className: "card", children: _jsx("p", { children: "\u0417\u0430\u0433\u0440\u0443\u0436\u0430\u0435\u043C \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044E \u043E \u0431\u0430\u043D\u043A\u0430\u0445..." }) })) : (_jsx(BanksList, { banks: banks }))] }));
};
</file>

<file path="src/pages/BanksCatalogPage.tsx">
import React, { useEffect } from 'react';
import { BanksList } from '../components/BanksList';
import { useUser } from '../state/useUser';

export const BanksCatalogPage: React.FC = () => {
  const { userId, banks, refreshBanks, isFetchingBanks } = useUser();

  useEffect(() => {
    if (userId) {
      refreshBanks();
    }
  }, [userId, refreshBanks]);

  return (
    <div className="app-main">
      <div className="card">
        <h2> </h2>
        <p> ,    Safe-to-Spend.</p>
      </div>

      {isFetchingBanks ? (
        <div className="card">
          <p>   ...</p>
        </div>
      ) : (
        <BanksList banks={banks} />
      )}
    </div>
  );
};
</file>

<file path="src/pages/DashboardPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useState } from 'react';
import { getDashboard } from '../api/client';
import { useUser } from '../state/useUser';
import { useNotifications } from '../state/notifications';
import { BanksOverviewCard } from '../components/BanksOverviewCard';
const formatCurrency = (value) => {
    if (value === null || value === undefined)
        return '';
    return new Intl.NumberFormat('ru-RU', {
        style: 'currency',
        currency: 'RUB',
        maximumFractionDigits: 0,
    }).format(value);
};
const formatDate = (value) => {
    if (!value)
        return '';
    const parsed = new Date(value);
    if (Number.isNaN(parsed.getTime())) {
        return value;
    }
    return parsed.toLocaleDateString('ru-RU', { day: 'numeric', month: 'long' });
};
const STSCard = ({ data }) => {
    const nextSalaryLabel = formatDate(data.next_salary_date);
    const creditPaymentLabel = formatDate(data.upcoming_credit_payment?.next_payment_date);
    return (_jsxs("div", { className: "card", children: [_jsx("h2", { children: "Safe-to-Spend" }), _jsxs("p", { className: "muted", children: ["\u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0434\u043D\u0435\u0432\u043D\u043E\u0439 \u043B\u0438\u043C\u0438\u0442 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439 \u0437\u0430\u0440\u043F\u043B\u0430\u0442\u044B (", nextSalaryLabel, ")."] }), _jsxs("p", { className: "metric", children: [formatCurrency(data.safe_to_spend_daily), _jsx("span", { children: " / \u0434\u0435\u043D\u044C" })] }), _jsxs("div", { className: "safe-obligations", children: [_jsxs("div", { children: ["\u0417\u0430\u0440\u043F\u043B\u0430\u0442\u0430: ", _jsx("strong", { children: formatCurrency(data.salary_amount) })] }), _jsxs("div", { children: ["\u0414\u043D\u0435\u0439 \u0434\u043E \u0432\u044B\u043F\u043B\u0430\u0442\u044B: ", _jsx("strong", { children: data.days_until_next_salary })] }), _jsxs("div", { children: ["\u0411\u043B\u0438\u0436\u0430\u0439\u0448\u0438\u0439 \u043F\u043B\u0430\u0442\u0451\u0436 \u043F\u043E \u043A\u0440\u0435\u0434\u0438\u0442\u0443: ", formatCurrency(data.upcoming_credit_payment?.amount), " (", creditPaymentLabel, ")"] })] })] }));
};
export const DashboardPage = () => {
    const { userId } = useUser();
    const { notifyError } = useNotifications();
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    useEffect(() => {
        if (!userId)
            return;
        const load = async () => {
            try {
                setLoading(true);
                const payload = await getDashboard(userId);
                setData(payload);
            }
            catch (error) {
                console.error(error);
                notifyError('     .');
            }
            finally {
                setLoading(false);
            }
        };
        load();
    }, [notifyError, userId]);
    if (loading) {
        return (_jsx("div", { className: "app-main", children: _jsx("div", { className: "card", children: _jsx("p", { children: "\u0410\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u0443\u0435\u043C \u0432\u0430\u0448\u0438 \u0444\u0438\u043D\u0430\u043D\u0441\u044B \u0438 \u0441\u0442\u0440\u043E\u0438\u043C \u043F\u0440\u043E\u0433\u043D\u043E\u0437\u044B..." }) }) }));
    }
    if (!data) {
        return (_jsx("div", { className: "app-main", children: _jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u041D\u0435\u0442 \u0434\u0430\u043D\u043D\u044B\u0445" }), _jsx("p", { children: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0430\u043D\u0430\u043B\u0438\u0442\u0438\u043A\u0443. \u0412\u043E\u0437\u043C\u043E\u0436\u043D\u043E, \u043D\u0443\u0436\u043D\u043E \u043F\u0440\u043E\u0439\u0442\u0438 \u043E\u043D\u0431\u043E\u0440\u0434\u0438\u043D\u0433 \u0437\u0430\u043D\u043E\u0432\u043E." })] }) }));
    }
    return (_jsxs("div", { className: "app-main", children: [_jsx(STSCard, { data: data }), _jsx(BanksOverviewCard, { totalBalance: data.total_balance, bankStatuses: data.bank_statuses })] }));
};
export default DashboardPage;
</file>

<file path="src/pages/DashboardPage.tsx">
import React, { useEffect, useState } from 'react';
import { getDashboard } from '../api/client';
import { useUser } from '../state/useUser';
import { useNotifications } from '../state/notifications';
import type { DashboardResponse } from '../types/dashboard';
import { BanksOverviewCard } from '../components/BanksOverviewCard';

const formatCurrency = (value?: number | null) => {
  if (value === null || value === undefined) return '';
  return new Intl.NumberFormat('ru-RU', {
    style: 'currency',
    currency: 'RUB',
    maximumFractionDigits: 0,
  }).format(value);
};

const formatDate = (value?: string | null) => {
  if (!value) return '';
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    return value;
  }
  return parsed.toLocaleDateString('ru-RU', { day: 'numeric', month: 'long' });
};

const STSCard: React.FC<{ data: DashboardResponse }> = ({ data }) => {
  const nextSalaryLabel = formatDate(data.next_salary_date);
  const creditPaymentLabel = formatDate(data.upcoming_credit_payment?.next_payment_date);

  return (
    <div className="card">
      <h2>Safe-to-Spend</h2>
      <p className="muted">      ({nextSalaryLabel}).</p>
      <p className="metric">
        {formatCurrency(data.safe_to_spend_daily)}
        <span> / </span>
      </p>
      <div className="safe-obligations">
        <div>
          : <strong>{formatCurrency(data.salary_amount)}</strong>
        </div>
        <div>
            : <strong>{data.days_until_next_salary}</strong>
        </div>
        <div>
             : {formatCurrency(data.upcoming_credit_payment?.amount)} ({creditPaymentLabel})
        </div>
      </div>
    </div>
  );
};

export const DashboardPage: React.FC = () => {
  const { userId } = useUser();
  const { notifyError } = useNotifications();
  const [data, setData] = useState<DashboardResponse | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!userId) return;
    const load = async () => {
      try {
        setLoading(true);
        const payload = await getDashboard(userId);
        setData(payload);
      } catch (error) {
        console.error(error);
        notifyError('     .');
      } finally {
        setLoading(false);
      }
    };
    load();
  }, [notifyError, userId]);

  if (loading) {
    return (
      <div className="app-main">
        <div className="card">
          <p>     ...</p>
        </div>
      </div>
    );
  }

  if (!data) {
    return (
      <div className="app-main">
        <div className="card">
          <h2> </h2>
          <p>   . ,    .</p>
        </div>
      </div>
    );
  }

  return (
    <div className="app-main">
      <STSCard data={data} />
      <BanksOverviewCard totalBalance={data.total_balance} bankStatuses={data.bank_statuses} />
    </div>
  );
};

export default DashboardPage;
</file>

<file path="src/pages/UserIdPage.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { UserIdForm } from '../components/UserIdForm';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';
export const UserIdPage = () => {
    const { userId, userName, setInitialUserData } = useUser();
    const { notifySuccess, notifyError } = useNotifications();
    const navigate = useNavigate();
    const [isSubmitting, setIsSubmitting] = useState(false);
    const handleSubmit = async (nextId, nextName) => {
        try {
            setIsSubmitting(true);
            setInitialUserData(nextId.toLowerCase(), nextName);
            notifySuccess('ID   ');
            navigate('/banks');
        }
        catch (error) {
            console.error(error);
            notifyError('   ');
        }
        finally {
            setIsSubmitting(false);
        }
    };
    return (_jsx("div", { className: "app-main", children: _jsx(UserIdForm, { defaultUserId: userId, defaultUserName: userName, onSubmit: handleSubmit, isSubmitting: isSubmitting }) }));
};
</file>

<file path="src/pages/UserIdPage.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { UserIdForm } from '../components/UserIdForm';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';

export const UserIdPage: React.FC = () => {
  const { userId, userName, setInitialUserData } = useUser();
  const { notifySuccess, notifyError } = useNotifications();
  const navigate = useNavigate();
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (nextId: string, nextName: string) => {
    try {
      setIsSubmitting(true);
      setInitialUserData(nextId.toLowerCase(), nextName);
      notifySuccess('ID   ');
      navigate('/banks');
    } catch (error) {
      console.error(error);
      notifyError('   ');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="app-main">
      <UserIdForm
        defaultUserId={userId}
        defaultUserName={userName}
        onSubmit={handleSubmit}
        isSubmitting={isSubmitting}
      />
    </div>
  );
};
</file>

<file path="src/state/notifications.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useMemo, useState } from 'react';
const NotificationsContext = createContext(undefined);
export const NotificationsProvider = ({ children }) => {
    const [items, setItems] = useState([]);
    const dismiss = useCallback((id) => {
        setItems((prev) => prev.filter((item) => item.id !== id));
    }, []);
    const notify = useCallback((message, type = 'info') => {
        const id = `${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
        setItems((prev) => [...prev, { id, message, type }]);
        window.setTimeout(() => dismiss(id), 5000);
    }, [dismiss]);
    const contextValue = useMemo(() => ({
        notify,
        notifyError: (msg) => notify(msg, 'error'),
        notifySuccess: (msg) => notify(msg, 'success'),
    }), [notify]);
    return (_jsxs(NotificationsContext.Provider, { value: contextValue, children: [children, _jsx("div", { className: "toast-stack", role: "status", "aria-live": "polite", children: items.map((item) => (_jsx("div", { className: `toast toast-${item.type}`, children: item.message }, item.id))) })] }));
};
export const useNotifications = () => {
    const ctx = useContext(NotificationsContext);
    if (!ctx) {
        throw new Error('useNotifications must be used inside NotificationsProvider');
    }
    return ctx;
};
</file>

<file path="src/state/notifications.tsx">
import React, { createContext, useCallback, useContext, useMemo, useState } from 'react';

type Notification = {
  id: string;
  message: string;
  type: 'info' | 'error' | 'success';
};

type NotificationsContextValue = {
  notify: (message: string, type?: Notification['type']) => void;
  notifyError: (message: string) => void;
  notifySuccess: (message: string) => void;
};

const NotificationsContext = createContext<NotificationsContextValue | undefined>(undefined);

export const NotificationsProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const [items, setItems] = useState<Notification[]>([]);

  const dismiss = useCallback((id: string) => {
    setItems((prev) => prev.filter((item) => item.id !== id));
  }, []);

  const notify = useCallback(
    (message: string, type: Notification['type'] = 'info') => {
      const id = `${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
      setItems((prev) => [...prev, { id, message, type }]);
      window.setTimeout(() => dismiss(id), 5000);
    },
    [dismiss]
  );

  const contextValue = useMemo<NotificationsContextValue>(
    () => ({
      notify,
      notifyError: (msg: string) => notify(msg, 'error'),
      notifySuccess: (msg: string) => notify(msg, 'success'),
    }),
    [notify]
  );

  return (
    <NotificationsContext.Provider value={contextValue}>
      {children}
      <div className="toast-stack" role="status" aria-live="polite">
        {items.map((item) => (
          <div key={item.id} className={`toast toast-${item.type}`}>
            {item.message}
          </div>
        ))}
      </div>
    </NotificationsContext.Provider>
  );
};

export const useNotifications = (): NotificationsContextValue => {
  const ctx = useContext(NotificationsContext);
  if (!ctx) {
    throw new Error('useNotifications must be used inside NotificationsProvider');
  }
  return ctx;
};
</file>

<file path="src/state/useUser.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';
import { getBanks } from '../api/client';
const STORAGE_KEY = 'finpulse:userId';
const USER_NAME_KEY = 'finpulse:userName';
const UserContext = createContext(undefined);
export const UserProvider = ({ children }) => {
    const [userId, setUserIdState] = useState(() => localStorage.getItem(STORAGE_KEY));
    const [userName, setUserNameState] = useState(() => localStorage.getItem(USER_NAME_KEY));
    const [banks, setBanks] = useState([]);
    const [isFetchingBanks, setIsFetchingBanks] = useState(false);
    const setInitialUserData = useCallback((nextId, nextName) => {
        localStorage.setItem(STORAGE_KEY, nextId);
        localStorage.setItem(USER_NAME_KEY, nextName);
        setUserIdState(nextId);
        setUserNameState(nextName);
    }, []);
    const clearUser = useCallback(() => {
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(USER_NAME_KEY);
        setUserIdState(null);
        setUserNameState(null);
        setBanks([]);
    }, []);
    const refreshBanks = useCallback(async () => {
        if (!userId) {
            setBanks([]);
            return;
        }
        try {
            setIsFetchingBanks(true);
            const response = await getBanks(userId);
            setBanks(response.banks ?? []);
        }
        catch (error) {
            console.error('Failed to fetch banks', error);
        }
        finally {
            setIsFetchingBanks(false);
        }
    }, [userId]);
    useEffect(() => {
        if (userId) {
            refreshBanks();
        }
    }, [userId, refreshBanks]);
    const value = useMemo(() => ({
        userId,
        userName,
        setInitialUserData,
        clearUser,
        banks,
        refreshBanks,
        isFetchingBanks,
    }), [banks, clearUser, isFetchingBanks, refreshBanks, setInitialUserData, userId, userName]);
    return _jsx(UserContext.Provider, { value: value, children: children });
};
export const useUser = () => {
    const ctx = useContext(UserContext);
    if (!ctx) {
        throw new Error('useUser must be used inside UserProvider');
    }
    return ctx;
};
</file>

<file path="src/state/useUser.tsx">
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';
import { getBanks } from '../api/client';

export type BankSummary = {
  id: string;
  name: string;
  connected: boolean;
  baseUrl?: string | null;
  status?: string;
  error?: string;
};

type UserContextValue = {
  userId: string | null;
  userName: string | null;
  setInitialUserData: (nextId: string, nextName: string) => void;
  clearUser: () => void;
  banks: BankSummary[];
  refreshBanks: () => Promise<void>;
  isFetchingBanks: boolean;
};

const STORAGE_KEY = 'finpulse:userId';
const USER_NAME_KEY = 'finpulse:userName';

const UserContext = createContext<UserContextValue | undefined>(undefined);

export const UserProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const [userId, setUserIdState] = useState<string | null>(() => localStorage.getItem(STORAGE_KEY));
  const [userName, setUserNameState] = useState<string | null>(() => localStorage.getItem(USER_NAME_KEY));
  const [banks, setBanks] = useState<BankSummary[]>([]);
  const [isFetchingBanks, setIsFetchingBanks] = useState(false);

  const setInitialUserData = useCallback((nextId: string, nextName: string) => {
    localStorage.setItem(STORAGE_KEY, nextId);
    localStorage.setItem(USER_NAME_KEY, nextName);
    setUserIdState(nextId);
    setUserNameState(nextName);
  }, []);

  const clearUser = useCallback(() => {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(USER_NAME_KEY);
    setUserIdState(null);
    setUserNameState(null);
    setBanks([]);
  }, []);

  const refreshBanks = useCallback(async () => {
    if (!userId) {
      setBanks([]);
      return;
    }
    try {
      setIsFetchingBanks(true);
      const response = await getBanks(userId);
      setBanks(response.banks ?? []);
    } catch (error) {
      console.error('Failed to fetch banks', error);
    } finally {
      setIsFetchingBanks(false);
    }
  }, [userId]);

  useEffect(() => {
    if (userId) {
      refreshBanks();
    }
  }, [userId, refreshBanks]);

  const value = useMemo<UserContextValue>(
    () => ({
      userId,
      userName,
      setInitialUserData,
      clearUser,
      banks,
      refreshBanks,
      isFetchingBanks,
    }),
    [banks, clearUser, isFetchingBanks, refreshBanks, setInitialUserData, userId, userName]
  );

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
};

export const useUser = (): UserContextValue => {
  const ctx = useContext(UserContext);
  if (!ctx) {
    throw new Error('useUser must be used inside UserProvider');
  }
  return ctx;
};
</file>

<file path="src/styles/global.css">
:root {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  color: #0f172a;
  background-color: #f5f7fb;
  --color-surface: #fff;
  --color-border: rgba(15, 23, 42, 0.08);
  --color-muted: #64748b;
  --color-chip-credit: #eef2ff;
  --color-chip-income: #dcfce7;
  --color-chip-debit: #fee2e2;
  --color-chip-neutral: #e2e8f0;
  --color-chip-balance: #dbeafe;
  --radius-pill: 999px;
  --radius-md: 16px;
  --space-xxs: 4px;
  --space-xs: 8px;
  --space-sm: 12px;
  --space-md: 16px;
  --space-lg: 20px;
}

* {
  box-sizing: border-box;
}

body,
#root {
  margin: 0;
  min-height: 100vh;
}

body {
  background: linear-gradient(180deg, #f5f7fb 0%, #edf0f9 100%);
}

a {
  color: #2563eb;
  text-decoration: none;
}

.app-shell {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-main {
  flex: 1;
  padding: 24px;
  max-width: 900px;
  margin: 0 auto;
}

.card {
  background: var(--color-surface);
  border-radius: var(--radius-md);
  border: 1px solid var(--color-border);
  padding: var(--space-lg);
  margin-bottom: 16px;
  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
}

.card h2 {
  margin-top: 0;
}

.btn {
  border: none;
  border-radius: 999px;
  padding: 10px 18px;
  cursor: pointer;
  font-weight: 600;
  background: #2563eb;
  color: #fff;
  transition: opacity 0.2s ease;
}

.btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.btn-secondary {
  background: #fff;
  color: #0f172a;
  border: 1px solid rgba(15, 23, 42, 0.2);
}

.toast-stack {
  position: fixed;
  top: 16px;
  right: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 999;
}

.toast {
  padding: 12px 16px;
  border-radius: 8px;
  color: #fff;
  box-shadow: 0 12px 20px rgba(0, 0, 0, 0.15);
}

.toast-info {
  background: #2563eb;
}

.toast-success {
  background: #16a34a;
}

.toast-error {
  background: #dc2626;
}

.grid {
  display: grid;
  gap: 16px;
}

.grid-two {
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
}

.list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.list li {
  padding: 12px 0;
  border-bottom: 1px solid rgba(15, 23, 42, 0.08);
}

.list--dense li {
  padding: 12px 0;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: var(--space-sm);
  flex-wrap: wrap;
}

.muted {
  color: var(--color-muted);
  margin: 4px 0;
}

.chip {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  border-radius: var(--radius-pill);
  font-size: 13px;
  padding: 4px 10px;
  background: var(--color-chip-neutral);
  color: #0f172a;
  border: 1px solid rgba(15, 23, 42, 0.06);
}

.chip--balance {
  background: var(--color-chip-balance);
}

.chip--credit {
  background: var(--color-chip-credit);
}

.chip--derived {
  background: #fde68a;
}

.chip--neutral {
  background: var(--color-chip-neutral);
}

.chip--source.chip--income {
  background: var(--color-chip-income);
}

.chip--source.chip--debit {
  background: var(--color-chip-debit);
}

.chip--source.chip--credit {
  background: var(--color-chip-credit);
}

.metadata-badges {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-xs);
  margin-top: var(--space-xs);
}

.metadata-badge {
  padding: 4px 8px;
  border-radius: 10px;
  font-size: 13px;
  background: var(--color-chip-neutral);
  border: 1px solid rgba(15, 23, 42, 0.06);
}

.metadata-badge--merchant {
  background: #e0f2fe;
}

.metadata-badge--mcc {
  background: #ede9fe;
}

.metadata-badge--code {
  background: #fee2e2;
}

.metadata-badge--obligation {
  background: #fef3c7;
}

.metadata-badge--muted {
  background: transparent;
  border-style: dashed;
  color: var(--color-muted);
}

.event-row {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.event-row__header {
  display: flex;
  justify-content: space-between;
  gap: var(--space-sm);
}

.event-row__title {
  font-weight: 600;
  margin: 0 0 4px;
}

.event-row__subtitle {
  margin: 0;
  color: var(--color-muted);
  font-size: 14px;
}

.event-row__amount {
  min-width: 160px;
  text-align: right;
}

.obligation-row {
  border-left: 3px solid transparent;
  padding-left: var(--space-sm);
}

.obligation-row--derived {
  border-left-color: #f59e0b;
}

.filter-row {
  display: flex;
  gap: var(--space-sm);
  flex-wrap: wrap;
}

.filter-row label {
  display: flex;
  flex-direction: column;
  font-size: 13px;
  color: var(--color-muted);
}

.safe-card {
  position: relative;
  overflow: hidden;
}

.safe-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: var(--space-md);
  margin: var(--space-md) 0;
}

.metric {
  font-size: 2.5rem;
  font-weight: 700;
  margin: 8px 0;
}

.metric span {
  font-size: 1rem;
  font-weight: 400;
  color: var(--color-muted);
}

.safe-recommendation {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-xs);
  align-items: baseline;
  padding: 8px 12px;
  background: #ecfccb;
  border-radius: 8px;
  margin-bottom: 12px;
}

.safe-obligations {
  border-top: 1px solid var(--color-border);
  margin-top: var(--space-md);
  padding-top: var(--space-sm);
  font-size: 14px;
  display: grid;
  gap: 4px;
}

.callout {
  border-radius: var(--radius-md);
  border: 1px solid;
  padding: var(--space-sm);
  font-size: 0.9rem;
  margin: var(--space-sm) 0;
}

.callout--warning {
  background: #fef3c7;
  border-color: #f97316;
  color: #7c2d12;
}

.callout--info {
  background: #ecfeff;
  border-color: #0ea5e9;
  color: #0f172a;
}

.snapshot-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: var(--space-sm);
  margin-top: var(--space-sm);
}

.snapshot-item {
  padding: var(--space-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  background: #f9fafb;
}

.credit-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--space-sm);
}

.credit-row__metrics {
  display: flex;
  flex-direction: column;
  gap: 4px;
  text-align: right;
}

.metadata-transactions {
  list-style: none;
  padding-left: 0;
  display: grid;
  gap: 4px;
}

.metadata-transactions li {
  display: grid;
  grid-template-columns: minmax(80px, 120px) 80px 1fr;
  gap: 8px;
  font-size: 13px;
  border-bottom: 1px dashed rgba(15, 23, 42, 0.08);
  padding-bottom: 4px;
}

.portrait-summary {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-xs);
  margin-bottom: var(--space-sm);
}

.portrait-event {
  padding-bottom: var(--space-sm);
}

.portrait-event__header {
  display: flex;
  justify-content: space-between;
  gap: var(--space-sm);
}

.portrait-panel {
  border: 1px solid rgba(15, 23, 42, 0.08);
  border-radius: 12px;
  padding: var(--space-sm);
}

@media (max-width: 640px) {
  .event-row__header {
    flex-direction: column;
    align-items: flex-start;
  }

  .event-row__amount {
    text-align: left;
  }

  .filter-row {
    flex-direction: column;
  }

  .metadata-badges {
    flex-direction: column;
    align-items: flex-start;
  }

  .metadata-transactions li {
    grid-template-columns: repeat(2, minmax(80px, 1fr));
  }

  .safe-grid {
    grid-template-columns: 1fr;
  }
}

.text-input,
select,
textarea {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid rgba(15, 23, 42, 0.2);
  font-size: 16px;
  margin: 8px 0 16px;
  font-family: inherit;
  background: #fff;
}
</file>

<file path="src/test/setup.js">
import '@testing-library/jest-dom';
</file>

<file path="src/test/setup.ts">
import '@testing-library/jest-dom';
</file>

<file path="src/types/dashboard.js">
export {};
</file>

<file path="src/types/dashboard.ts">
export type BankStatus = {
  bank_id: string;
  bank_name: string;
  status: string;
  fetched_at: string | null;
};

export type CreditPaymentMetadata = {
  amount: number;
  next_payment_date: string;
};

export type DashboardResponse = {
  total_balance: number;
  bank_statuses: BankStatus[];
  safe_to_spend_daily: number;
  salary_amount: number;
  next_salary_date: string;
  days_until_next_salary: number;
  upcoming_credit_payment: CreditPaymentMetadata;
};
</file>

<file path="src/App.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from 'react';
import { Navigate, Outlet, Route, Routes, useLocation, useNavigate } from 'react-router-dom';
import { useNotifications } from './state/notifications';
import { useUser } from './state/useUser';
import { BanksCatalogPage } from './pages/BanksCatalogPage';
import { DashboardPage } from './pages/DashboardPage';
import { UserIdPage } from './pages/UserIdPage';
const ProtectedRoute = () => {
    const { userId } = useUser();
    const location = useLocation();
    if (!userId) {
        return _jsx(Navigate, { to: "/", replace: true, state: { from: location } });
    }
    return _jsx(Outlet, {});
};
class AppErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }
    static getDerivedStateFromError(error) {
        return { hasError: true, message: error.message };
    }
    componentDidCatch(error, errorInfo) {
        console.error('App crashed', error, errorInfo);
    }
    render() {
        if (this.state.hasError) {
            return (_jsx("div", { className: "app-main", children: _jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0427\u0442\u043E-\u0442\u043E \u043F\u043E\u0448\u043B\u043E \u043D\u0435 \u0442\u0430\u043A" }), _jsx("p", { children: this.state.message }), _jsx("button", { className: "btn", onClick: () => this.setState({ hasError: false }), children: "\u041F\u043E\u043F\u0440\u043E\u0431\u043E\u0432\u0430\u0442\u044C \u0441\u043D\u043E\u0432\u0430" })] }) }));
        }
        return this.props.children;
    }
}
const Header = () => {
    const { userId, clearUser } = useUser();
    const navigate = useNavigate();
    const { notify } = useNotifications();
    return (_jsxs("header", { style: { padding: '16px 24px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }, children: [_jsxs("div", { children: [_jsx("strong", { children: "FinPulse MPA" }), userId ? _jsxs("span", { style: { marginLeft: 12, color: '#475569' }, children: ["User: ", userId] }) : null] }), _jsxs("div", { style: { display: 'flex', gap: 12 }, children: [_jsx("button", { className: "btn-secondary btn", onClick: () => navigate('/dashboard'), children: "\u0414\u0430\u0448\u0431\u043E\u0440\u0434" }), userId ? (_jsx("button", { className: "btn-secondary btn", onClick: () => {
                            clearUser();
                            notify(' ');
                            navigate('/');
                        }, children: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C" })) : null] })] }));
};
export const App = () => (_jsx(AppErrorBoundary, { children: _jsxs("div", { className: "app-shell", children: [_jsx(Header, {}), _jsxs(Routes, { children: [_jsx(Route, { path: "/", element: _jsx(UserIdPage, {}) }), _jsxs(Route, { element: _jsx(ProtectedRoute, {}), children: [_jsx(Route, { path: "/banks", element: _jsx(BanksCatalogPage, {}) }), _jsx(Route, { path: "/dashboard", element: _jsx(DashboardPage, {}) })] }), _jsx(Route, { path: "*", element: _jsx(Navigate, { to: "/", replace: true }) })] })] }) }));
export default App;
</file>

<file path="src/App.tsx">
import React from 'react';
import { Navigate, Outlet, Route, Routes, useLocation, useNavigate } from 'react-router-dom';
import { useNotifications } from './state/notifications';
import { useUser } from './state/useUser';
import { BanksCatalogPage } from './pages/BanksCatalogPage';
import { DashboardPage } from './pages/DashboardPage';
import { UserIdPage } from './pages/UserIdPage';

const ProtectedRoute: React.FC = () => {
  const { userId } = useUser();
  const location = useLocation();
  if (!userId) {
    return <Navigate to="/" replace state={{ from: location }} />;
  }
  return <Outlet />;
};

class AppErrorBoundary extends React.Component<React.PropsWithChildren, { hasError: boolean; message?: string }> {
  constructor(props: React.PropsWithChildren) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, message: error.message };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('App crashed', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="app-main">
          <div className="card">
            <h2>-   </h2>
            <p>{this.state.message}</p>
            <button className="btn" onClick={() => this.setState({ hasError: false })}>
               
            </button>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}

const Header: React.FC = () => {
  const { userId, clearUser } = useUser();
  const navigate = useNavigate();
  const { notify } = useNotifications();

  return (
    <header style={{ padding: '16px 24px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
      <div>
        <strong>FinPulse MPA</strong>
        {userId ? <span style={{ marginLeft: 12, color: '#475569' }}>User: {userId}</span> : null}
      </div>
      <div style={{ display: 'flex', gap: 12 }}>
        <button className="btn-secondary btn" onClick={() => navigate('/dashboard')}>
          
        </button>
        {userId ? (
          <button
            className="btn-secondary btn"
            onClick={() => {
              clearUser();
              notify(' ');
              navigate('/');
            }}
          >
            
          </button>
        ) : null}
      </div>
    </header>
  );
};

export const App: React.FC = () => (
  <AppErrorBoundary>
    <div className="app-shell">
      <Header />
      <Routes>
        <Route path="/" element={<UserIdPage />} />
        <Route element={<ProtectedRoute />}>
        <Route path="/banks" element={<BanksCatalogPage />} />
        <Route path="/dashboard" element={<DashboardPage />} />
      </Route>
      <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </div>
  </AppErrorBoundary>
);

export default App;
</file>

<file path="src/main.js">
import { jsx as _jsx } from "react/jsx-runtime";
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './styles/global.css';
import { UserProvider } from './state/useUser';
import { NotificationsProvider } from './state/notifications';
ReactDOM.createRoot(document.getElementById('root')).render(_jsx(React.StrictMode, { children: _jsx(NotificationsProvider, { children: _jsx(UserProvider, { children: _jsx(BrowserRouter, { children: _jsx(App, {}) }) }) }) }));
</file>

<file path="src/main.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './styles/global.css';
import { UserProvider } from './state/useUser';
import { NotificationsProvider } from './state/notifications';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <NotificationsProvider>
      <UserProvider>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </UserProvider>
    </NotificationsProvider>
  </React.StrictMode>
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tests/test_api_aliases.py">
import sys
from pathlib import Path
from types import SimpleNamespace

from fastapi.testclient import TestClient
import pytest

PROJECT_DIR = Path(__file__).resolve().parents[1]
REPO_ROOT = PROJECT_DIR.parent
sys.path.append(str(PROJECT_DIR))
sys.path.append(str(REPO_ROOT))

import core.database as database
from hktn.backend_app import BANK_CONFIGS, app


@pytest.fixture(autouse=True)
def temp_db(tmp_path, monkeypatch):
    test_db = tmp_path / "consents.db"
    monkeypatch.setattr(database, "DB_FILE", str(test_db))
    database.init_db()
    yield


def test_list_banks_exposes_base_url(monkeypatch):
    BANK_CONFIGS["vbank"]["url"] = "http://mock-bank.local"
    with TestClient(app) as client:
        response = client.get("/api/banks")
    assert response.status_code == 200
    payload = response.json()
    assert any(bank["baseUrl"] == "http://mock-bank.local" for bank in payload["banks"])


def test_consents_start_alias(monkeypatch):
    BANK_CONFIGS["vbank"]["url"] = "http://mock-bank.local"
    monkeypatch.setattr("hktn.backend.config.settings.team_client_id", "team-id", raising=False)
    monkeypatch.setattr("hktn.backend.config.settings.team_client_secret", "team-secret", raising=False)

    class DummyClient:
        def __init__(self, *args, **kwargs):
            self._closed = False

        async def initiate_consent(self, user_id: str):
            assert user_id == "demo-123"
            return SimpleNamespace(
                consent_id="consent-1",
                request_id="req-1",
                status="AwaitingAuthorization",
                approval_url="http://bank/approve",
                auto_approved=False,
            )

        async def close(self):
            self._closed = True

    monkeypatch.setattr("hktn.backend.services.banking.OBRAPIClient", DummyClient)

    with TestClient(app) as client:
        response = client.post("/api/consents/start", json={"user_id": "demo-123", "bank_id": "vbank"})

    assert response.status_code == 200
    data = response.json()
    assert data["bank_id"] == "vbank"
    assert data["request_id"] == "req-1"
    assert data["state"] == "pending"
</file>

<file path="tests/test_consents.py">
from pathlib import Path
import sys

import pytest

sys.path.append(str(Path(__file__).resolve().parents[1]))

import core.database as database  # noqa: E402


@pytest.fixture(autouse=True)
def _temp_db(tmp_path, monkeypatch):
    test_db = tmp_path / "consents.db"
    monkeypatch.setattr(database, "DB_FILE", str(test_db))
    database.init_db()
    yield


def test_find_approved_consents_filters_account_scope():
    database.save_consent("user-1", "vbank", "consent-accounts", "APPROVED")
    database.save_consent("user-1", "vbank", "consent-products", "APPROVED", consent_type="products")

    accounts_only = database.find_approved_consents("user-1", consent_type="accounts")
    assert len(accounts_only) == 1
    assert accounts_only[0].consent_id == "consent-accounts"
    assert accounts_only[0].consent_type == "accounts"

    all_consents = database.find_approved_consents("user-1")
    assert {entry.consent_type for entry in all_consents} == {"accounts", "products"}
    assert {entry.consent_id for entry in all_consents} == {"consent-accounts", "consent-products"}
</file>

<file path="backend_app.py">
"""Compatibility wrapper for legacy imports.

This module keeps the historical `hktn.backend_app:app` entrypoint working
while the real FastAPI application lives inside `hktn.backend`.
"""

try:  # pragma: no cover - compatibility for direct module import
    from .backend.app import app, create_app
    from .backend.config import settings
except ImportError:  # pragma: no cover
    from backend.app import app, create_app  # type: ignore
    from backend.config import settings  # type: ignore

from hktn.core.obr_client import OBRAPIClient  # re-exported for legacy tests

BANK_CONFIGS = settings.banks
TEAM_CLIENT_ID = settings.team_client_id
TEAM_CLIENT_SECRET = settings.team_client_secret

__all__ = ["app", "create_app", "BANK_CONFIGS", "TEAM_CLIENT_ID", "TEAM_CLIENT_SECRET", "OBRAPIClient"]
</file>

<file path="index.html">
<!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Main screens</title>
    </head>

    <body>
      <div id="root"></div>
      <script type="module" src="/src/main.tsx"></script>
    </body>
  </html>
</file>

<file path="jest.config.ts">
import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
  transform: {
    '^.+\\.(ts|tsx)$': [
      'ts-jest',
      {
        tsconfig: '<rootDir>/tsconfig.json',
      },
    ],
  },
};

export default config;
</file>

<file path="package.json">
{
  "name": "finpulse-open-banking-ui",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest run"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.3"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.1.2",
    "@testing-library/user-event": "^14.4.3",
    "@types/jest": "^29.5.12",
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@vitejs/plugin-react": "^4.2.1",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "jsdom": "^24.1.3",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3",
    "vite": "^5.1.4",
    "vitest": "^1.6.1"
  }
}
</file>

<file path="README.md">
# Main screens

This bundle now exposes the streamlined screens and API needed to demo Safe-to-Spend without the historical onboarding and portrait flows.

## Running the code

Run `npm i` to install the frontend dependencies.

Start the dev server via `npm run dev` and open `http://localhost:5173`.

The FastAPI backend still boots through `uvicorn hktn.backend_app:app --reload` (requirements listed in `requirements.txt`).

## Simplified analytics flow

- `/api/dashboard` is the only analytics endpoint. It returns the summed bank balance, bank statuses, the scheduled salary (amount/date) and the next credit payment (amount/date). The safe-to-spend number is now computed with a single formula: `(balance + salary_amount - credit_payment_amount) / days_until_next_salary`.
- `/api/banks` and `/api/consents/*` stay intact for teams who still connect banks, but the SPA only shows the bank catalog, a basic dashboard and the user-id screen.
- All portrait, credit-ranking, onboarding and goal routes (and their React pages) were removed.
- The bulky analytics engine and numerical dependencies (`pandas`, `numpy`, etc.) are gone; the backend only fetches balances and looks up the salary / credit metadata.

## Configuring salary and credit metadata

Each user can override the salary and payment inputs through the new `user_financial_inputs` table. Example SQL:

```sql
INSERT INTO user_financial_inputs (user_id, salary_amount, next_salary_date, credit_payment_amount, credit_payment_date)
VALUES ('team260-1', 80000, '2025-12-25', 15000, '2025-12-18')
ON CONFLICT(user_id) DO UPDATE SET
  salary_amount=excluded.salary_amount,
  next_salary_date=excluded.next_salary_date,
  credit_payment_amount=excluded.credit_payment_amount,
  credit_payment_date=excluded.credit_payment_date;
```

If no row exists the backend falls back to the new environment variables:

- `DEFAULT_SALARY_AMOUNT` (float, default `0`)
- `DEFAULT_NEXT_SALARY_DAYS` (int, default `14`)
- `DEFAULT_CREDIT_PAYMENT_AMOUNT` (float, default `0`)
- `DEFAULT_CREDIT_PAYMENT_DAYS` (int, default `10`)

## Testing & QA

- Run `npm run test` for the Vitest suite.
- Run `pytest` for the backend tests.
- When salary / payment data is missing the dashboard still renders, but the safe-to-spend limit will degrade to zero; populate the DB row (or env defaults) for realistic demos.
</file>

<file path="requirements.txt">
# -- Backend Framework --
# FastAPI   REST API  Uvicorn   .
fastapi
uvicorn[standard]
python-multipart

# -- Core Utilities & API Communication --
#   HTTP-,   JWT, .env    .
httpx[http2]
pydantic
python-dotenv
pyjwt[crypto]
tenacity
cachetools
pytest
pytest-asyncio
pytest-mock
respx
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ES2020"],
    "module": "ESNext",
    "moduleResolution": "Node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

//   root: 'src',    
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
  },
  test: { //    !
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
  },
});
</file>

</files>
