This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/
  routers/
    __init__.py
    analytics.py
    banks.py
    consents.py
    onboarding.py
    profile.py
  services/
    analytics.py
    banking.py
    consents.py
    goals.py
    onboarding.py
    products.py
  __init__.py
  app.py
  config.py
  schemas.py
  state.py
core/
  __init__.py
  analytics_engine.py
  data_models.py
  database.py
  obr_client.py
src/
  api/
    client.js
    client.ts
  components/
    __tests__/
      BanksList.test.js
      BanksList.test.tsx
      UserIdForm.test.js
      UserIdForm.test.tsx
    BanksList.js
    BanksList.tsx
    BanksOverviewCard.tsx
    UserIdForm.js
    UserIdForm.tsx
  pages/
    __tests__/
      DashboardPage.test.js
      DashboardPage.test.tsx
    BanksCatalogPage.js
    BanksCatalogPage.tsx
    CallbackPage.js
    CallbackPage.tsx
    ConsentProcessPage.js
    ConsentProcessPage.tsx
    ConsentStatusPage.js
    ConsentStatusPage.tsx
    DashboardPage.js
    DashboardPage.tsx
    DebtGoalPage.js
    DebtGoalPage.tsx
    GoalsLandingPage.js
    GoalsLandingPage.tsx
    IngestionPage.js
    IngestionPage.tsx
    SaveGoalPage.js
    SaveGoalPage.tsx
    UserIdPage.js
    UserIdPage.tsx
  state/
    notifications.js
    notifications.tsx
    useUser.js
    useUser.tsx
  styles/
    global.css
  test/
    setup.js
    setup.ts
  types/
    dashboard.js
    dashboard.ts
  App.js
  App.tsx
  main.js
  main.tsx
  vite-env.d.ts
tests/
  test_api_aliases.py
  test_consents.py
backend_app.py
finpulse_consents.db
index.html
jest.config.ts
package.json
README.md
requirements.txt
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/routers/__init__.py">
from . import analytics, banks, consents, onboarding, profile

__all__ = ["analytics", "banks", "consents", "onboarding", "profile"]
</file>

<file path="backend/routers/analytics.py">
from __future__ import annotations

from fastapi import APIRouter

from ..schemas import AnalysisRequest, FinancialPortraitRequest, IngestRequest
from ..services import analytics

router = APIRouter(prefix="/api", tags=["analytics"])


@router.get("/credits")
async def get_user_credits(user_id: str):
    return await analytics.get_user_credits(user_id)


@router.get("/dashboard")
async def get_dashboard_metrics(user_id: str):
    return await analytics.get_dashboard_metrics(user_id)


@router.post("/financial-portrait")
async def build_financial_portrait(req: FinancialPortraitRequest):
    return await analytics.build_financial_portrait_view(req)


@router.post("/ingest/run")
async def run_initial_ingestion(req: IngestRequest):
    return await analytics.run_initial_ingestion(req)


@router.post("/analyze")
async def start_analysis(req: AnalysisRequest):
    return await analytics.start_analysis(req)
</file>

<file path="backend/routers/banks.py">
from __future__ import annotations

from fastapi import APIRouter

from ..services import banking

router = APIRouter(prefix="/api", tags=["banks"])


@router.get("/banks")
async def list_banks(user_id: str | None = None):
    return banking.list_banks(user_id)


@router.get("/banks/{bank_id}/bootstrap")
async def bootstrap_bank(bank_id: str, user_id: str):
    return await banking.bootstrap_bank(bank_id, user_id)
</file>

<file path="backend/routers/consents.py">
from __future__ import annotations

from fastapi import APIRouter, Request
from fastapi.responses import RedirectResponse

from ..config import settings
from ..schemas import ConsentInitiateRequest
from ..services import consents

router = APIRouter(prefix="/api", tags=["consents"])


@router.post("/consent/initiate")
async def initiate_consent(req: ConsentInitiateRequest):
    return await consents.initiate_consent(req)


@router.post("/consent/initiate/product")
async def initiate_product_consent(req: ConsentInitiateRequest):
    return await consents.initiate_product_consent(req)


@router.post("/consents/start")
async def start_consent_alias(req: ConsentInitiateRequest):
    """Specification-friendly alias for /api/consent/initiate."""
    return await consents.initiate_consent(req)


@router.get("/consent/callback")
async def consent_callback(request: Request, consent_id: str):
    consents.mark_consent_from_callback(consent_id)
    return RedirectResponse(url=f"{settings.frontend_url}/callback")


@router.get("/consent/status")
async def get_consent_status(user_id: str, bank_id: str, request_id: str):
    return await consents.poll_consent_status(user_id=user_id, bank_id=bank_id, request_id=request_id)


@router.get("/consents/status")
async def get_consent_status_alias(user_id: str, bank_id: str, request_id: str):
    """Specification-friendly alias for /api/consent/status."""
    return await consents.poll_consent_status(user_id=user_id, bank_id=bank_id, request_id=request_id)
</file>

<file path="backend/routers/onboarding.py">
from __future__ import annotations

from fastapi import APIRouter

from ..schemas import IngestRequest, OnboardingCommitRequest, PreviewResponse, ProductConsentRequest
from ..services import onboarding

router = APIRouter(prefix="/api", tags=["onboarding"])


@router.post("/ingest/preview", response_model=PreviewResponse)
async def preview_products(req: IngestRequest):
    return await onboarding.preview_products(req)


@router.post("/products/consent")
async def save_product_consents(req: ProductConsentRequest):
    return onboarding.save_product_consents(req)


@router.post("/onboarding/commit")
async def finalize_onboarding(req: OnboardingCommitRequest):
    return onboarding.finalize_onboarding(req)


@router.get("/app/state")
async def get_app_state(user_id: str, include_portrait: bool = False):
    return await onboarding.load_app_state(user_id, include_portrait)
</file>

<file path="backend/routers/profile.py">
from __future__ import annotations

import logging

from fastapi import APIRouter, HTTPException

from hktn.core.database import save_user_profile

from ..schemas import GoalRequest

logger = logging.getLogger("finpulse.backend.profile")
router = APIRouter(prefix="/api", tags=["profile"])


@router.post("/profile/goal")
async def set_user_goal(req: GoalRequest):
    """Persist the user's selected financial goal."""
    try:
        save_user_profile(req.user_id, req.goal_type, req.goal_details)
        logger.info("Goal saved for user %s (%s)", req.user_id, req.goal_type)
        return {"status": "ok", "message": "Goal saved successfully."}
    except Exception as exc:  # noqa: BLE001
        logger.error("Failed to save goal for user %s: %s", req.user_id, exc)
        raise HTTPException(status_code=500, detail="Could not save user profile.") from exc
</file>

<file path="backend/services/analytics.py">
from __future__ import annotations

import asyncio
import logging
from datetime import date, datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Sequence

from fastapi import HTTPException, status

from hktn.core.analytics_engine import (
    build_financial_portrait,
    calculate_daily_s2s,
    derive_obligations,
    estimate_goal_probability,
    extract_recurring_events,
    rank_credits,
    run_analysis_with_details,
    _discover_events,
    _extract_account_balance,
    _prepare_transactions_df,
    _profile_events,
    _derive_event_label,
)
from hktn.core.data_models import Transaction
from hktn.core.database import (
    find_approved_consents,
    get_product_consents_for_user,
    get_recent_bank_status_logs,
    get_user_goal,
    StoredConsent,
)

from ..schemas import AnalysisRequest, FinancialPortraitRequest, IngestRequest
from .banking import (
    _sum_balance_amounts,
    fetch_bank_accounts_with_consent,
    fetch_bank_balances_with_consent,
    fetch_bank_credits,
    fetch_bank_data_with_consent,
)
from .goals import compose_user_goal
from .products import apply_consent_flags, build_account_product, build_credit_product, group_products_by_bank

logger = logging.getLogger("finpulse.backend.analytics")


def _parse_iso_date(value: Any) -> Optional[date]:
    if isinstance(value, date):
        return value
    if isinstance(value, datetime):
        return value.date()
    if isinstance(value, str) and value:
        try:
            return date.fromisoformat(value)
        except ValueError:
            try:
                return datetime.fromisoformat(value).date()
            except ValueError:
                return None
    return None


def _generate_budget_breakdown(
    spendable_total: float,
    event_profiles: Sequence[Dict[str, Any]],
) -> List[Dict[str, Any]]:
    """Distribute spendable cash across recurring spending categories."""
    if spendable_total <= 0:
        return []

    category_spend: Dict[str, float] = {}
    for event in event_profiles or []:
        if event.get("is_income"):
            continue
        if event.get("source") not in (None, "expense_event", "recurring_debit"):
            continue
        avg_amount = abs(float(event.get("mu_amount") or 0.0))
        if avg_amount <= 0:
            continue
        label = _derive_event_label(event)
        category_spend[label] = category_spend.get(label, 0.0) + avg_amount

    total_avg_spend = sum(category_spend.values())
    if total_avg_spend <= 0:
        return []

    budget: List[Dict[str, Any]] = []
    for category, avg_amount in category_spend.items():
        proportion = avg_amount / total_avg_spend
        budget.append(
            {
                "category": category,
                "amount": round(spendable_total * proportion, 2),
            }
        )

    budget.sort(key=lambda item: item["amount"], reverse=True)
    return budget


def _collect_cycle_events(
    obligations: Sequence[Dict[str, Any]],
    cycle_start_iso: Optional[str],
    cycle_end_iso: Optional[str],
) -> List[Dict[str, Any]]:
    """Return obligations that fall within the current planning cycle."""
    cycle_start = _parse_iso_date(cycle_start_iso)
    cycle_end = _parse_iso_date(cycle_end_iso)
    if not cycle_start or not cycle_end:
        return []

    events: List[Dict[str, Any]] = []
    for obligation in obligations or []:
        due_date = obligation.get("due_date")
        due = _parse_iso_date(due_date)
        if due is None:
            continue
        if not (cycle_start <= due < cycle_end):
            continue
        events.append(
            {
                "name": obligation.get("label") or "Обязательный платёж",
                "amount": float(obligation.get("amount") or 0.0),
                "date": due.isoformat(),
                "is_income": False,
                "source": obligation.get("source"),
                "mcc_code": obligation.get("mcc_code"),
                "merchant_name": obligation.get("merchant_name"),
            }
        )

    events.sort(key=lambda item: item["date"])
    return events


def _require_consents(user_id: str) -> Sequence[StoredConsent]:
    approved_consents = find_approved_consents(user_id, consent_type="accounts")
    if not approved_consents:
        raise HTTPException(
            status_code=status.HTTP_424_FAILED_DEPENDENCY,
            detail="No approved consents found.",
        )
    return approved_consents


async def get_user_credits(user_id: str) -> Dict[str, Any]:
    approved_consents = _require_consents(user_id)
    tasks = [
        fetch_bank_credits(consent.bank_id, consent.consent_id, user_id, create_product_consent=True)
        for consent in approved_consents
    ]
    bank_results = await asyncio.gather(*tasks)

    all_credits: List[Dict[str, Any]] = []
    bank_statuses: List[Dict[str, str]] = []
    for res in bank_results:
        bank_statuses.append({"bank_name": res["bank_id"], "status": res["status"], "message": res["message"]})
        if res["status"] == "ok":
            all_credits.extend(res["credits"])

    ranked = rank_credits(all_credits)
    return {"credits": all_credits, "credit_rankings": ranked, "bank_statuses": bank_statuses}


async def get_dashboard_metrics(user_id: str) -> Dict[str, Any]:
    approved_consents = _require_consents(user_id)

    account_tasks = [
        fetch_bank_accounts_with_consent(consent.bank_id, consent.consent_id, user_id) for consent in approved_consents
    ]
    balance_tasks = [
        fetch_bank_balances_with_consent(consent.bank_id, consent.consent_id, user_id) for consent in approved_consents
    ]
    credit_tasks = [fetch_bank_credits(consent.bank_id, consent.consent_id, user_id) for consent in approved_consents]
    tx_tasks = [fetch_bank_data_with_consent(consent.bank_id, consent.consent_id, user_id) for consent in approved_consents]

    account_results, balance_results, credit_results, tx_results = await asyncio.gather(
        asyncio.gather(*account_tasks),
        asyncio.gather(*balance_tasks),
        asyncio.gather(*credit_tasks),
        asyncio.gather(*tx_tasks),
    )

    all_accounts: List[Dict[str, Any]] = []
    bank_statuses: Dict[str, Dict[str, Any]] = {}
    total_balance = 0.0
    fetched_at = datetime.now(timezone.utc).isoformat()

    for res in account_results:
        bank_id = res["bank_id"]
        bank_statuses[bank_id] = {
            "bank_name": res.get("bank_name", bank_id),
            "status": res["status"],
            "fetched_at": None,
        }
        if res["status"] == "ok":
            all_accounts.extend(res.get("accounts", []))
            bank_statuses[bank_id]["fetched_at"] = fetched_at

    for res in balance_results:
        if res["status"] != "ok":
            continue
        for balance_entry in res.get("balances", []):
            amount = _extract_account_balance({"balances": [balance_entry]})
            total_balance += amount

    all_credits: List[Dict[str, Any]] = [
        credit for res in credit_results if res["status"] == "ok" for credit in res.get("credits", [])
    ]
    all_transactions: List[Transaction] = [
        tx for res in tx_results if res["status"] == "ok" for tx in res.get("transactions", [])
    ]

    if not all_transactions:
        raise HTTPException(
            status_code=status.HTTP_424_FAILED_DEPENDENCY,
            detail="Нет транзакций для анализа.",
        )

    df = _prepare_transactions_df(all_transactions)
    event_profiles, _ = _profile_events(_discover_events(df))
    income_events = [event for event in event_profiles if event.get("is_income")]

    today = date.today()
    next_income_date: Optional[date] = None
    if income_events:
        next_dates: List[date] = []
        for event in income_events:
            last_date = event.get("last_date") or today
            if not isinstance(last_date, date):
                continue
            frequency = timedelta(days=int(event.get("frequency_days") or 30))
            candidate = last_date
            while candidate <= today:
                candidate += frequency
            next_dates.append(candidate)
        if next_dates:
            next_income_date = min(next_dates)

    horizon_end_date = next_income_date or (today + timedelta(days=30))
    days_until_next_income = max((horizon_end_date - today).days, 1)

    obligations = derive_obligations(all_credits, event_profiles)
    upcoming_payments_total = 0.0
    for obligation in obligations:
        due_date = obligation.get("due_date")
        if isinstance(due_date, datetime):
            due_date = due_date.date()
        if isinstance(due_date, date) and today <= due_date <= horizon_end_date:
            upcoming_payments_total += float(obligation.get("amount") or 0.0)

    spendable_balance = total_balance - upcoming_payments_total
    safe_to_spend_daily = spendable_balance / days_until_next_income if days_until_next_income > 0 else 0.0

    return {
        "total_balance": round(total_balance, 2),
        "accounts": all_accounts,
        "bank_statuses": bank_statuses,
        "safe_to_spend_daily": round(max(0.0, safe_to_spend_daily), 2),
        "next_income_date": next_income_date.isoformat() if next_income_date else None,
        "days_until_next_income": days_until_next_income,
    }


async def build_financial_portrait_view(req: FinancialPortraitRequest) -> Dict[str, Any]:
    approved_consents = _require_consents(req.user_id)

    tx_tasks = [
        fetch_bank_data_with_consent(consent.bank_id, consent.consent_id, req.user_id)
        for consent in approved_consents
    ]
    credit_tasks = [
        fetch_bank_credits(consent.bank_id, consent.consent_id, req.user_id, create_product_consent=True)
        for consent in approved_consents
    ]
    account_tasks = [
        fetch_bank_accounts_with_consent(consent.bank_id, consent.consent_id, req.user_id)
        for consent in approved_consents
    ]
    balance_tasks = [
        fetch_bank_balances_with_consent(consent.bank_id, consent.consent_id, req.user_id)
        for consent in approved_consents
    ]

    tx_results, credit_results, account_results, balance_results = await asyncio.gather(
        asyncio.gather(*tx_tasks),
        asyncio.gather(*credit_tasks),
        asyncio.gather(*account_tasks),
        asyncio.gather(*balance_tasks),
    )

    all_transactions: List[Transaction] = []
    all_credits: List[Dict[str, Any]] = []
    all_accounts: List[Dict[str, Any]] = []
    enriched_credits: List[Dict[str, Any]] = []
    enriched_accounts: List[Dict[str, Any]] = []
    tx_statuses: List[Dict[str, str]] = []
    credit_statuses: List[Dict[str, str]] = []
    account_statuses: List[Dict[str, str]] = []

    for res in tx_results:
        tx_statuses.append({"bank": res["bank_id"], "status": res["status"], "message": res.get("message") or ""})
        if res["status"] == "ok":
            all_transactions.extend(res["transactions"])

    for res in credit_results:
        credit_statuses.append({"bank": res["bank_id"], "status": res["status"], "message": res.get("message") or ""})
        if res["status"] == "ok":
            all_credits.extend(res.get("credits") or [])
            for credit in res.get("credits", []) or []:
                enriched = build_credit_product(credit, res["bank_id"])
                if enriched:
                    enriched_credits.append(enriched)

    for res in account_results:
        account_statuses.append({"bank": res["bank_id"], "status": res["status"], "message": res.get("message") or ""})
        if res["status"] == "ok":
            all_accounts.extend(res.get("accounts") or [])
            for account in res.get("accounts", []) or []:
                enriched = build_account_product(account, res["bank_id"])
                if enriched:
                    enriched_accounts.append(enriched)

    balance_total = 0.0
    balance_statuses: List[Dict[str, str]] = []
    for res in balance_results:
        balance_statuses.append({"bank": res["bank_id"], "status": res["status"], "message": res.get("message") or ""})
        entries = res.get("balances") or []
        balance_total += _sum_balance_amounts(entries)


    product_consents = get_product_consents_for_user(req.user_id)
    bank_status_logs = get_recent_bank_status_logs(req.user_id)

    if not all_transactions:
        return {
            "error": "Could not fetch any transactions.",
        "bank_statuses": {
            "transactions": tx_statuses,
            "credits": credit_statuses,
            "accounts": account_statuses,
            "balances": balance_statuses,
        },
            "product_consents": product_consents,
            "bank_status_logs": bank_status_logs,
        }

    stored_goal = get_user_goal(req.user_id)
    user_goal = compose_user_goal(stored_goal, req.goal_type, req.goal_details, req.pace)

    portrait = build_financial_portrait(
        transactions=all_transactions,
        credits=enriched_credits or all_credits,
        accounts=enriched_accounts or all_accounts,
        user_goal=user_goal,
        balance_override=balance_total if balance_total > 0 else None,
    )
    portrait["bank_statuses"] = {
        "transactions": tx_statuses,
        "credits": credit_statuses,
        "accounts": account_statuses,
        "balances": balance_statuses,
    }
    portrait["product_consents"] = product_consents
    portrait["bank_status_logs"] = bank_status_logs
    portrait["accounts"] = enriched_accounts or all_accounts
    portrait["credits"] = enriched_credits or all_credits
    portrait["transactions_sample"] = all_transactions[:100]
    products_by_bank = group_products_by_bank(portrait["accounts"], portrait["credits"])
    portrait["products_by_bank"] = apply_consent_flags(products_by_bank, product_consents)
    (
        portrait_analysis,
        portrait_trajectories,
        portrait_forecast_dates,
        portrait_noise_profile,
        portrait_event_profiles,
    ) = run_analysis_with_details(
        all_transactions,
        float(portrait.get("current_balance") or 0.0),
        date.today() + timedelta(days=30),
        0,
    )
    recurring_source = portrait.get("discovered_events") or portrait_event_profiles
    obligations = derive_obligations(portrait["credits"], recurring_source)
    goal_probability = estimate_goal_probability(
        user_goal,
        portrait_trajectories,
        portrait_forecast_dates,
        obligations,
        recurring_source,
    )
    portrait["analysis"] = portrait_analysis.dict()
    portrait["diagnostics"] = {
        "noise_profile": portrait_noise_profile,
        "forecast_dates": [d.isoformat() for d in portrait_forecast_dates],
        "trajectory_sample": list(portrait_trajectories.shape),
    }
    portrait["goal_probability"] = goal_probability
    if not portrait.get("recurring_events"):
        portrait["recurring_events"] = extract_recurring_events(recurring_source)
    logger.info(
        "Financial portrait for %s: debt=%.2f, monthly=%.2f, sts=%.2f, loans=%d, accounts=%d",
        req.user_id,
        portrait.get("financial_health", {}).get("total_debt", 0.0),
        portrait.get("financial_health", {}).get("total_monthly_payments", 0.0),
        portrait.get("safe_to_spend_daily", 0.0),
        len(portrait["credits"]),
        len(portrait["accounts"]),
    )
    return portrait


async def run_initial_ingestion(req: IngestRequest) -> Dict[str, Any]:
    logger.info("Starting initial ingestion for user %s", req.user_id)
    approved_consents = _require_consents(req.user_id)

    tasks = [
        fetch_bank_data_with_consent(consent.bank_id, consent.consent_id, req.user_id)
        for consent in approved_consents
    ]
    bank_results = await asyncio.gather(*tasks)

    all_transactions: List[Transaction] = []
    bank_statuses: List[Dict[str, str]] = []
    for res in bank_results:
        bank_statuses.append(
            {"bank_name": res["bank_id"], "status": res["status"], "message": res["message"]}
        )
        if res["status"] == "ok":
            all_transactions.extend(res["transactions"])

    if not all_transactions:
        raise HTTPException(
            status_code=status.HTTP_424_FAILED_DEPENDENCY,
            detail="Could not fetch any transactions.",
        )

    logger.info(
        "Initial ingestion completed for user %s (%d transactions)",
        req.user_id,
        len(all_transactions),
    )

    return {
        "status": "ok",
        "transactions_count": len(all_transactions),
        "bank_statuses": bank_statuses,
        "message": "Initial data ingestion complete.",
    }


async def start_analysis(req: AnalysisRequest) -> Dict[str, Any]:
    approved_consents = _require_consents(req.user_id)

    tasks = [
        fetch_bank_data_with_consent(consent.bank_id, consent.consent_id, req.user_id)
        for consent in approved_consents
    ]
    bank_results = await asyncio.gather(*tasks)

    all_transactions: List[Transaction] = []
    bank_statuses: List[Dict[str, str]] = []
    for res in bank_results:
        bank_statuses.append(
            {"bank_name": res["bank_id"], "status": res["status"], "message": res["message"]}
        )
        if res["status"] == "ok":
            all_transactions.extend(res["transactions"])

    if not all_transactions:
        raise HTTPException(
            status_code=status.HTTP_424_FAILED_DEPENDENCY,
            detail="Could not fetch any transactions.",
        )

    (
        analysis_result,
        trajectories,
        forecast_dates,
        noise_profile,
        event_profiles,
    ) = run_analysis_with_details(
        all_transactions,
        req.current_balance,
        req.payment_date,
        req.payment_amount,
    )

    return {
        "analysis_result": analysis_result.dict(),
        "bank_statuses": bank_statuses,
        "discovered_events": event_profiles,
        "noise_profile": noise_profile,
        "forecast_dates": [d.isoformat() for d in forecast_dates],
        "trajectory_shape": list(trajectories.shape),
    }
</file>

<file path="backend/services/banking.py">
from __future__ import annotations

import asyncio
import logging
from contextlib import asynccontextmanager
from typing import Any, Dict, List, Optional, Sequence, Tuple

from fastapi import HTTPException, status

from hktn.core.database import add_bank_status_log, find_approved_consents
from hktn.core.obr_client import OBRAPIClient

from ..config import BankConfig, settings
from ..state import api_cache

logger = logging.getLogger("finpulse.backend.banking")


BALANCE_FIELDS = (
    "amount",
    "balance",
    "availableBalance",
    "currentBalance",
    "ledgerBalance",
    "available_balance",
    "current_balance",
    "clearedBalance",
    "cleared_balance",
)


def _coerce_to_float(value: Any) -> Optional[float]:
    if value is None:
        return None
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return float(value)
    if isinstance(value, str):
        try:
            normalized = value.strip().replace("\u00a0", "").replace(",", ".")
            return float(normalized)
        except ValueError:
            return None
    if isinstance(value, dict):
        for field in ("amount", "value", "balance", "current"):
            candidate = value.get(field)
            numeric = _coerce_to_float(candidate)
            if numeric is not None:
                return numeric
        return None
    return None


def _extract_balance_entries(payload: Any) -> List[Dict[str, Any]]:
    if isinstance(payload, dict):
        for candidate in ("balances", "items", "data", "accountBalances"):
            section = payload.get(candidate)
            if isinstance(section, list):
                return section
        if isinstance(payload.get("data"), dict):
            nested = payload["data"].get("balances")
            if isinstance(nested, list):
                return nested
    if isinstance(payload, list):
        return payload
    return []


def _normalize_balance_entry(entry: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    if not isinstance(entry, dict):
        return None

    amount = None
    for key in BALANCE_FIELDS:
        if key in entry:
            amount = _coerce_to_float(entry[key])
            if amount is not None:
                break
    if amount is None and "balanceAmount" in entry and isinstance(entry["balanceAmount"], dict):
        amount = _coerce_to_float(entry["balanceAmount"].get("amount"))

    if amount is None:
        return None

    account_id = (
        entry.get("accountId")
        or entry.get("account_id")
        or entry.get("resource_id")
        or entry.get("id")
    )

    return {
        "bank_id": entry.get("bank_id") or entry.get("bankId"),
        "account_id": account_id,
        "amount": amount,
        "currency": entry.get("currency") or entry.get("currency_code"),
    }


def _sum_balance_amounts(entries: List[Dict[str, Any]]) -> float:
    total = 0.0
    for entry in entries:
        normalized = _normalize_balance_entry(entry)
        if normalized and normalized.get("amount") is not None:
            total += normalized["amount"]
    return round(total, 2)


def _ensure_team_credentials() -> Tuple[str, str]:
    if not settings.team_client_id or not settings.team_client_secret:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Server is missing TEAM credentials.",
        )
    return settings.team_client_id, settings.team_client_secret


def _require_bank(bank_id: str, require_url: bool = True) -> BankConfig:
    config = settings.banks.get(bank_id)
    if not config:
        raise HTTPException(status_code=404, detail=f"Bank '{bank_id}' is not supported.")
    if require_url and not config.url:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Bank endpoint URL is not configured.",
        )
    return config


def get_bank_config(bank_id: str, require_url: bool = False) -> BankConfig:
    """Return bank configuration ensuring it exists."""
    return _require_bank(bank_id, require_url=require_url)


@asynccontextmanager
async def bank_client(bank_id: str):
    config = _require_bank(bank_id, require_url=True)
    client_id, client_secret = _ensure_team_credentials()
    client = OBRAPIClient(
        api_base_url=config.url,
        team_client_id=client_id,
        team_client_secret=client_secret,
    )
    try:
        yield client
    finally:
        await client.close()


def list_banks(user_id: Optional[str] = None) -> Dict[str, List[Dict[str, Any]]]:
    connected_bank_ids = set()
    if user_id:
        connected_bank_ids = {
            consent.bank_id for consent in find_approved_consents(user_id, consent_type="accounts")
        }

    banks = []
    for bank_id, config in settings.banks.items():
        entry: Dict[str, Any] = {
            "id": bank_id,
            "name": config.display_name,
            "connected": bank_id in connected_bank_ids,
            "baseUrl": config.url,
            "status": "configured" if config.url else "missing_url",
        }
        if not config.url:
            entry["error"] = "Bank endpoint URL is not configured."
        banks.append(entry)
    return {"banks": banks}


async def fetch_bank_data_with_consent(bank_id: str, consent_id: str, user_id: str) -> Dict[str, Any]:
    cache_key = f"{user_id}:{bank_id}:{consent_id}"
    if cache_key in api_cache:
        logger.info("Serving data from cache for bank %s", bank_id)
        return api_cache[cache_key]

    _require_bank(bank_id)
    async with bank_client(bank_id) as client:
        try:
            transactions = await client.fetch_transactions_with_consent(user_id, consent_id)
            message = f"Fetched {len(transactions)} transactions"
            result = {
                "bank_id": bank_id,
                "status": "ok",
                "transactions": transactions,
                "message": message,
            }
            api_cache[cache_key] = result
            add_bank_status_log(user_id, bank_id, "fetch_transactions", "ok", message)
            return result
        except Exception as exc:  # noqa: BLE001
            error_message = str(exc)
            logger.error("Failed to fetch data for bank %s: %s", bank_id, error_message)
            add_bank_status_log(user_id, bank_id, "fetch_transactions", "error", error_message)
            return {"bank_id": bank_id, "status": "error", "transactions": [], "message": error_message}


async def fetch_bank_credits(
    bank_id: str,
    consent_id: str,
    user_id: str,
    user_name: Optional[str] = None,
    create_product_consent: bool = False,
) -> Dict[str, Any]:
    _require_bank(bank_id)
    async with bank_client(bank_id) as client:
        try:
            prod_consent_id = consent_id
            if create_product_consent:
                prod_consent_meta = await client.initiate_product_consent(user_id, user_display_name=user_name)
                if prod_consent_meta and prod_consent_meta.consent_id:
                    prod_consent_id = prod_consent_meta.consent_id

            credits = await client.fetch_credits_with_consent(user_id, prod_consent_id)
            for credit in credits or []:
                if isinstance(credit, dict):
                    credit.setdefault("bank_id", bank_id)
                    credit.setdefault("bank_name", settings.banks[bank_id].display_name)
            message = f"Fetched {len(credits)} credits"
            add_bank_status_log(user_id, bank_id, "fetch_credits", "ok", message)
            return {
                "bank_id": bank_id,
                "status": "ok",
                "credits": credits,
                "message": message,
            }
        except Exception as exc:  # noqa: BLE001
            error_message = str(exc)
            logger.error("Failed to fetch credits for bank %s: %s", bank_id, error_message)
            add_bank_status_log(user_id, bank_id, "fetch_credits", "error", error_message)
            return {"bank_id": bank_id, "status": "error", "credits": [], "message": error_message}


async def fetch_bank_accounts_with_consent(bank_id: str, consent_id: str, user_id: str) -> Dict[str, Any]:
    _require_bank(bank_id)
    async with bank_client(bank_id) as client:
        try:
            accounts = await client.fetch_accounts_with_consent(user_id, consent_id)
            for account in accounts or []:
                if isinstance(account, dict):
                    account.setdefault("bank_id", bank_id)
                    account.setdefault("bank_name", settings.banks[bank_id].display_name)
            message = f"Fetched {len(accounts)} accounts"
            add_bank_status_log(user_id, bank_id, "fetch_accounts", "ok", message)
            return {
                "bank_id": bank_id,
                "status": "ok",
                "accounts": accounts,
                "message": message,
            }
        except Exception as exc:  # noqa: BLE001
            error_message = str(exc)
            logger.error("Failed to fetch accounts for bank %s: %s", bank_id, error_message)
            add_bank_status_log(user_id, bank_id, "fetch_accounts", "error", error_message)
            return {"bank_id": bank_id, "status": "error", "accounts": [], "message": error_message}


async def fetch_bank_balances_with_consent(bank_id: str, consent_id: str, user_id: str) -> Dict[str, Any]:
    _require_bank(bank_id)
    async with bank_client(bank_id) as client:
        try:
            balances_data = await client.fetch_balances_with_consent(user_id, consent_id)
            entries = balances_data.get("balances", [])
            message = f"Fetched {len(entries)} balance records"
            add_bank_status_log(user_id, bank_id, "fetch_balances", "ok", message)
            return {
                "bank_id": bank_id,
                "status": "ok",
                "balances": entries,
                "message": message,
            }
        except Exception as exc:  # noqa: BLE001
            error_message = str(exc)
            logger.error("Failed to fetch balances for bank %s: %s", bank_id, error_message)
            add_bank_status_log(user_id, bank_id, "fetch_balances", "error", error_message)
            return {"bank_id": bank_id, "status": "error", "balances": [], "message": error_message}


async def bootstrap_bank(bank_id: str, user_id: str) -> Dict[str, Any]:
    """Aggregate initial payload for a connected bank."""
    config = _require_bank(bank_id)
    if not config.url:
        message = "Bank endpoint URL is not configured."
        add_bank_status_log(user_id, bank_id, "bootstrap", "error", message)
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=message,
        )

    approved_consents = find_approved_consents(user_id, consent_type="accounts")
    consent = next((entry for entry in approved_consents if entry.bank_id == bank_id), None)
    if not consent:
        message = "No approved consents found."
        add_bank_status_log(user_id, bank_id, "bootstrap", "error", message)
        raise HTTPException(status_code=status.HTTP_424_FAILED_DEPENDENCY, detail=message)

    accounts_task = fetch_bank_accounts_with_consent(bank_id, consent.consent_id, user_id)
    transactions_task = fetch_bank_data_with_consent(bank_id, consent.consent_id, user_id)
    credits_task = fetch_bank_credits(bank_id, consent.consent_id, user_id)
    balances_task = fetch_bank_balances_with_consent(bank_id, consent.consent_id, user_id)

    accounts_res, transactions_res, credits_res, balances_res = await asyncio.gather(
        accounts_task,
        transactions_task,
        credits_task,
        balances_task,
    )

    transactions_snapshot = list(transactions_res.get("transactions") or [])[:100]
    status_block = {
        "accounts": {
            "state": accounts_res.get("status"),
            "message": accounts_res.get("message"),
        },
        "transactions": {
            "state": transactions_res.get("status"),
            "message": transactions_res.get("message"),
        },
        "credits": {
            "state": credits_res.get("status"),
            "message": credits_res.get("message"),
        },
        "balances": {
            "state": balances_res.get("status"),
            "message": balances_res.get("message"),
        },
    }

    result = {
        "bank_id": bank_id,
        "user_id": user_id,
        "baseUrl": config.url,
        "accounts": accounts_res.get("accounts") or [],
        "credits": credits_res.get("credits") or [],
        "transactions": transactions_snapshot,
        "status": status_block,
        "balances": balances_res.get("balances") or [],
    }
    add_bank_status_log(user_id, bank_id, "bootstrap", "ok", "Bootstrap payload generated.")
    return result
</file>

<file path="backend/services/consents.py">
from __future__ import annotations

import logging
from typing import Any, Dict

from fastapi import HTTPException, status

from hktn.core.database import (
    get_consent_by_request_id,
    save_consent,
    update_consent_from_request,
    update_consent_status,
)
from hktn.core.obr_client import AUTHORIZED_CONSENT_STATUSES, FAILED_CONSENT_STATUSES

from ..schemas import ConsentInitiateRequest
from .banking import bank_client, get_bank_config

logger = logging.getLogger("finpulse.backend.consents")


async def initiate_consent(req: ConsentInitiateRequest) -> Dict[str, Any]:
    bank_config = get_bank_config(req.bank_id, require_url=True)
    async with bank_client(req.bank_id) as client:
        try:
            logger.info("Initiating consent for user '%s' with bank '%s'", req.user_id, req.bank_id)
            consent_meta = await client.initiate_consent(req.user_id)
            consent_identifier = consent_meta.consent_id or consent_meta.request_id
            if not consent_identifier:
                raise HTTPException(
                    status_code=502,
                    detail="Bank did not provide consent or request identifier.",
                )

            initial_status = "APPROVED" if consent_meta.auto_approved else "AWAITING_USER"
            save_consent(
                req.user_id,
                req.bank_id,
                consent_identifier,
                initial_status,
                request_id=consent_meta.request_id,
                approval_url=consent_meta.approval_url,
                consent_type="accounts",
            )

            if consent_meta.consent_id and consent_meta.auto_approved:
                update_consent_status(consent_meta.consent_id, "APPROVED")

            response_payload: Dict[str, Any] = {
                "bank_id": req.bank_id,
                "bank_name": bank_config.display_name,
                "user_id": req.user_id,
                "state": "approved" if consent_meta.auto_approved else "pending",
                "status": consent_meta.status,
                "consent_id": consent_meta.consent_id,
                "request_id": consent_meta.request_id,
                "approval_url": consent_meta.approval_url,
                "auto_approved": consent_meta.auto_approved,
            }

            if consent_meta.auto_approved:
                logger.info("Consent %s auto-approved for user '%s'.", consent_meta.consent_id, req.user_id)
            else:
                logger.info(
                    "Consent awaiting user action (request_id=%s) for user '%s'.",
                    consent_meta.request_id,
                    req.user_id,
                )
            return response_payload
        except HTTPException:
            raise
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to initiate consent for bank %s: %s", req.bank_id, exc)
            raise HTTPException(status_code=502, detail=f"Could not initiate consent with bank: {exc}") from exc


async def initiate_product_consent(req: ConsentInitiateRequest) -> Dict[str, Any]:
    """Initiate product-agreement consent for the selected bank."""
    bank_config = get_bank_config(req.bank_id, require_url=True)
    async with bank_client(req.bank_id) as client:
        try:
            logger.info("Initiating PRODUCT consent for user '%s' with bank '%s'", req.user_id, req.bank_id)
            consent_meta = await client.initiate_product_consent(req.user_id)
            if not consent_meta or not (consent_meta.consent_id or consent_meta.request_id):
                raise HTTPException(status_code=502, detail="Bank did not provide product consent identifier.")

            consent_identifier = consent_meta.consent_id or consent_meta.request_id
            initial_status = "APPROVED" if consent_meta.auto_approved else "AWAITING_USER"
            save_consent(
                req.user_id,
                req.bank_id,
                consent_identifier,
                initial_status,
                request_id=consent_meta.request_id,
                approval_url=consent_meta.approval_url,
                consent_type="products",
            )

            if consent_meta.consent_id and consent_meta.auto_approved:
                update_consent_status(consent_meta.consent_id, "APPROVED")

            return {
                "bank_id": req.bank_id,
                "bank_name": bank_config.display_name,
                "type": "product",
                "state": "approved" if consent_meta.auto_approved else "pending",
                "status": consent_meta.status,
                "consent_id": consent_meta.consent_id,
                "request_id": consent_meta.request_id,
                "approval_url": consent_meta.approval_url,
                "auto_approved": consent_meta.auto_approved,
            }
        except HTTPException as exc:
            logger.error("Failed to initiate PRODUCT consent for bank %s: %s", req.bank_id, exc)
            return {
                "bank_id": req.bank_id,
                "bank_name": bank_config.display_name,
                "type": "product",
                "state": "error",
                "status": "error",
                "error_message": str(exc.detail if hasattr(exc, "detail") else exc),
            }
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to initiate PRODUCT consent for bank %s: %s", req.bank_id, exc)
            return {
                "bank_id": req.bank_id,
                "bank_name": bank_config.display_name,
                "type": "product",
                "state": "error",
                "status": "error",
                "error_message": str(exc),
            }


async def poll_consent_status(user_id: str, bank_id: str, request_id: str) -> Dict[str, Any]:
    if not request_id:
        raise HTTPException(status_code=400, detail="request_id is required.")
    get_bank_config(bank_id, require_url=True)

    async with bank_client(bank_id) as client:
        try:
            logger.info("Polling consent status for request_id=%s at bank %s", request_id, bank_id)
            payload = await client.get_consent_status_by_request_id(request_id)
            data_section = payload.get("data", {}) if isinstance(payload, dict) else {}
            consent_id = (
                data_section.get("consentId")
                or data_section.get("consent_id")
                or payload.get("consent_id")
            )
            status_value = (
                data_section.get("status")
                or payload.get("status")
                or "unknown"
            )
            response: Dict[str, Any] = {
                "state": "pending",
                "status": status_value,
                "bank_id": bank_id,
                "request_id": request_id,
            }
            stored = get_consent_by_request_id(request_id)
            if stored and stored.get("approval_url"):
                response["approval_url"] = stored["approval_url"]
            approval_link = (
                payload.get("links", {}).get("consentApproval")
                if isinstance(payload, dict)
                else None
            )
            if approval_link:
                response["approval_url"] = approval_link

            if status_value in FAILED_CONSENT_STATUSES:
                response["state"] = "failed"
                if consent_id:
                    update_consent_from_request(request_id, consent_id, status_value)
                return response

            if consent_id:
                response["consent_id"] = consent_id
                if status_value in AUTHORIZED_CONSENT_STATUSES:
                    updated = update_consent_from_request(request_id, consent_id, "APPROVED")
                    if not updated:
                        consent_kind = (stored or {}).get("consent_type") or "accounts"
                        save_consent(
                            user_id,
                            bank_id,
                            consent_id,
                            "APPROVED",
                            request_id=request_id,
                            consent_type=consent_kind,
                        )
                    update_consent_status(consent_id, "APPROVED")
                    response["state"] = "approved"
            return response
        except HTTPException:
            raise
        except Exception as exc:  # noqa: BLE001
            logger.error("Failed to fetch consent status for bank %s: %s", bank_id, exc)
            raise HTTPException(status_code=502, detail=f"Failed to fetch consent status: {exc}") from exc


def mark_consent_from_callback(consent_id: str) -> bool:
    """Mark consent as approved when redirected back from bank."""
    return update_consent_status(consent_id, "APPROVED")
</file>

<file path="backend/services/goals.py">
from __future__ import annotations

from typing import Any, Dict, Optional

from hktn.core.analytics_engine import UserGoal

VALID_GOAL_PACES = {"conservative", "optimal", "fast"}


def _ensure_goal_details(payload: Optional[Dict[str, Any]]) -> Dict[str, Any]:
    if isinstance(payload, dict):
        return dict(payload)
    return {}


def compose_user_goal(
    stored_goal: Optional[Dict[str, Any]],
    goal_type_override: Optional[str] = None,
    goal_details_override: Optional[Dict[str, Any]] = None,
    pace_override: Optional[str] = None,
) -> UserGoal:
    base_details = _ensure_goal_details(goal_details_override) or _ensure_goal_details(
        (stored_goal or {}).get("goal_details")
        if stored_goal
        else {}
    )
    goal_type = goal_type_override or (stored_goal or {}).get("goal_type")
    if not goal_type:
        goal_type = "pay_debts"

    pace_candidates = (
        pace_override,
        base_details.get("pace"),
        base_details.get("save_speed"),
        base_details.get("close_speed"),
    )
    pace = next(
        (candidate for candidate in pace_candidates if isinstance(candidate, str) and candidate in VALID_GOAL_PACES),
        "optimal",
    )
    return UserGoal(goal_type=goal_type, pace=pace, goal_details=base_details)
</file>

<file path="backend/services/onboarding.py">
from __future__ import annotations

import asyncio
import logging
from datetime import datetime, timezone
from typing import Any, Dict

from fastapi import HTTPException, status

from hktn.core.database import (
    commit_onboarding_session,
    find_approved_consents,
    get_latest_onboarding_session,
    get_product_consents_for_user,
    get_user_consents,
    get_user_goal,
    upsert_product_consents,
)

from ..schemas import FinancialPortraitRequest, IngestRequest, OnboardingCommitRequest, ProductConsentRequest
from .banking import fetch_bank_accounts_with_consent, fetch_bank_credits
from .products import apply_consent_flags, build_account_product, build_credit_product, group_products_by_bank

logger = logging.getLogger("finpulse.backend.onboarding")


async def preview_products(req: IngestRequest) -> Dict[str, Any]:
    """Fetch lightweight preview of accounts and credits for onboarding."""
    approved_consents = find_approved_consents(req.user_id, consent_type="accounts")
    if not approved_consents:
        raise HTTPException(
            status_code=status.HTTP_424_FAILED_DEPENDENCY,
            detail="No approved consents found.",
        )

    account_tasks = [
        fetch_bank_accounts_with_consent(consent.bank_id, consent.consent_id, req.user_id)
        for consent in approved_consents
    ]
    credit_tasks = [
        fetch_bank_credits(
            consent.bank_id,
            consent.consent_id,
            req.user_id,
            req.user_name,
            create_product_consent=True,
        )
        for consent in approved_consents
    ]

    account_results, credit_results = await asyncio.gather(
        asyncio.gather(*account_tasks),
        asyncio.gather(*credit_tasks),
    )

    products_by_bank: Dict[str, list[Dict[str, Any]]] = {}
    for res in account_results:
        bank_id = res["bank_id"]
        products_by_bank.setdefault(bank_id, [])
        if res["status"] != "ok":
            continue
        for account in res.get("accounts", []) or []:
            enriched = build_account_product(account, bank_id)
            if not enriched:
                continue
            products_by_bank[bank_id].append(enriched)

    for res in credit_results:
        bank_id = res["bank_id"]
        products_by_bank.setdefault(bank_id, [])
        if res["status"] != "ok":
            continue
        for credit in res.get("credits", []) or []:
            enriched = build_credit_product(credit, bank_id)
            if not enriched:
                continue
            products_by_bank[bank_id].append(enriched)

    existing_consents = get_product_consents_for_user(req.user_id)
    products_by_bank = apply_consent_flags(products_by_bank, existing_consents)
    latest_state = get_user_consents(req.user_id) or []

    return {"productsByBank": products_by_bank, "latestConsentState": latest_state}


def save_product_consents(req: ProductConsentRequest) -> Dict[str, Any]:
    """Persist the user's product consent selections."""
    if not req.user_id:
        raise HTTPException(status_code=400, detail="user_id is required.")

    approved_consents = find_approved_consents(req.user_id, consent_type="accounts")
    if not approved_consents:
        raise HTTPException(
            status_code=status.HTTP_424_FAILED_DEPENDENCY,
            detail="No approved consents found.",
        )

    try:
        payload = [item.model_dump() for item in req.items]
        upsert_product_consents(req.user_id, payload)
        current_consents = get_product_consents_for_user(req.user_id)
        latest_state = get_user_consents(req.user_id) or []
        return {
            "status": "ok",
            "consents": current_consents,
            "latestConsentState": latest_state,
        }
    except Exception as exc:  # noqa: BLE001
        logger.error("Failed to save product consents for user %s: %s", req.user_id, exc)
        raise HTTPException(status_code=500, detail="Could not save product consents.") from exc


def finalize_onboarding(req: OnboardingCommitRequest) -> Dict[str, Any]:
    """Commit the onboarding flow and store a snapshot."""
    if not req.user_id:
        raise HTTPException(status_code=400, detail="user_id is required.")

    try:
        approved_consents = find_approved_consents(req.user_id, consent_type="accounts")
        if not approved_consents:
            raise HTTPException(
                status_code=status.HTTP_424_FAILED_DEPENDENCY,
                detail="No approved consents found.",
            )

        product_consents = get_product_consents_for_user(req.user_id)
        if not product_consents:
            raise HTTPException(
                status_code=status.HTTP_424_FAILED_DEPENDENCY,
                detail="No product consents have been saved.",
            )

        user_goal = get_user_goal(req.user_id)
        if not user_goal:
            raise HTTPException(
                status_code=status.HTTP_424_FAILED_DEPENDENCY,
                detail="No financial goal has been saved.",
            )

        connected_bank_ids = [consent.bank_id for consent in approved_consents]
        commit_onboarding_session(req.user_id, connected_bank_ids, product_consents, user_goal)

        snapshot = {
            "banks_connected": connected_bank_ids,
            "products_consented": product_consents,
            "goal_profile": user_goal,
            "completed_at": datetime.now(timezone.utc).isoformat(),
        }
        return {"status": "ok", "message": "Onboarding completed", "data": snapshot}
    except HTTPException:
        raise
    except Exception as exc:  # noqa: BLE001
        logger.error("Failed to commit onboarding for user %s: %s", req.user_id, exc)
        raise HTTPException(status_code=500, detail="Could not finalize onboarding session.") from exc


async def load_app_state(user_id: str, include_portrait: bool = False) -> Dict[str, Any]:
    """Return onboarding snapshot, consents and optional portrait for the SPA shell."""
    snapshot = get_latest_onboarding_session(user_id)
    product_consents = get_product_consents_for_user(user_id)
    consents = get_user_consents(user_id)

    response: Dict[str, Any] = {
        "user_id": user_id,
        "is_onboarded": snapshot is not None,
        "onboarding_snapshot": snapshot,
        "product_consents": product_consents,
        "consents": consents,
    }

    if not snapshot:
        response["reason"] = "onboarding_not_completed"
        return response

    user_goal = get_user_goal(user_id)
    response["goal"] = user_goal

    portrait = None
    portrait_error = None

    if include_portrait:
        try:
            portrait_request = FinancialPortraitRequest(
                user_id=user_id,
                goal_type=(user_goal or {}).get("goal_type"),
                goal_details=(user_goal or {}).get("goal_details"),
                pace=(user_goal or {}).get("goal_details", {}).get("save_speed")
                or (user_goal or {}).get("goal_details", {}).get("close_speed"),
            )
            # Lazy import to avoid circular dependency at module load time.
            from .analytics import build_financial_portrait_view

            portrait = await build_financial_portrait_view(portrait_request)
        except HTTPException as exc:
            if exc.status_code == status.HTTP_424_FAILED_DEPENDENCY:
                portrait_error = exc.detail
            else:
                raise

    response["portrait"] = portrait
    response["portrait_error"] = portrait_error
    return response
</file>

<file path="backend/services/products.py">
from __future__ import annotations

import uuid
from datetime import date, datetime
from typing import Any, Dict, List, Optional, Sequence, Tuple

from ..config import settings

BALANCE_FIELDS: Tuple[str, ...] = (
    "outstanding_balance",
    "outstandingBalance",
    "remaining_balance",
    "remainingBalance",
    "balance",
    "current_balance",
    "currentBalance",
    "principal",
    "principal_amount",
    "principalAmount",
    "amount",
    "available_balance",
    "availableBalance",
    "total_balance",
    "totalBalance",
)

PAYMENT_FIELDS: Tuple[str, ...] = (
    "min_payment",
    "minimum_payment",
    "payment",
    "monthly_payment",
    "monthlyPayment",
    "scheduled_payment",
    "installment_amount",
    "installmentAmount",
)

RATE_FIELDS: Tuple[str, ...] = (
    "rate",
    "interest_rate",
    "interestRate",
    "apr",
    "percentage",
    "rate_percent",
    "ratePercent",
)

DATE_FIELDS: Tuple[str, ...] = (
    "next_payment_date",
    "nextPaymentDate",
    "due_date",
    "dueDate",
    "payment_due_date",
    "paymentDueDate",
    "maturity_date",
    "maturityDate",
)


def _coerce_number(value: Any) -> Optional[float]:
    if value is None:
        return None
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return float(value)
    if isinstance(value, str):
        try:
            normalized = value.strip().replace("\u00a0", "").replace(" ", "").replace(",", ".")
            return float(normalized)
        except ValueError:
            return None
    if isinstance(value, dict):
        for nested_key in ("amount", "value", "balance", "current", "val"):
            if nested_key in value:
                nested = _coerce_number(value[nested_key])
                if nested is not None:
                    return nested
    if isinstance(value, (list, tuple)):
        for item in value:
            nested = _coerce_number(item)
            if nested is not None:
                return nested
    return None


def _extract_number(payload: Dict[str, Any], field_names: Sequence[str]) -> Optional[float]:
    for key in field_names:
        if key in payload:
            number = _coerce_number(payload[key])
            if number is not None:
                return number
    return None


def _extract_date(payload: Dict[str, Any], field_names: Sequence[str]) -> Optional[str]:
    for key in field_names:
        raw_value = payload.get(key)
        if not raw_value:
            continue
        if isinstance(raw_value, datetime):
            return raw_value.date().isoformat()
        if isinstance(raw_value, date):
            return raw_value.isoformat()
        if isinstance(raw_value, str):
            try:
                normalized = raw_value.replace("Z", "")
                return datetime.fromisoformat(normalized).date().isoformat()
            except ValueError:
                try:
                    return datetime.strptime(normalized, "%Y-%m-%dT%H:%M:%S").date().isoformat()
                except Exception:  # noqa: BLE001
                    continue
    return None


def _infer_product_type(candidates: Sequence[Optional[str]], default_type: str) -> str:
    for candidate in candidates:
        if not candidate:
            continue
        lowered = str(candidate).lower()
        if any(token in lowered for token in ("credit card", "creditcard", "кредитная карта")):
            return "credit_card"
        if "card" in lowered and any(token in lowered for token in ("credit", "кредит")):
            return "credit_card"
        if any(token in lowered for token in ("debit", "дебет", "checking")) and "card" in lowered:
            return "debit_card"
        if any(token in lowered for token in ("deposit", "вклад", "накоп", "savings")):
            return "deposit"
        if any(token in lowered for token in ("loan", "кредит", "ипотека", "installment")):
            return "loan"
    return default_type


def build_account_product(account: Dict[str, Any], bank_id: str) -> Optional[Dict[str, Any]]:
    if not isinstance(account, dict):
        return None
    config = settings.banks.get(bank_id)
    bank_name = config.display_name if config else bank_id
    account_id = (
        account.get("accountId")
        or account.get("account_id")
        or account.get("id")
        or account.get("resource_id")
        or str(uuid.uuid4())
    )
    balance = _extract_number(account, BALANCE_FIELDS)
    rate = _extract_number(account, RATE_FIELDS)
    rate_value = None
    if rate is not None:
        rate_value = round(rate * 100, 2) if rate <= 1 else round(rate, 2)
    product_type = _infer_product_type(
        (
            str(account.get("product_type")),
            str(account.get("accountSubType")),
            str(account.get("accountType")),
            str(account.get("nickname")),
        ),
        "debit_card",
    )
    name = (
        account.get("nickname")
        or account.get("accountName")
        or account.get("product")
        or account.get("product_name")
        or "Счет"
    )
    return {
        "id": account_id,
        "type": product_type,
        "product_type": product_type,
        "name": name,
        "bank_id": bank_id,
        "bank_name": bank_name,
        "consented": False,
        "tos_url": account.get("tos_url") or "#",
        "outstanding_balance": round(balance, 2) if balance is not None else None,
        "balance": round(balance, 2) if balance is not None else None,
        "min_payment": None,
        "next_payment_date": None,
        "rate": rate_value,
        "raw_product": account,
    }


def build_credit_product(credit: Dict[str, Any], bank_id: str) -> Optional[Dict[str, Any]]:
    if not isinstance(credit, dict):
        return None
    config = settings.banks.get(bank_id)
    bank_name = config.display_name if config else bank_id
    credit_id = (
        credit.get("agreement_id")
        or credit.get("credit_id")
        or credit.get("id")
        or str(uuid.uuid4())
    )
    balance = _extract_number(credit, BALANCE_FIELDS)
    min_payment = _extract_number(credit, PAYMENT_FIELDS)
    next_payment = _extract_date(credit, DATE_FIELDS)
    rate = _extract_number(credit, RATE_FIELDS)
    normalized_rate = None
    if rate is not None:
        normalized_rate = round(rate * 100, 2) if rate <= 1 else round(rate, 2)
    product_type = _infer_product_type(
        (
            str(credit.get("product_type")),
            str(credit.get("type")),
            str(credit.get("product")),
            str(credit.get("name")),
        ),
        "loan",
    )
    name = credit.get("name") or credit.get("product_name") or credit.get("product") or "Кредит"
    return {
        "id": credit_id,
        "type": product_type,
        "product_type": product_type,
        "name": name,
        "bank_id": bank_id,
        "bank_name": bank_name,
        "consented": False,
        "tos_url": credit.get("tos_url") or "#",
        "outstanding_balance": round(balance, 2) if balance is not None else None,
        "balance": round(balance, 2) if balance is not None else None,
        "min_payment": round(min_payment, 2) if min_payment is not None else None,
        "next_payment_date": next_payment,
        "rate": normalized_rate,
        "raw_product": credit,
    }


def group_products_by_bank(
    accounts: Sequence[Dict[str, Any]],
    credits: Sequence[Dict[str, Any]],
) -> Dict[str, List[Dict[str, Any]]]:
    grouped: Dict[str, List[Dict[str, Any]]] = {}
    for product in list(accounts) + list(credits):
        bank_id = product.get("bank_id") or "unknown"
        grouped.setdefault(bank_id, []).append(product)
    return grouped


def apply_consent_flags(
    products_by_bank: Dict[str, List[Dict[str, Any]]],
    product_consents: Sequence[Dict[str, Any]] | None,
) -> Dict[str, List[Dict[str, Any]]]:
    if not product_consents:
        return products_by_bank
    index = {
        (item.get("bank_id"), item.get("product_id")): bool(item.get("consented"))
        for item in product_consents
    }
    for bank_products in products_by_bank.values():
        for product in bank_products:
            key = (product.get("bank_id"), product.get("id"))
            if key in index:
                product["consented"] = index[key]
    return products_by_bank
</file>

<file path="backend/__init__.py">
from .app import create_app

__all__ = ["create_app"]
</file>

<file path="backend/app.py">
from __future__ import annotations

import logging

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from hktn.core.database import init_db
from .config import settings
from .routers import analytics, banks, consents, onboarding, profile

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("finpulse.backend")


def create_app() -> FastAPI:
    app = FastAPI(title=settings.title, version=settings.version)

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    app.include_router(banks.router)
    app.include_router(consents.router)
    app.include_router(onboarding.router)
    app.include_router(profile.router)
    app.include_router(analytics.router)

    @app.on_event("startup")
    def _on_startup() -> None:
        logger.info("Bootstrapping FinPulse backend")
        init_db()

    return app


app = create_app()
</file>

<file path="backend/config.py">
from __future__ import annotations

import os
from pathlib import Path
from typing import Dict, List, Optional

from dotenv import load_dotenv

BASE_DIR = Path(__file__).resolve().parent.parent
load_dotenv(BASE_DIR / ".env")


class BankConfig(dict):
    """Dictionary-backed bank configuration with attribute helpers."""

    def __init__(self, display_name: str, url: Optional[str]):
        super().__init__(display_name=display_name, url=url)

    @property
    def display_name(self) -> str:
        return self.get("display_name", "")

    @display_name.setter
    def display_name(self, value: str) -> None:
        self["display_name"] = value

    @property
    def url(self) -> Optional[str]:
        return self.get("url")

    @url.setter
    def url(self, value: Optional[str]) -> None:
        self["url"] = value


def _build_bank_configs() -> Dict[str, BankConfig]:
    """Load partner bank configuration from environment variables."""
    return {
        "vbank": BankConfig(display_name="VBank", url=os.getenv("VBANK_API_URL")),
        "abank": BankConfig(display_name="ABank", url=os.getenv("ABANK_API_URL")),
        "sbank": BankConfig(display_name="SBank", url=os.getenv("SBANK_API_URL")),
    }


class Settings:
    """Runtime settings shared across the backend application."""

    def __init__(self) -> None:
        self.title: str = "FinPulse Experience API"
        self.version: str = "4.0.0"
        self.frontend_url: str = os.getenv("FRONTEND_URL", "http://localhost:5173")
        self.cors_origins: List[str] = [
            "http://localhost:3000",
            "http://localhost:5173",
            "http://127.0.0.1:5173",
        ]
        self.api_cache_ttl: int = int(os.getenv("API_CACHE_TTL", "300"))
        self.api_cache_size: int = int(os.getenv("API_CACHE_SIZE", "100"))
        self.team_client_id: Optional[str] = os.getenv("CLIENT_ID")
        self.team_client_secret: Optional[str] = os.getenv("CLIENT_SECRET")
        self.banks: Dict[str, BankConfig] = _build_bank_configs()


settings = Settings()
</file>

<file path="backend/schemas.py">
from __future__ import annotations

from datetime import date, timedelta
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class ConsentInitiateRequest(BaseModel):
    user_id: str
    bank_id: str


class AnalysisRequest(BaseModel):
    user_id: str
    current_balance: float = 50_000.0
    payment_date: date = Field(default_factory=lambda: date.today() + timedelta(days=15))
    payment_amount: float = 25_000.0


class GoalRequest(BaseModel):
    user_id: str
    goal_type: str
    goal_details: Dict[str, Any]


class IngestRequest(BaseModel):
    user_id: str
    user_name: Optional[str] = None


class FinancialPortraitRequest(BaseModel):
    user_id: str
    user_name: Optional[str] = None
    goal_type: Optional[str] = None
    pace: Optional[str] = None
    goal_details: Optional[Dict[str, Any]] = None
    force_error_for_bank: Optional[str] = None


class ProductConsentItem(BaseModel):
    bank_id: str
    product_id: str
    product_type: Optional[str] = None
    consented: bool


class ProductConsentRequest(BaseModel):
    user_id: str
    items: List[ProductConsentItem]


class OnboardingCommitRequest(BaseModel):
    user_id: str


class PreviewResponse(BaseModel):
    productsByBank: Dict[str, List[Dict[str, Any]]]
    latestConsentState: List[Dict[str, Any]] = Field(default_factory=list)
</file>

<file path="backend/state.py">
from __future__ import annotations

from cachetools import TTLCache

from .config import settings

# Shared cache for expensive banking API calls.
api_cache: TTLCache[str, dict] = TTLCache(maxsize=settings.api_cache_size, ttl=settings.api_cache_ttl)
</file>

<file path="core/__init__.py">
"""Core package exposing primary interfaces for the FinPulse project."""

from .analytics_engine import build_financial_portrait, run_analysis, UserGoal
from .data_models import AnalysisResult, Transaction
from .obr_client import ConsentInitResult, OBRAPIClient

__all__ = [
    "run_analysis",
    "build_financial_portrait",
    "UserGoal",
    "OBRAPIClient",
    "ConsentInitResult",
    "AnalysisResult",
    "Transaction",
]
</file>

<file path="core/analytics_engine.py">
"""Financial Pulse analytics engine with probabilistic forecasting."""
from __future__ import annotations

import math
import re
from collections import Counter
from datetime import date, datetime, timedelta
from typing import Any, Dict, Iterable, List, Optional, Sequence, Set, Tuple, Literal

import numpy as np
import pandas as pd
from scipy.spatial.distance import cosine
from sklearn.cluster import DBSCAN
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import StandardScaler

from pydantic import BaseModel, Field

from .data_models import AnalysisResult, Transaction

# Feature weighting balances numeric and textual signal strength.
_NUMERIC_FEATURE_WEIGHT = 2.5
_TEXT_FEATURE_WEIGHT = 1.0
_DEFAULT_SIMULATIONS = 1200
_MIN_SIGMA_AMOUNT = 1.0

MCC_TO_LABEL = {
    "5732": "Электроника",
    "5411": "Супермаркеты",
    "5812": "Рестораны и кафе",
    "5814": "Фастфуд",
    "4814": "Связь и интернет",
    "6011": "Снятие наличных",
    "4121": "Такси",
    "4900": "Коммунальные услуги",
    "5541": "АЗС",
    "6300": "Страхование",
}


class UserGoal(BaseModel):
    """Represents user's desired financial outcome and preferred pace."""

    goal_type: Literal["pay_debts", "save_money"] = "pay_debts"
    pace: Literal["conservative", "optimal", "fast"] = "optimal"
    goal_details: Dict[str, Any] = Field(default_factory=dict)


def _safe_float(value: Any) -> Optional[float]:
    """Best-effort conversion to float."""
    if value is None:
        return None
    if isinstance(value, (int, float)) and not isinstance(value, bool):
        return float(value)
    if isinstance(value, str):
        try:
            return float(value.strip())
        except ValueError:
            return None
    return None


def _stringify(value: Any) -> str:
    """Return a trimmed string representation for feature engineering."""
    if value is None:
        return ""
    if isinstance(value, str):
        return value.strip()
    return str(value).strip()


def estimate_goal_probability(
    goal: UserGoal,
    trajectories: np.ndarray,
    forecast_dates: Sequence[date],
    obligations: Optional[Sequence[Dict[str, Any]]] = None,
    event_profiles: Optional[Sequence[Dict[str, Any]]] = None,
) -> int:
    """
    Approximate probability (0-100%) that a user will hit the selected goal.
    save_money: share of forecast paths ending above the target balance.
    pay_debts: compares recurring income vs. required obligations.
    """
    if trajectories.size == 0 or not forecast_dates:
        return 0

    details = goal.goal_details or {}
    terminal_balances = trajectories[:, -1]

    if goal.goal_type == "save_money":
        target_candidates = (
            details.get("save_amount"),
            details.get("target_amount"),
            details.get("targeted_balance"),
        )
        target_amount = next(
            (val for val in ( _safe_float(candidate) for candidate in target_candidates ) if val is not None),
            None,
        )
        if target_amount is None or target_amount <= 0:
            target_amount = float(np.median(terminal_balances))
        probability = float(np.mean(terminal_balances >= target_amount))
        return int(round(np.clip(probability * 100.0, 0.0, 100.0)))

    # pay_debts
    obligation_total = sum(float(item.get("amount") or 0.0) for item in obligations or [])
    targeted_payment = _safe_float(details.get("targeted_monthly_payment"))
    if obligation_total <= 0 and targeted_payment:
        obligation_total = targeted_payment
    if obligation_total <= 0:
        return 85  # nothing to pay off

    income_total = 0.0
    for profile in event_profiles or []:
        if profile.get("is_income"):
            income_total += float(profile.get("mu_amount") or 0.0)
    if income_total <= 0:
        declared_income = _safe_float(details.get("declared_income"))
        income_total = declared_income or 0.0
    if income_total <= 0:
        return 25

    coverage_ratio = income_total / max(obligation_total, 1.0)
    probability = np.clip(coverage_ratio / 1.5, 0.0, 1.0) * 100.0
    return int(round(probability))


def _coerce_to_date(value: Any) -> Optional[date]:
    """Normalize multiple date formats to python date."""
    if value is None:
        return None
    if isinstance(value, date) and not isinstance(value, datetime):
        return value
    if isinstance(value, datetime):
        return value.date()
    if isinstance(value, pd.Timestamp):
        return value.to_pydatetime().date()
    if isinstance(value, str):
        try:
            normalized = value.replace("Z", "")
            return datetime.fromisoformat(normalized).date()
        except ValueError:
            return None
    return None


def _derive_event_label(profile: Dict[str, Any]) -> str:
    """Generate a human-friendly label for recurring events."""
    metadata = profile.get("metadata") or {}
    dominant_mcc = profile.get("mcc_code") or metadata.get("dominant_mcc_code")
    if dominant_mcc:
        label = MCC_TO_LABEL.get(str(dominant_mcc))
        if label:
            return label
    merchant_name = (
        profile.get("merchant_name")
        or metadata.get("dominant_merchant")
        or metadata.get("merchant_category")
    )
    if merchant_name:
        return merchant_name
    raw_label = profile.get("label")
    if isinstance(raw_label, str) and raw_label.strip():
        normalized = raw_label.strip().lower()
        if normalized.startswith("выруч"):
            return "Регулярный доход"
        if normalized.startswith("закуп"):
            return "Регулярный расход"
        return raw_label.strip()
    return "Регулярный доход" if profile.get("is_income") else "Регулярный расход"


def extract_recurring_events(
    event_profiles: Sequence[Dict[str, Any]],
    limit: int = 8,
    exclude_cluster_ids: Optional[Set[int]] = None,
) -> List[Dict[str, Any]]:
    """Produce a simplified list of recurring events for UI."""
    events: List[Dict[str, Any]] = []
    today = date.today()
    excluded = {int(cid) for cid in (exclude_cluster_ids or set()) if cid is not None}

    for profile in event_profiles or []:
        cluster_id = profile.get("cluster_id")
        if cluster_id is not None and int(cluster_id) in excluded:
            continue

        label = _derive_event_label(profile)
        amount = round(float(profile.get("mu_amount") or 0.0), 2)
        is_income = bool(profile.get("is_income"))
        frequency_days = int(profile.get("frequency_days") or profile.get("frequencyDays") or 30)
        frequency_days = max(frequency_days, 1)
        last_date = _coerce_to_date(
            profile.get("last_date")
            or profile.get("lastDate")
            or profile.get("last_occurrence")
            or profile.get("lastOccurrence")
        )
        next_date = last_date or today
        while next_date <= today:
            next_date += timedelta(days=frequency_days)

        metadata = profile.get("metadata") or {}
        mcc_code = profile.get("mcc_code") or metadata.get("dominant_mcc_code")
        category = (
            profile.get("merchant_category")
            or metadata.get("merchant_category")
            or metadata.get("transaction_category")
        )
        merchant_name = profile.get("merchant_name") or metadata.get("dominant_merchant")
        source = profile.get("source") or ("recurring_income" if is_income else "recurring_debit")

        events.append(
            {
                "name": label,
                "amount": amount,
                "is_income": is_income,
                "next_date": next_date.isoformat(),
                "frequency_days": frequency_days,
                "mcc_code": mcc_code,
                "category": category,
                "merchant_name": merchant_name,
                "bank_transaction_code": profile.get("bank_transaction_code")
                or metadata.get("dominant_bank_transaction_code"),
                "source": source,
            }
        )

    events.sort(key=lambda item: item["next_date"])
    return events[:limit]


def _calculate_annuity_payment(principal: float, annual_rate_percent: float, term_months: int) -> float:
    """
    Compute best-effort annuity payment when API does not return min_payment explicitly.
    """
    if principal <= 0:
        return 0.0
    if term_months <= 0:
        return 0.0
    if annual_rate_percent <= 0:
        return round(principal / term_months, 2)

    monthly_rate = (annual_rate_percent / 100.0) / 12.0
    try:
        factor = (1 + monthly_rate) ** term_months
        denom = factor - 1
        if denom == 0:
            payment = principal / term_months
        else:
            payment = principal * (monthly_rate * factor / denom)
    except OverflowError:
        payment = principal / term_months
    return round(payment, 2)


def _parse_payment_date(date_raw: Optional[str]) -> Optional[date]:
    """Safely parse payment date from ISO-like formats."""
    if not date_raw:
        return None
    try:
        normalized = date_raw.replace("Z", "")
        return datetime.fromisoformat(normalized).date()
    except (ValueError, TypeError, AttributeError):
        return None


def _create_obligations_from_credits(credits: Sequence[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Transform credit agreements into deterministic payment obligations."""
    obligations: List[Dict[str, Any]] = []
    for credit in credits or []:
        payment_amount = float(credit.get("min_payment") or credit.get("payment") or 0.0)
        if payment_amount <= 0:
            principal = float(credit.get("balance") or credit.get("principal") or 0.0)
            rate = float(credit.get("rate") or credit.get("interest_rate") or 0.0)
            term_months = int(credit.get("term_months") or credit.get("termMonths") or 36)
            if principal > 0:
                payment_amount = _calculate_annuity_payment(principal, rate * 100 if rate < 1 else rate, term_months)

        if payment_amount <= 0:
            continue

        obligations.append(
            {
                "label": credit.get("name") or credit.get("product") or "Кредитный платеж",
                "amount": round(payment_amount, 2),
                "due_date": _parse_payment_date(credit.get("next_payment_date")),
                "source": "credit_agreement",
                "mcc_code": credit.get("mccCode"),
                "merchant_name": credit.get("name"),
                "category": credit.get("category") or credit.get("type"),
                "bank_transaction_code": None,
                "frequency_days": 30,
            }
        )
    return obligations


def _event_to_obligation(event: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """Convert a debit event profile into a deterministic obligation payload."""
    if event.get("is_income"):
        return None

    amount = abs(float(event.get("mu_amount") or 0.0))
    if amount <= 0:
        return None

    sample_size = int(event.get("sample_size") or 0)
    if sample_size < 2:
        return None

    coherence = float(event.get("coherence") or 0.0)
    metadata = event.get("metadata") or {}
    mcc_code = event.get("mcc_code") or metadata.get("dominant_mcc_code")
    mcc_consistency = float(metadata.get("mcc_consistency") or 0.0)

    if coherence < 0.55 and mcc_consistency < 0.5:
        return None

    frequency_days = max(int(round(event.get("frequency_days") or 30)), 1)
    last_date = event.get("last_date")
    if isinstance(last_date, pd.Timestamp):
        last_date = last_date.date()
    elif isinstance(last_date, datetime):
        last_date = last_date.date()
    if not isinstance(last_date, date):
        last_date = date.today()

    next_due = last_date
    while next_due <= date.today():
        next_due += timedelta(days=frequency_days)

    label = (
        metadata.get("dominant_merchant")
        or metadata.get("merchant_category")
        or event.get("label")
        or "Recurring debit"
    )

    return {
        "label": label,
        "amount": round(amount, 2),
        "due_date": next_due,
        "source": "recurring_debit",
        "mcc_code": mcc_code,
        "merchant_name": metadata.get("dominant_merchant"),
        "category": metadata.get("merchant_category") or metadata.get("transaction_category"),
        "bank_transaction_code": event.get("bank_transaction_code"),
        "cluster_id": event.get("cluster_id"),
        "frequency_days": frequency_days,
    }


def derive_obligations(
    credits: Sequence[Dict[str, Any]],
    event_profiles: Sequence[Dict[str, Any]],
) -> List[Dict[str, Any]]:
    """Combine credit-derived obligations with recurring debit events."""
    obligations = _create_obligations_from_credits(credits)
    for event in event_profiles or []:
        obligation = _event_to_obligation(event)
        if obligation:
            obligations.append(obligation)
    return obligations


def _credit_identifier(credit: Dict[str, Any]) -> Optional[str]:
    for key in ("id", "agreement_id", "credit_id", "product_id"):
        if credit.get(key):
            return str(credit[key])
    return None


PACE_COEFFICIENTS: Dict[str, float] = {
    "conservative": 0.10,
    "optimal": 0.25,
    "fast": 0.50,
}


def _find_next_income_event(event_profiles: List[Dict[str, Any]], start_date: date) -> Optional[Dict[str, Any]]:
    """Locate the soonest expected income event."""
    candidates: List[Dict[str, Any]] = []
    for event in event_profiles or []:
        if not event.get("is_income"):
            continue
        last_date: date = event.get("last_date") or start_date
        frequency = timedelta(days=max(int(round(event.get("frequency_days", 30) or 30)), 1))
        next_date = last_date
        while next_date <= start_date:
            next_date += frequency
        candidates.append(
            {
                "next_occurrence": next_date,
                "mu_amount": float(event.get("mu_amount") or 0.0),
                "label": event.get("label") or "Доход",
            }
        )
    if not candidates:
        return None
    return min(candidates, key=lambda item: item["next_occurrence"])


_BALANCE_FALLBACK_FIELDS = (
    "balances",
    "balance",
    "current",
    "available",
    "amount",
    "value",
)

_ID_HINTS_TO_SKIP = {
    "accountid",
    "account_id",
    "resource_id",
    "identification",
    "agreement_id",
    "iban",
    "pan",
    "mask",
    "card",
    "id",
}


def _resolve_numeric_value(value: Any, key_hint: str | None = None) -> Optional[float]:
    """Traverse nested structures to coerce a numeric amount."""
    if key_hint:
        hint = key_hint.replace("-", "_").lower()
        if hint in _ID_HINTS_TO_SKIP:
            return None

    number = _safe_float(value)
    if number is not None:
        return number
    if isinstance(value, dict):
        for nested_key in _BALANCE_FALLBACK_FIELDS:
            if nested_key in value:
                nested = _resolve_numeric_value(value[nested_key], nested_key)
                if nested is not None:
                    return nested
        for nested_key, nested in value.items():
            nested_value = _resolve_numeric_value(nested, nested_key)
            if nested_value is not None:
                return nested_value
    if isinstance(value, (list, tuple)):
        for item in value:
            nested = _resolve_numeric_value(item)
            if nested is not None:
                return nested
    return None


def _extract_account_balance(account: Dict[str, Any]) -> float:
    """
    Best-effort balance extraction across heterogeneous account payloads.
    Prioritizes nested 'balances' array as seen in sandbox data.
    """
    balances_list = account.get("balances")
    if isinstance(balances_list, list) and balances_list:
        balance_obj = balances_list[0]
        if isinstance(balance_obj, dict):
            for key in ("availableBalance", "available_balance", "currentBalance", "current_balance"):
                if key in balance_obj and balance_obj[key] is not None:
                    amount = _resolve_numeric_value(balance_obj[key], key)
                    if amount is not None:
                        return amount
            amount = _resolve_numeric_value(balance_obj)
            if amount is not None:
                return amount

    balance_keys = (
        "available_balance",
        "availableBalance",
        "balance",
        "current_balance",
        "currentBalance",
        "total_balance",
        "totalBalance",
    )
    for key in balance_keys:
        if key in account and account[key] is not None:
            amount = _resolve_numeric_value(account[key], key)
            if amount is not None:
                return amount

    for fallback_key in _BALANCE_FALLBACK_FIELDS:
        if fallback_key in account and account[fallback_key] is not None:
            amount = _resolve_numeric_value(account[fallback_key], fallback_key)
            if amount is not None:
                return amount

    final_attempt = _resolve_numeric_value(account)
    if final_attempt is not None:
        return final_attempt

    return 0.0


def calculate_daily_s2s(
    current_balance: float,
    event_profiles: List[Dict[str, Any]],
    obligations: List[Dict[str, Any]],
    user_goal: UserGoal,
    start_date: Optional[date] = None,
    return_details: bool = False,
) -> float | Tuple[float, Dict[str, Any]]:
    """
    Estimate safe-to-spend per day using only the cash that already exists on the account.
    Future income does not count toward the available balance — it merely defines the horizon.
    """
    if start_date is None:
        start_date = date.today()

    next_income = _find_next_income_event(event_profiles, start_date)
    if next_income:
        cycle_end = next_income["next_occurrence"]
    else:
        cycle_end = start_date + timedelta(days=30)

    days_in_cycle = max((cycle_end - start_date).days, 1)

    cycle_expenses = 0.0
    for obligation in obligations or []:
        due_date = obligation.get("due_date")
        if isinstance(due_date, date) and start_date <= due_date < cycle_end:
            cycle_expenses += float(obligation.get("amount") or 0.0)

    free_cash = current_balance - cycle_expenses
    next_income_payload = None
    if next_income:
        next_occurrence = next_income["next_occurrence"]
        next_income_payload = {
            "label": next_income.get("label"),
            "next_occurrence": next_occurrence.isoformat(),
            "amount": round(float(next_income.get("mu_amount") or 0.0), 2),
        }

    details = {
        "cycle_start": start_date.isoformat(),
        "cycle_end": cycle_end.isoformat(),
        "days_in_cycle": days_in_cycle,
        "current_balance": round(current_balance, 2),
        "obligations_total": round(cycle_expenses, 2),
        "free_cash": round(free_cash, 2),
        "goal_reserve": 0.0,
        "spendable_total": 0.0,
        "next_income_event": next_income_payload,
    }

    if free_cash <= 0:
        return (0.0, details) if return_details else 0.0

    reserve = 0.0
    if user_goal.goal_type == "pay_debts":
        reserve = free_cash * PACE_COEFFICIENTS.get(user_goal.pace, 0.25)

    spendable = max(0.0, free_cash - reserve)
    result = round(spendable / days_in_cycle, 2)
    details["goal_reserve"] = round(reserve, 2)
    details["spendable_total"] = round(spendable, 2)
    return (result, details) if return_details else result


def _normalize_description(value: Optional[str]) -> str:
    """Normalize merchant description: lowercase alpha characters only."""
    if not isinstance(value, str):
        return "unknown"
    cleaned = re.sub(r"[^a-zA-Zа-яА-Я\s]", " ", value).lower()
    normalized = re.sub(r"\s+", " ", cleaned).strip()
    return normalized or "unknown"


def _prepare_transactions_df(transactions: Sequence[Transaction]) -> pd.DataFrame:
    """Convert transactions into a consistently typed DataFrame."""
    if not transactions:
        return pd.DataFrame(columns=["transactionId", "amount", "description", "bookingDate"])

    df = pd.DataFrame([tx.model_dump() for tx in transactions])
    df["bookingDate"] = pd.to_datetime(df["bookingDate"])
    df = df.sort_values("bookingDate").reset_index(drop=True)
    for field in ("description", "transactionInformation", "creditDebitIndicator", "bankTransactionCode", "mccCode", "category"):
        if field not in df:
            df[field] = None
    if "merchant" not in df:
        df["merchant"] = [{} for _ in range(len(df))]

    df["description"] = df["description"].fillna("")
    df["transactionInformation"] = df["transactionInformation"].fillna("")
    merchant_series = df["merchant"].apply(lambda value: value if isinstance(value, dict) else {})
    df["merchantName"] = merchant_series.apply(lambda merchant: _stringify(merchant.get("name")))
    df["merchantCategory"] = merchant_series.apply(lambda merchant: _stringify(merchant.get("category")))
    df["merchantMcc"] = merchant_series.apply(lambda merchant: _stringify(merchant.get("mccCode") or merchant.get("mcc")))

    empty_mask = df["description"].str.strip() == ""
    df.loc[empty_mask, "description"] = df.loc[empty_mask, "transactionInformation"]
    empty_mask = df["description"].str.strip() == ""
    df.loc[empty_mask, "description"] = df.loc[empty_mask, "merchantName"]
    df["description"] = df["description"].fillna("")

    df["bankTransactionCode"] = df["bankTransactionCode"].apply(_stringify)
    df["creditDebitIndicator"] = df["creditDebitIndicator"].apply(_stringify)
    df["category"] = df["category"].apply(_stringify)
    df["mcc_code"] = df["mccCode"]
    df.loc[df["mcc_code"].isna(), "mcc_code"] = df.loc[df["mcc_code"].isna(), "merchantMcc"]
    df["mcc_code"] = df["mcc_code"].apply(lambda value: _stringify(value) or None)
    df["has_mcc"] = df["mcc_code"].notna()

    df["normalized_description"] = df["description"].apply(_normalize_description)
    df["day_of_month"] = df["bookingDate"].dt.day.astype(float)
    df["is_income"] = (df["amount"] >= 0).astype(int)
    return df


def _discover_events(df: pd.DataFrame) -> pd.DataFrame:
    """Cluster transactions that form recurring financial events."""
    if df.empty:
        df["cluster_id"] = []
        return df

    text_vectorizer = TfidfVectorizer(min_df=1, ngram_range=(1, 2))
    text_features = text_vectorizer.fit_transform(df["normalized_description"]).toarray()
    if text_features.size == 0:
        text_features = np.zeros((len(df), 1))

    scaler = StandardScaler()
    numeric_features = df[["amount", "day_of_month"]].astype(float).copy()
    mcc_codes = df["mcc_code"].fillna("unknown")
    numeric_features["mcc_code_feature"] = pd.factorize(mcc_codes)[0].astype(float)
    scaled_numeric = scaler.fit_transform(numeric_features) * _NUMERIC_FEATURE_WEIGHT
    scaled_text = text_features * _TEXT_FEATURE_WEIGHT

    feature_matrix = np.hstack([scaled_numeric, scaled_text])

    if len(df) < 2:
        cluster_labels = np.full(len(df), -1, dtype=int)
    else:
        dbscan = DBSCAN(eps=0.85, min_samples=2, metric="euclidean")
        cluster_labels = dbscan.fit_predict(feature_matrix)

    df_with_clusters = df.copy()
    df_with_clusters["cluster_id"] = cluster_labels
    return df_with_clusters


def _cluster_label(descriptions: Iterable[str]) -> str:
    """Generate a human readable label for cluster."""
    filtered = [desc for desc in descriptions if desc]
    if not filtered:
        return "Recurring event"

    token_counter: Counter[str] = Counter()
    for desc in filtered:
        token_counter.update(desc.split())

    most_common = token_counter.most_common(2)
    label = " ".join(token for token, _ in most_common[:2])
    return label.title() if label else "Recurring event"


def _cluster_coherence(normalized_descriptions: Sequence[str]) -> float:
    """Estimate textual cohesion inside the cluster using cosine similarity."""
    if len(normalized_descriptions) <= 1:
        return 1.0

    vectorizer = TfidfVectorizer()
    matrix = vectorizer.fit_transform(normalized_descriptions).toarray()
    centroid = matrix.mean(axis=0)
    # Guard against degenerate vectors.
    if not np.any(centroid):
        return 0.5
    similarities = []
    for row in matrix:
        if not np.any(row):
            continue
        similarities.append(1 - cosine(centroid, row))
    return float(np.mean(similarities)) if similarities else 0.5


def _profile_events(df_with_clusters: pd.DataFrame) -> Tuple[List[Dict[str, object]], Dict[str, float]]:
    """Build probabilistic profiles for discovered events and background noise."""
    event_profiles: List[Dict[str, object]] = []

    for cluster_id, cluster_df in df_with_clusters.groupby("cluster_id"):
        if cluster_id == -1:
            continue

        cluster_df = cluster_df.sort_values("bookingDate")
        amount_series = cluster_df["amount"]
        day_series = cluster_df["day_of_month"]

        # Exponentially weighted mean emphasises recent behavior.
        mu_amount = float(cluster_df["amount"].ewm(alpha=0.35).mean().iloc[-1])
        sigma_amount = float(amount_series.std(ddof=0)) if len(cluster_df) > 1 else 0.0
        sigma_amount = max(sigma_amount, _MIN_SIGMA_AMOUNT)

        mu_day = float(day_series.mean())
        sigma_day = float(day_series.std(ddof=0)) if len(cluster_df) > 1 else 1.5
        sigma_day = max(sigma_day, 1.5)

        intervals = cluster_df["bookingDate"].diff().dt.days.dropna()
        if not intervals.empty:
            frequency_days = float(np.clip(np.median(intervals), 1, 45))
        else:
            frequency_days = 30.0

        descriptions = cluster_df["description"].tolist()
        normalized_descriptions = cluster_df["normalized_description"].tolist()
        coherence = _cluster_coherence(normalized_descriptions)
        last_date = cluster_df["bookingDate"].iloc[-1].date()
        dominant_sign = cluster_df["is_income"].mean()

        mcc_counter = Counter(code for code in cluster_df["mcc_code"].tolist() if code)
        bank_code_counter = Counter(code for code in cluster_df["bankTransactionCode"].tolist() if code)
        merchant_counter = Counter(name for name in cluster_df["merchantName"].tolist() if name)
        merchant_category_counter = Counter(cat for cat in cluster_df["merchantCategory"].tolist() if cat)
        txn_category_counter = Counter(cat for cat in cluster_df["category"].tolist() if cat)

        dominant_mcc = mcc_counter.most_common(1)[0][0] if mcc_counter else None
        dominant_bank_code = bank_code_counter.most_common(1)[0][0] if bank_code_counter else None
        dominant_merchant = merchant_counter.most_common(1)[0][0] if merchant_counter else None
        dominant_merchant_category = (
            merchant_category_counter.most_common(1)[0][0] if merchant_category_counter else None
        )
        dominant_txn_category = txn_category_counter.most_common(1)[0][0] if txn_category_counter else None
        total_mcc_samples = sum(mcc_counter.values())
        mcc_consistency = (
            mcc_counter[dominant_mcc] / total_mcc_samples if dominant_mcc and total_mcc_samples else 0.0
        )

        metadata = {
            "dominant_mcc_code": dominant_mcc,
            "dominant_bank_transaction_code": dominant_bank_code,
            "dominant_merchant": dominant_merchant,
            "merchant_category": dominant_merchant_category,
            "transaction_category": dominant_txn_category,
            "mcc_consistency": mcc_consistency,
        }
        source_label = "income_event" if bool(dominant_sign >= 0.5) else "expense_event"

        label = None
        if dominant_mcc:
            label = MCC_TO_LABEL.get(str(dominant_mcc))
        if not label:
            label = _cluster_label(normalized_descriptions)

        event_profiles.append(
            {
                "cluster_id": int(cluster_id),
                "label": label,
                "mu_amount": mu_amount,
                "sigma_amount": sigma_amount,
                "mu_day": mu_day,
                "sigma_day": sigma_day,
                "frequency_days": frequency_days,
                "last_date": last_date,
                "is_income": bool(dominant_sign >= 0.5),
                "coherence": coherence,
                "sample_size": len(cluster_df),
                "descriptions": descriptions,
                "mcc_code": dominant_mcc,
                "merchant_name": dominant_merchant,
                "merchant_category": dominant_merchant_category,
                "bank_transaction_code": dominant_bank_code,
                "has_mcc": bool(dominant_mcc),
                "metadata": metadata,
                "source": source_label,
            }
        )

    noise_df = df_with_clusters[df_with_clusters["cluster_id"] == -1]
    if noise_df.empty:
        noise_profile = {"mu_daily_spend_noise": 0.0, "sigma_daily_spend_noise": 0.0}
    else:
        daily_totals = noise_df.groupby(noise_df["bookingDate"].dt.date)["amount"].sum()
        mu_noise = float(daily_totals.mean()) if not daily_totals.empty else 0.0
        sigma_noise = float(daily_totals.std(ddof=0)) if len(daily_totals) > 1 else _MIN_SIGMA_AMOUNT
        noise_profile = {
            "mu_daily_spend_noise": mu_noise,
            "sigma_daily_spend_noise": max(abs(sigma_noise), _MIN_SIGMA_AMOUNT),
        }

    return event_profiles, noise_profile


def _initial_event_schedule(event_profiles: Sequence[Dict[str, object]], start_date: date) -> List[date]:
    """Calculate the next occurrence date for each event at simulation start."""
    schedule: List[date] = []
    for event in event_profiles:
        frequency = max(int(round(event["frequency_days"])), 1)
        last_date: date = event["last_date"]
        next_date = last_date
        while next_date <= start_date:
            next_date = next_date + timedelta(days=frequency)
        schedule.append(next_date)
    return schedule


def _draw_event_amount(rng: np.random.Generator, mu: float, sigma: float) -> float:
    sigma_safe = sigma if sigma > 0 else max(abs(mu) * 0.1, _MIN_SIGMA_AMOUNT)
    return float(rng.normal(mu, sigma_safe))


def _run_monte_carlo_simulation(
    current_balance: float,
    event_profiles: Sequence[Dict[str, object]],
    noise_profile: Dict[str, float],
    horizon_days: int,
    n_simulations: int = _DEFAULT_SIMULATIONS,
    random_seed: Optional[int] = 42,
) -> np.ndarray:
    """Simulate future balance trajectories using Monte Carlo sampling."""
    horizon_days = max(int(horizon_days), 1)
    if n_simulations <= 0:
        raise ValueError("n_simulations must be positive")

    rng = np.random.default_rng(random_seed)
    trajectories = np.zeros((n_simulations, horizon_days), dtype=float)
    start_date = date.today()

    for sim_idx in range(n_simulations):
        balance = current_balance
        next_occurrences = _initial_event_schedule(event_profiles, start_date)
        for day_offset in range(horizon_days):
            current_date = start_date + timedelta(days=day_offset + 1)
            daily_delta = 0.0

            for idx, event in enumerate(event_profiles):
                if current_date < next_occurrences[idx]:
                    continue

                mu_amount = float(event["mu_amount"])
                sigma_amount = float(event["sigma_amount"])
                expected_day = float(event["mu_day"])
                sigma_day = float(event["sigma_day"])

                day_gap = abs(current_date.day - expected_day)
                trigger_probability = math.exp(-0.5 * (day_gap / sigma_day) ** 2)
                trigger_probability = min(max(trigger_probability, 0.1), 0.99)

                if rng.random() <= trigger_probability:
                    daily_delta += _draw_event_amount(rng, mu_amount, sigma_amount)
                    frequency = max(int(round(event["frequency_days"])), 1)
                    next_occurrences[idx] = current_date + timedelta(days=frequency)
                else:
                    # event skipped; revisit the next day without advancing schedule
                    pass

            mu_noise = float(noise_profile.get("mu_daily_spend_noise", 0.0))
            sigma_noise = float(noise_profile.get("sigma_daily_spend_noise", 0.0))
            if abs(mu_noise) > 1e-6 or sigma_noise > 1e-6:
                daily_delta += _draw_event_amount(rng, mu_noise, max(sigma_noise, _MIN_SIGMA_AMOUNT))

            balance += daily_delta
            trajectories[sim_idx, day_offset] = balance

    return trajectories


def _color_zone(probability_percent: float) -> Tuple[str, str]:
    """Map probability to color code and human recommendation."""
    if probability_percent >= 95:
        return "green", "Платеж почти гарантирован. Можно планировать дополнительные цели."
    if probability_percent >= 70:
        return "yellow", "Вероятность средняя: оптимизируйте расходы и держите резерв."
    return "red", "Высокий риск дефицита. Рассмотрите пополнение или перенос платежа."


def _execute_engine(
    transactions: Sequence[Transaction],
    current_balance: float,
    payment_date: date,
    payment_amount: float,
) -> Tuple[AnalysisResult, Dict[str, object]]:
    df = _prepare_transactions_df(transactions)
    if df.empty:
        result = AnalysisResult(
            payment_date=payment_date,
            payment_amount=payment_amount,
            success_probability_percent=0,
            recommendation="Недостаточно данных для анализа. Загрузите транзакции.",
            color_zone="red",
        )
        details = {
            "trajectories": np.zeros((_DEFAULT_SIMULATIONS, 1)),
            "forecast_dates": [date.today()],
            "event_profiles": [],
            "noise_profile": {"mu_daily_spend_noise": 0.0, "sigma_daily_spend_noise": _MIN_SIGMA_AMOUNT},
            "payment_index": 0,
        }
        return result, details

    df_with_clusters = _discover_events(df)
    event_profiles, noise_profile = _profile_events(df_with_clusters)

    today = date.today()
    days_until_payment = max((payment_date - today).days, 0)
    horizon_days = max(days_until_payment + 1, 30)

    trajectories = _run_monte_carlo_simulation(
        current_balance=current_balance,
        event_profiles=event_profiles,
        noise_profile=noise_profile,
        horizon_days=horizon_days,
    )

    forecast_dates = [today + timedelta(days=offset + 1) for offset in range(horizon_days)]
    payment_index = min(days_until_payment, horizon_days - 1)

    payment_balances = trajectories[:, payment_index]
    probability = float(np.mean(payment_balances >= payment_amount) * 100.0)
    probability_percent = int(round(probability))

    color_zone, recommendation = _color_zone(probability)

    analysis = AnalysisResult(
        payment_date=payment_date,
        payment_amount=payment_amount,
        success_probability_percent=probability_percent,
        recommendation=recommendation,
        color_zone=color_zone,
    )

    details = {
        "trajectories": trajectories,
        "forecast_dates": forecast_dates,
        "event_profiles": event_profiles,
        "noise_profile": noise_profile,
        "payment_index": payment_index,
    }

    return analysis, details


def run_analysis(
    transactions: Sequence[Transaction],
    current_balance: float,
    payment_date: date,
    payment_amount: float,
) -> AnalysisResult:
    """Public API returning only AnalysisResult for backward compatibility."""
    analysis, _details = _execute_engine(transactions, current_balance, payment_date, payment_amount)
    return analysis


def run_analysis_with_details(
    transactions: Sequence[Transaction],
    current_balance: float,
    payment_date: date,
    payment_amount: float,
) -> Tuple[AnalysisResult, np.ndarray, List[date], Dict[str, object], List[Dict[str, object]]]:
    """Extended API returning forecast trajectories and diagnostic profiles."""
    analysis, details = _execute_engine(transactions, current_balance, payment_date, payment_amount)
    return (
        analysis,
        details["trajectories"],
        details["forecast_dates"],
        details["noise_profile"],
        details["event_profiles"],
    )


def calculate_safe_to_spend(
    obligations: Sequence[Dict[str, object]],
    forecast_trajectories: np.ndarray,
    forecast_dates: Sequence[date],
    confidence_level: float = 0.8,
) -> float:
    """Estimate safe-to-spend amount at a chosen confidence level."""
    if forecast_trajectories.size == 0 or not forecast_dates:
        return 0.0

    confidence_level = float(np.clip(confidence_level, 0.01, 0.99))
    percentile = (1.0 - confidence_level) * 100.0
    lower_envelope = np.percentile(forecast_trajectories, percentile, axis=0)

    horizon_end = forecast_dates[-1]
    obligations_total = 0.0
    for obligation in obligations or []:
        amount = float(obligation.get("amount", 0.0) or 0.0)
        due_raw = obligation.get("due_date")
        due_date: Optional[date] = None
        if isinstance(due_raw, date):
            due_date = due_raw
        elif isinstance(due_raw, pd.Timestamp):
            due_date = due_raw.date()
        elif hasattr(due_raw, "to_pydatetime"):
            due_date = due_raw.to_pydatetime().date()
        elif isinstance(due_raw, str):
            try:
                due_date = datetime.fromisoformat(due_raw).date()
            except ValueError:
                due_date = None
        if due_date is None or due_date > horizon_end:
            continue
        obligations_total += amount

    safe_buffer = float(np.min(lower_envelope)) - obligations_total
    return max(0.0, round(safe_buffer, 2))


def rank_credits(credits: Sequence[Dict[str, object]]) -> List[Dict[str, object]]:
    """Produce a stress-based ranking for outstanding credits."""
    ranked: List[Dict[str, object]] = []
    for credit in credits or []:
        balance = float(credit.get("balance") or credit.get("principal") or 0.0)
        rate = float(credit.get("rate") or credit.get("interest_rate") or 0.0)
        min_payment = float(credit.get("min_payment") or credit.get("payment") or 0.0)
        days_past_due = float(credit.get("days_past_due") or 0.0)

        utilization = min(balance / max(credit.get("limit", balance or 1.0), 1.0), 1.0)
        stress_score = rate * 100 + min_payment / max(balance, 1.0) * 50 + days_past_due * 2 + utilization * 25

        ranked.append(
            {
                "name": credit.get("name") or credit.get("product") or "Кредит",
                "balance": round(balance, 2),
                "rate": round(rate, 4),
                "min_payment": round(min_payment, 2),
                "days_past_due": int(days_past_due),
                "stress_score": round(stress_score, 2),
            }
        )

    ranked.sort(key=lambda item: item["stress_score"], reverse=True)
    return ranked


def build_financial_portrait(
    transactions: Sequence[Transaction],
    credits: Sequence[Dict[str, Any]],
    accounts: Sequence[Dict[str, Any]],
    user_goal: UserGoal,
    balance_override: Optional[float] = None,
) -> Dict[str, Any]:
    """Compose a holistic financial portrait combining probabilistic and deterministic insights."""
    df = _prepare_transactions_df(transactions)
    if df.empty:
        return {
            "safe_to_spend_daily": 0.0,
            "credit_rankings": [],
            "discovered_events": [],
            "recurring_events": [],
            "upcoming_payments": [],
            "financial_health": {"total_debt": 0.0, "total_monthly_payments": 0.0},
            "noise_profile": {"mu_daily_spend_noise": 0.0, "sigma_daily_spend_noise": 0.0},
            "next_income_event": None,
            "error": "Недостаточно транзакций для анализа.",
        }

    df_with_clusters = _discover_events(df)
    event_profiles, noise_profile = _profile_events(df_with_clusters)

    obligations = derive_obligations(credits, event_profiles)
    if balance_override is not None:
        current_balance = balance_override
    else:
        current_balance = sum(_extract_account_balance(acc) for acc in accounts or [])
    daily_s2s = calculate_daily_s2s(current_balance, event_profiles, obligations, user_goal)

    ranked_credits = rank_credits(credits)
    next_income_event = _find_next_income_event(event_profiles, date.today())

    upcoming_payments = [
        obligation
        for obligation in obligations
        if isinstance(obligation.get("due_date"), date) and obligation["due_date"] >= date.today()
    ]
    upcoming_payments.sort(key=lambda item: item["due_date"])

    total_debt = sum(float(c.get("balance") or c.get("principal") or 0.0) for c in credits or [])
    total_monthly_payments = sum(float(obligation.get("amount") or 0.0) for obligation in obligations)

    upcoming_payments_payload = [
        {
            "name": obligation.get("label") or "Обязательный платёж",
            "amount": obligation.get("amount"),
            "due_date": obligation.get("due_date").isoformat()
            if isinstance(obligation.get("due_date"), date)
            else obligation.get("due_date"),
            "source": obligation.get("source"),
            "mcc_code": obligation.get("mcc_code"),
            "category": obligation.get("category"),
            "merchant_name": obligation.get("merchant_name"),
            "bank_transaction_code": obligation.get("bank_transaction_code"),
            "frequency_days": obligation.get("frequency_days"),
        }
        for obligation in upcoming_payments
    ]

    goal_details = user_goal.goal_details or {}
    close_loan_ids = [str(item) for item in goal_details.get("close_loan_ids") or []]
    targeted_balance = 0.0
    if close_loan_ids:
        lookup = {_credit_identifier(credit): credit for credit in credits or []}
        for loan_id in close_loan_ids:
            credit = lookup.get(str(loan_id))
            if not credit:
                continue
            targeted_balance += float(
                credit.get("outstanding_balance")
                or credit.get("balance")
                or credit.get("principal")
                or 0.0
            )
    targeted_balance = round(targeted_balance, 2) if targeted_balance else 0.0

    timeline_months = goal_details.get("timeline_months")
    expected_close_date = goal_details.get("expected_close_date")
    if not expected_close_date and timeline_months:
        try:
            months_int = int(timeline_months)
            expected_close_date = (date.today() + timedelta(days=months_int * 30)).isoformat()
        except (TypeError, ValueError):
            expected_close_date = None

    targeted_monthly_payment = goal_details.get("targeted_monthly_payment")
    if not targeted_monthly_payment and timeline_months and targeted_balance:
        try:
            targeted_monthly_payment = round(targeted_balance / max(float(timeline_months), 1.0), 2)
        except (TypeError, ValueError):
            targeted_monthly_payment = None

    if user_goal.goal_type == "pay_debts":
        target_amount = goal_details.get("targeted_loan_amount") or targeted_balance or total_debt
    else:
        target_amount = goal_details.get("save_amount") or goal_details.get("target_amount")
    if target_amount is not None:
        try:
            target_amount = round(float(target_amount), 2)
        except (TypeError, ValueError):
            target_amount = None

    goal_summary = {
        "type": user_goal.goal_type,
        "pace": user_goal.pace,
        "speed": goal_details.get("close_speed") or goal_details.get("save_speed") or user_goal.pace,
        "target_amount": target_amount,
        "close_loan_ids": close_loan_ids,
        "targeted_balance": targeted_balance or None,
        "timeline_months": timeline_months,
        "expected_close_date": expected_close_date,
        "recommended_monthly_payment": targeted_monthly_payment,
    }

    return {
        "safe_to_spend_daily": daily_s2s,
        "current_balance": round(current_balance, 2),
        "credit_rankings": ranked_credits,
        "discovered_events": event_profiles,
        "upcoming_payments": upcoming_payments_payload,
        "timeline": upcoming_payments_payload,
        "financial_health": {
            "total_debt": round(total_debt, 2),
            "total_monthly_payments": round(total_monthly_payments, 2),
        },
        "recurring_events": extract_recurring_events(event_profiles),
        "noise_profile": noise_profile,
        "next_income_event": next_income_event,
        "goal_summary": goal_summary,
    }
</file>

<file path="core/data_models.py">
"""Data models for the hackathon project core."""
from __future__ import annotations

from datetime import date
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field


class Transaction(BaseModel):
    """Represents a single bank transaction with optional merchant context."""

    transactionId: str
    amount: float
    currency: str
    description: Optional[str] = None
    bookingDate: date
    creditDebitIndicator: Optional[str] = None
    bankTransactionCode: Optional[str] = None
    merchant: Dict[str, Optional[str]] = Field(default_factory=dict)
    mccCode: Optional[str] = None
    category: Optional[str] = None
    transactionInformation: Optional[str] = None
    transactionLocation: Dict[str, Any] = Field(default_factory=dict)
    card: Dict[str, Optional[str]] = Field(default_factory=dict)


class Account(BaseModel):
    """Represents a user's account."""

    accountId: str
    nickname: Optional[str] = None
    # Extend with additional fields once API contract is finalized.


class BankConsent(BaseModel):
    """Stores consent metadata for a bank."""

    bank_id: str
    consent_id: str


class AnalysisResult(BaseModel):
    """Outcome structure returned by analytics engine."""

    payment_date: date
    payment_amount: float
    success_probability_percent: int
    recommendation: str
    color_zone: str = Field(description="green, yellow, or red")
</file>

<file path="core/database.py">
import json
import logging
import sqlite3
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

DB_FILE = "finpulse_consents.db"
logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class StoredConsent:
    """Lightweight view of a consent record used by service layers."""

    bank_id: str
    consent_id: str
    consent_type: str = "accounts"


def get_db_connection() -> sqlite3.Connection:
    """Open a connection to the consent state database."""
    conn = sqlite3.connect(DB_FILE)
    conn.row_factory = sqlite3.Row
    return conn


def _ensure_column(conn: sqlite3.Connection, table: str, column: str, definition: str) -> None:
    """Ensure the given column exists on the table, adding it if necessary."""
    cursor = conn.execute(f"PRAGMA table_info({table})")
    columns = {row[1] for row in cursor.fetchall()}
    if column not in columns:
        logger.info("Adding column %s to table %s", column, table)
        conn.execute(f"ALTER TABLE {table} ADD COLUMN {column} {definition};")


def init_db() -> None:
    """Create all required tables for the application if they are absent."""
    try:
        with get_db_connection() as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS consents (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    bank_id TEXT NOT NULL,
                    consent_id TEXT NOT NULL UNIQUE,
                    status TEXT NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                """
            )
            _ensure_column(conn, "consents", "request_id", "TEXT")
            _ensure_column(conn, "consents", "approval_url", "TEXT")
            _ensure_column(conn, "consents", "consent_type", "TEXT")
            # Backfill consent type for legacy rows.
            conn.execute(
                """
                UPDATE consents
                SET bank_id = substr(bank_id, 1, length(bank_id) - 9),
                    consent_type = COALESCE(consent_type, 'products')
                WHERE bank_id LIKE '%\_products' ESCAPE '\\'
                """
            )
            conn.execute(
                """
                UPDATE consents
                SET consent_type = COALESCE(consent_type, 'accounts')
                WHERE consent_type IS NULL
                """
            )
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS user_profiles (
                    user_id TEXT PRIMARY KEY,
                    goal_type TEXT,
                    goal_details TEXT
                );
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS user_product_consents (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    bank_id TEXT NOT NULL,
                    product_id TEXT NOT NULL,
                    product_type TEXT,
                    consented BOOLEAN NOT NULL,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    UNIQUE(user_id, bank_id, product_id)
                );
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS bank_status_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    bank_id TEXT NOT NULL,
                    operation TEXT NOT NULL,
                    status TEXT NOT NULL,
                    message TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS onboarding_sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id TEXT NOT NULL,
                    banks_connected TEXT,
                    products_consented TEXT,
                    goal_profile TEXT,
                    completed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
                """
            )
            conn.commit()
        logger.info("All database tables ensured.")
    except sqlite3.Error as exc:
        logger.error("Database initialization failed: %s", exc)
        raise


def save_consent(
    user_id: str,
    bank_id: str,
    consent_id: str,
    status: str,
    request_id: Optional[str] = None,
    approval_url: Optional[str] = None,
    consent_type: str = "accounts",
) -> None:
    """Persist or update a consent record."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO consents (user_id, bank_id, consent_id, status, request_id, approval_url, consent_type)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            ON CONFLICT(consent_id) DO UPDATE SET
                status=excluded.status,
                user_id=excluded.user_id,
                bank_id=excluded.bank_id,
                request_id=COALESCE(excluded.request_id, consents.request_id),
                approval_url=COALESCE(excluded.approval_url, consents.approval_url),
                consent_type=COALESCE(excluded.consent_type, consents.consent_type)
            """,
            (user_id, bank_id, consent_id, status, request_id, approval_url, consent_type),
        )
        conn.commit()


def update_consent_status(consent_id: str, status: str) -> bool:
    """Set consent status; returns True if a row was updated."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "UPDATE consents SET status = ? WHERE consent_id = ?",
            (status, consent_id),
        )
        conn.commit()
        return cursor.rowcount > 0


def update_consent_from_request(request_id: str, consent_id: str, status: str) -> bool:
    """Update a pending consent row once the real consent_id becomes available."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            """
            UPDATE consents
            SET consent_id = ?, status = ?
            WHERE request_id = ?
            """,
            (consent_id, status, request_id),
        )
        conn.commit()
        return cursor.rowcount > 0


def get_consent_by_request_id(request_id: str) -> Optional[Dict[str, Any]]:
    """Return consent row by request_id if it exists."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "SELECT * FROM consents WHERE request_id = ?",
            (request_id,),
        )
        row = cursor.fetchone()
    return dict(row) if row else None


def find_approved_consents(user_id: str, consent_type: Optional[str] = None) -> List[StoredConsent]:
    """Return structured consents filtered by approval status (and optionally type)."""
    with get_db_connection() as conn:
        sql = "SELECT bank_id, consent_id, consent_type FROM consents WHERE user_id = ? AND status = 'APPROVED'"
        params: List[Any] = [user_id]
        if consent_type:
            sql += " AND consent_type = ?"
            params.append(consent_type)
        cursor = conn.execute(sql, params)
        rows = cursor.fetchall()
    return [
        StoredConsent(
            bank_id=row["bank_id"],
            consent_id=row["consent_id"],
            consent_type=row["consent_type"] or "accounts",
        )
        for row in rows
    ]


def upsert_product_consents(user_id: str, items: List[Dict[str, Any]]) -> None:
    """Upsert multiple product consent records for a user."""
    if not items:
        return
    with get_db_connection() as conn:
        cursor = conn.cursor()
        for item in items:
            cursor.execute(
                """
                INSERT INTO user_product_consents (user_id, bank_id, product_id, product_type, consented, updated_at)
                VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
                ON CONFLICT(user_id, bank_id, product_id) DO UPDATE SET
                    consented = excluded.consented,
                    product_type = excluded.product_type,
                    updated_at = CURRENT_TIMESTAMP;
                """,
                (
                    user_id,
                    item["bank_id"],
                    item["product_id"],
                    item.get("product_type"),
                    bool(item["consented"]),
                ),
            )
        conn.commit()
    logger.info("Upserted %d product consents for user %s", len(items), user_id)


def get_product_consents_for_user(user_id: str) -> List[Dict[str, Any]]:
    """Fetch all product consents for a given user."""
    with get_db_connection() as conn:
        cursor = conn.execute("SELECT * FROM user_product_consents WHERE user_id = ?", (user_id,))
        rows = cursor.fetchall()
    return [dict(row) for row in rows]


def get_user_consents(user_id: str) -> List[Dict[str, Any]]:
    """Return all stored consents (any status) for the user."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "SELECT bank_id, consent_id, status, request_id, approval_url, created_at, consent_type FROM consents WHERE user_id = ?",
            (user_id,),
        )
        rows = cursor.fetchall()
    return [dict(row) for row in rows]


def add_bank_status_log(user_id: str, bank_id: str, operation: str, status: str, message: str) -> None:
    """Log the status of a bank operation."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO bank_status_log (user_id, bank_id, operation, status, message)
            VALUES (?, ?, ?, ?, ?);
            """,
            (user_id, bank_id, operation, status, message),
        )
        conn.commit()


def get_recent_bank_status_logs(user_id: str, limit: int = 10) -> List[Dict[str, Any]]:
    """Fetch recent bank operation logs for a user."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "SELECT * FROM bank_status_log WHERE user_id = ? ORDER BY timestamp DESC LIMIT ?",
            (user_id, limit),
        )
        rows = cursor.fetchall()
    return [dict(row) for row in rows]


def commit_onboarding_session(user_id: str, banks: List[str], products: List[Dict[str, Any]], goal: Dict[str, Any]) -> None:
    """Save a summary of the completed onboarding session."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO onboarding_sessions (user_id, banks_connected, products_consented, goal_profile)
            VALUES (?, ?, ?, ?);
            """,
            (user_id, json.dumps(banks), json.dumps(products), json.dumps(goal)),
        )
        conn.commit()
    logger.info("Committed onboarding session for user %s", user_id)


def get_latest_onboarding_session(user_id: str) -> Optional[Dict[str, Any]]:
    """Return the most recent onboarding session snapshot if it exists."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            """
            SELECT user_id, banks_connected, products_consented, goal_profile, completed_at
            FROM onboarding_sessions
            WHERE user_id = ?
            ORDER BY completed_at DESC
            LIMIT 1;
            """,
            (user_id,),
        )
        row = cursor.fetchone()

    if not row:
        return None

    def _safe_parse(value: Optional[str], default: Any) -> Any:
        if not value:
            return default
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return default

    return {
        "user_id": row["user_id"],
        "banks_connected": _safe_parse(row["banks_connected"], []),
        "products_consented": _safe_parse(row["products_consented"], []),
        "goal_profile": _safe_parse(row["goal_profile"], {}),
        "completed_at": row["completed_at"],
    }


def get_user_goal(user_id: str) -> Optional[Dict[str, Any]]:
    """Fetch the last saved user goal."""
    with get_db_connection() as conn:
        cursor = conn.execute(
            "SELECT goal_type, goal_details FROM user_profiles WHERE user_id = ?",
            (user_id,),
        )
        row = cursor.fetchone()
    if not row:
        return None
    goal_details = json.loads(row["goal_details"]) if row["goal_details"] else {}
    return {"goal_type": row["goal_type"], "goal_details": goal_details}


def save_user_profile(user_id: str, goal_type: str, goal_details: Dict[str, Any]) -> None:
    """Upsert the user's selected goal details."""
    with get_db_connection() as conn:
        conn.execute(
            """
            INSERT INTO user_profiles (user_id, goal_type, goal_details)
            VALUES (?, ?, ?)
            ON CONFLICT(user_id) DO UPDATE SET
                goal_type = excluded.goal_type,
                goal_details = excluded.goal_details
            """,
            (user_id, goal_type, json.dumps(goal_details)),
        )
        conn.commit()
    logger.info("Saved profile for user %s (goal=%s)", user_id, goal_type)
</file>

<file path="core/obr_client.py">
import asyncio
import json
import logging
import uuid
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional
from urllib.parse import urljoin

import httpx
import jwt
from tenacity import retry, retry_if_exception, stop_after_attempt, wait_exponential

from .data_models import Transaction

logger = logging.getLogger(__name__)
DEFAULT_TIMEOUT = httpx.Timeout(20.0, connect=5.0)

# Определяем, какие ошибки считать временными для повторов
RETRYABLE_EXCEPTIONS = (
    httpx.TimeoutException,
    httpx.ConnectError,
    httpx.NetworkError,
)


def _is_retryable(exc: BaseException) -> bool:
    """Retry only on transport errors and HTTP 5xx per API docs."""
    if isinstance(exc, httpx.HTTPStatusError):
        return exc.response.status_code >= 500
    return isinstance(exc, RETRYABLE_EXCEPTIONS)


# Создаем декоратор retry с правильными настройками
api_retry = retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=1, max=5),
    retry=retry_if_exception(_is_retryable),
)

AUTHORIZED_CONSENT_STATUSES = {"Authorized", "AuthorizedConsent", "Active", "Approved"}
PENDING_CONSENT_STATUSES = {"AwaitingAuthorization", "Pending", "AwaitingApproval"}
FAILED_CONSENT_STATUSES = {"Rejected", "Expired", "Revoked", "Cancelled"}
_AUTHORIZED_STATUS_SET = {item.lower() for item in AUTHORIZED_CONSENT_STATUSES}
_FAILED_STATUS_SET = {item.lower() for item in FAILED_CONSENT_STATUSES}
RSA_JWT_ALGS = {"RS256", "RS384", "RS512"}


def _normalize_status_value(value: Any) -> str:
    if value is None:
        return ""
    return str(value).strip()


@dataclass
class ConsentInitResult:
    consent_id: Optional[str]
    status: str
    auto_approved: bool
    approval_url: Optional[str] = None
    request_id: Optional[str] = None

    @property
    def requires_manual_action(self) -> bool:
        return not self.auto_approved and self.status not in AUTHORIZED_CONSENT_STATUSES


class OBRAPIClient:
    """Implements the multi-step OBR consent flow."""

    def __init__(self, api_base_url: str, team_client_id: str, team_client_secret: str):
        if not all([api_base_url, team_client_id, team_client_secret]):
            raise ValueError("api_base_url, team_client_id, and team_client_secret are required.")

        self.api_base_url = api_base_url.rstrip("/")
        self.team_id = team_client_id
        self.team_secret = team_client_secret
        self._client = httpx.AsyncClient(base_url=self.api_base_url, timeout=DEFAULT_TIMEOUT)
        self._bank_token: Optional[str] = None
        self._token_expires_at: Optional[datetime] = None
        self._jwks_keys: Optional[List[Dict[str, Any]]] = None
        self._token_lock = asyncio.Lock()

    async def _get_common_headers(self, bank_token: str) -> Dict[str, str]:
        """Header block shared by most outbound calls."""
        return {
            "Authorization": f"Bearer {bank_token}",
            "X-Requesting-Bank": self.team_id,
            "x-fapi-interaction-id": str(uuid.uuid4()),
        }

    @api_retry
    async def _get_jwks_keys(self) -> List[Dict[str, Any]]:
        if self._jwks_keys:
            return self._jwks_keys

        logger.info("Fetching JWKS from %s/.well-known/jwks.json", self.api_base_url)
        response = await self._client.get("/.well-known/jwks.json")
        response.raise_for_status()
        self._jwks_keys = response.json().get("keys", [])
        if not self._jwks_keys:
            raise ValueError("JWKS endpoint did not return any keys.")
        return self._jwks_keys

    def invalidate_jwks_cache(self) -> None:
        """Allow callers to force JWKS refresh (e.g., after key rotation)."""
        self._jwks_keys = None

    async def _validate_jwt(self, token: str) -> Dict[str, Any]:
        """
        Decode JWT payload and verify signature when the bank provides an RSA key.
        Some sandbox banks issue HS256 tokens without a shared secret in docs, so we
        fall back to skipping signature verification in that case.
        """
        try:
            unverified_header = jwt.get_unverified_header(token)
            alg = unverified_header.get("alg", "RS256")
            options = {"verify_aud": False}
            key: Optional[Any] = None

            if alg in RSA_JWT_ALGS:
                kid = unverified_header.get("kid")
                if not kid:
                    raise jwt.InvalidTokenError("JWT header is missing required 'kid' for RSA algorithms.")

                jwks_keys = await self._get_jwks_keys()
                if not jwks_keys:
                    raise jwt.InvalidTokenError("No keys found in JWKS endpoint.")

                key_data: Optional[Dict[str, Any]] = next(
                    (jwks_key for jwks_key in jwks_keys if jwks_key.get("kid") == kid),
                    None,
                )
                if key_data is None:
                    raise jwt.InvalidTokenError(f"Unknown 'kid' {kid} in JWT header.")

                public_key = jwt.algorithms.RSAAlgorithm.from_jwk(json.dumps(key_data))
                key = public_key
                options["verify_signature"] = True
            else:
                options["verify_signature"] = False
                logger.warning(
                    "Bank %s issued JWT with unsupported alg '%s'; skipping signature verification.",
                    self.api_base_url,
                    alg,
                )

            payload = jwt.decode(
                token,
                key,
                algorithms=[alg] if options.get("verify_signature") else None,
                options=options,
            )
            return payload
        except jwt.PyJWTError as exc:
            logger.error("JWT validation failed: %s", exc)
            raise

    async def _get_bank_token(self) -> str:
        async with self._token_lock:
            if self._bank_token and self._token_expires_at and datetime.now(timezone.utc) < self._token_expires_at:
                return self._bank_token

            logger.info("Requesting new bank token from %s", self.api_base_url)

            @api_retry
            async def _fetch_token_with_retry():
                response = await self._client.post(
                    "/auth/bank-token",
                    params={"client_id": self.team_id, "client_secret": self.team_secret},
                )
                response.raise_for_status()
                return response.json()

            token_data = await _fetch_token_with_retry()
            access_token = token_data["access_token"]

            payload = await self._validate_jwt(access_token)
            self._bank_token = access_token
            
            expires_at_timestamp = payload.get("exp", 0)
            self._token_expires_at = datetime.fromtimestamp(expires_at_timestamp, tz=timezone.utc) - timedelta(minutes=1)

            logger.info("Successfully obtained and validated new bank token.")
            return self._bank_token

    # !!! УБРАЛИ @retry ОТСЮДА !!!
    async def initiate_consent(self, user_id: str) -> ConsentInitResult:
        """
        Step 1: Create an account access consent request at the bank.
        Returns metadata about the consent, including approval URL when provided.
        """
        bank_token = await self._get_bank_token()
        headers = await self._get_common_headers(bank_token)
        body = {
            "client_id": user_id,
            "permissions": ["ReadAccountsDetail", "ReadBalances", "ReadTransactionsDetail"],
            "reason": "Financial analysis for FinPulse Hackathon",
            "requesting_bank": self.team_id,
            "requesting_bank_name": f"{self.team_id} App",
            "redirect_uri": "http://localhost:5173/callback",
        }

        logger.info("Initiating consent for user '%s' at %s", user_id, self.api_base_url)
        
        @api_retry
        async def _post_consent_request():
            response = await self._client.post("/account-consents/request", headers=headers, json=body)
            response.raise_for_status()
            return response.json()

        response_data = await _post_consent_request()

        data_section = response_data.get("data") if isinstance(response_data, dict) else {}
        if not isinstance(data_section, dict):
            data_section = {}

        consent_id = (
            data_section.get("consentId")
            or data_section.get("consent_id")
            or (response_data.get("consentId") if isinstance(response_data, dict) else None)
            or (response_data.get("consent_id") if isinstance(response_data, dict) else None)
        )
        request_id = (
            data_section.get("requestId")
            or data_section.get("request_id")
            or (response_data.get("request_id") if isinstance(response_data, dict) else None)
            or (response_data.get("requestId") if isinstance(response_data, dict) else None)
        )

        approval_url = (
            response_data.get("links", {}).get("consentApproval")
            or response_data.get("links", {}).get("consentApprovalUrl")
            or response_data.get("links", {}).get("approvalUrl")
            or response_data.get("approvalUrl")
            or response_data.get("approval_url")
        )

        status = (
            data_section.get("status")
            or response_data.get("status") if isinstance(response_data, dict) else None
            or ("Authorized" if response_data.get("auto_approved") else "AwaitingAuthorization")
        )
        auto_approved = bool(
            response_data.get("auto_approved")
            or data_section.get("autoApproved")
            or (status in AUTHORIZED_CONSENT_STATUSES)
        )

        if not consent_id and not request_id:
            raise ValueError("API did not return a consent or request identifier.")

        if not approval_url and auto_approved:
            logger.info(
                "Consent %s appears auto-approved at %s (no approval URL).",
                consent_id,
                self.api_base_url,
            )

        logger.info(
            "Consent initiated with consent_id=%s request_id=%s (status=%s)",
            consent_id,
            request_id,
            status,
        )
        return ConsentInitResult(
            consent_id=consent_id,
            approval_url=approval_url,
            status=status,
            auto_approved=auto_approved,
            request_id=request_id,
        )

    async def initiate_product_consent(
        self, user_id: str, user_display_name: Optional[str] = None
    ) -> Optional[ConsentInitResult]:
        """Tries multiple payloads to create a product agreement consent, inspired by hndmd.py."""
        bank_token = await self._get_bank_token()
        headers = await self._get_common_headers(bank_token)
        url = "/product-agreement-consents/request"

        valid_until = (
            datetime.now(timezone.utc) + timedelta(days=365)
        ).replace(microsecond=0).isoformat().replace("+00:00", "Z")

        base_payload = {
            "requesting_bank": self.team_id,
            "requesting_bank_name": f"{self.team_id} App",
            "client_id": user_id,
            "reason": "CreditGuard: credit analysis",
            "customer_name": user_display_name or user_id,
        }

        payloads_to_try = [
            {
                **base_payload,
                "read_product_agreements": True,
                "open_product_agreements": False,
                "close_product_agreements": False,
                "allowed_product_types": ["deposit", "loan", "credit_card"],
                "max_amount": 5_000_000,
                "valid_until": valid_until,
            },
            {
                **base_payload,
                "permissions": ["ReadProductAgreements"],
            },
            {
                **base_payload,
                "read_product_agreements": True,
            },
        ]

        for body in payloads_to_try:
            try:
                response = await self._client.post(
                    url,
                    headers=headers,
                    params={"client_id": user_id},
                    json=body,
                )
                if response.status_code >= 400:
                    logger.warning("Payload failed with status %s: %s", response.status_code, body)
                    continue

                data = response.json()
                consent_id = data.get("consent_id") or self._jget(data, ["data", "consentId"])
                request_id = data.get("request_id") or self._jget(data, ["data", "requestId"])
                status_raw = data.get("status") or self._jget(data, ["data", "status"])
                approval_url = self._jget(data, ["links", "consentApproval"])

                # SBank может вернуть request_id вместо consent_id
                final_id = consent_id or request_id
                if final_id:
                    normalized_status = _normalize_status_value(status_raw).lower()
                    auto_approved = bool(
                        data.get("auto_approved")
                        or (normalized_status and normalized_status in _AUTHORIZED_STATUS_SET)
                    )
                    if not auto_approved and not approval_url and normalized_status not in _FAILED_STATUS_SET:
                        auto_approved = True
                        status_raw = "Approved"

                    status_value = status_raw or ("Approved" if auto_approved else "Pending")

                    logger.info("Product consent initiated successfully with payload: %s", body)
                    return ConsentInitResult(
                        consent_id=final_id,
                        status=status_value,
                        auto_approved=auto_approved,
                        approval_url=approval_url,
                        request_id=request_id,
                    )
            except httpx.RequestError as e:  # noqa: PERF203
                logger.warning("Request failed for product consent payload %s: %s", body, e)

        logger.error("All attempts to create product consent failed for user %s at %s", user_id, self.api_base_url)
        return None

    @api_retry
    async def get_consent_details(self, consent_id: str) -> Dict[str, Any]:
        """Fetch consent status from /account-consents/{consent_id}."""
        response = await self._client.get(f"/account-consents/{consent_id}")
        response.raise_for_status()
        return response.json()

    @api_retry
    async def get_consent_status_by_request_id(self, request_id: str) -> Dict[str, Any]:
        """Fetch consent status when only request_id is available."""
        bank_token = await self._get_bank_token()
        headers = await self._get_common_headers(bank_token)
        response = await self._client.get(f"/account-consents/{request_id}", headers=headers)
        response.raise_for_status()
        return response.json()

    async def wait_for_consent_authorization(
        self,
        consent_id: str,
        timeout_seconds: float = 300,
        poll_interval_seconds: float = 5,
    ) -> str:
        """Poll consent status until it becomes authorized or fails."""
        logger.info("Waiting for consent %s to be authorized...", consent_id)
        deadline = asyncio.get_running_loop().time() + timeout_seconds

        while True:
            consent_payload = await self.get_consent_details(consent_id)
            data_section = consent_payload.get("data", {}) if isinstance(consent_payload, dict) else {}
            status = data_section.get("status") or consent_payload.get("status") or "unknown"

            if status in AUTHORIZED_CONSENT_STATUSES:
                logger.info("Consent %s authorized with status %s.", consent_id, status)
                return status
            if status in FAILED_CONSENT_STATUSES:
                raise RuntimeError(f"Consent {consent_id} failed with status '{status}'.")

            if asyncio.get_running_loop().time() >= deadline:
                raise TimeoutError(f"Timed out waiting for consent {consent_id} authorization (last status {status}).")

            await asyncio.sleep(poll_interval_seconds)

    async def fetch_transactions_with_consent(self, user_id: str, consent_id: str) -> List[Transaction]:
        """
        Step 2: Retrieve transactions for the user using an approved consent.
        """
        bank_token = await self._get_bank_token()
        base_headers = await self._get_common_headers(bank_token)

        logger.info("Fetching accounts for user '%s' with consent '%s'", user_id, consent_id)
        headers = {**base_headers, "X-Consent-Id": consent_id}
        
        @api_retry
        async def _get_accounts():
            acc_response = await self._client.get(f"/accounts?client_id={user_id}", headers=headers)
            acc_response.raise_for_status()
            return acc_response.json()

        accounts_data = await _get_accounts()
        accounts = self._extract_accounts(accounts_data)

        all_transactions: List[Transaction] = []
        for account in accounts:
            account_id = self._extract_account_id(account)
            if not account_id:
                continue

            next_page_url: Optional[str] = f"/accounts/{account_id}/transactions?client_id={user_id}"
            page_num = 1
            while next_page_url:
                logger.info(
                    "Fetching transactions for account '%s', page %d (next=%s)",
                    account_id,
                    page_num,
                    next_page_url,
                )
                paginated_headers = {**headers, "x-fapi-interaction-id": str(uuid.uuid4())}

                @api_retry
                async def _get_transactions_page(url):
                    tx_response = await self._client.get(url, headers=paginated_headers)
                    tx_response.raise_for_status()
                    return tx_response.json()
                
                response_data = await _get_transactions_page(next_page_url)

                raw_txs = self._extract_transactions(response_data)

                for raw in raw_txs:
                    tx_model = self._to_transaction_model(raw)
                    if tx_model:
                        all_transactions.append(tx_model)
                    else:
                        logger.warning("Failed to normalize transaction payload: %s", raw)

                next_page_url = self._extract_next_link(response_data)
                logger.info(
                    "Pagination checkpoint account=%s page=%d next=%s",
                    account_id,
                    page_num,
                    next_page_url,
                )
                page_num += 1

        logger.info("Fetched %d transactions for user '%s' from %s", len(all_transactions), user_id, self.api_base_url)
        return all_transactions

    async def close(self) -> None:
        """Dispose the underlying HTTP client."""
        await self._client.aclose()

    async def fetch_accounts_with_consent(self, user_id: str, consent_id: str) -> List[Dict[str, Any]]:
        """Fetch accounts list for the user with the granted consent."""
        bank_token = await self._get_bank_token()
        headers = {**(await self._get_common_headers(bank_token)), "X-Consent-Id": consent_id}

        logger.info("Fetching accounts overview for user '%s' (consent %s)", user_id, consent_id)

        @api_retry
        async def _get_accounts():
            response = await self._client.get(f"/accounts?client_id={user_id}", headers=headers)
            response.raise_for_status()
            return response.json()

        payload = await _get_accounts()
        accounts = self._extract_accounts(payload)
        logger.info("Retrieved %d accounts for user '%s' from %s", len(accounts), user_id, self.api_base_url)
        return accounts

    async def fetch_balances_with_consent(self, user_id: str, consent_id: str) -> Dict[str, Any]:
        """Fetch balance totals for the user with the granted consent."""
        bank_token = await self._get_bank_token()
        base_headers = await self._get_common_headers(bank_token)

        logger.info("Fetching balances for user '%s' (consent %s)", user_id, consent_id)

        async def _accounts_headers() -> Dict[str, str]:
            headers = {**base_headers, "x-fapi-interaction-id": str(uuid.uuid4())}
            headers["X-Consent-Id"] = consent_id
            return headers

        @api_retry
        async def _get_accounts():
            response = await self._client.get(f"/accounts?client_id={user_id}", headers=await _accounts_headers())
            response.raise_for_status()
            return response.json()

        accounts_payload = await _get_accounts()
        accounts = self._extract_accounts(accounts_payload)

        all_balance_entries: List[Dict[str, Any]] = []
        for account in accounts:
            account_id = self._extract_account_id(account)
            if not account_id:
                continue

            url = f"/accounts/{account_id}/balances"

            @api_retry
            async def _get_account_balances():
                response = await self._client.get(url, headers=await _accounts_headers())
                response.raise_for_status()
                return response.json()

            balance_payload = await _get_account_balances()
            entries = self._jget(balance_payload, ["data", "Balance"], [])
            if not entries:
                logger.warning("No balance entries found for account %s at %s", account_id, self.api_base_url)
                continue

            for entry in entries:
                if isinstance(entry, dict):
                    entry.setdefault("accountId", account_id)
                    all_balance_entries.append(entry)

        logger.info(
            "Retrieved %d balance entries for user '%s' from %s",
            len(all_balance_entries),
            user_id,
            self.api_base_url,
        )
        return {"balances": all_balance_entries}

    async def fetch_credits_with_consent(self, user_id: str, consent_id: str) -> List[Dict[str, Any]]:
        """
        Fetches credit agreements using multiple header variations and pagination,
        inspired by hndmd.py.
        """
        if not consent_id:
            logger.warning("fetch_credits_with_consent called without consent_id for user %s", user_id)
            return []

        bank_token = await self._get_bank_token()
        common_headers = await self._get_common_headers(bank_token)
        params: Dict[str, Any] = {"client_id": user_id}

        urls_to_try = ["/credits", "/product-agreements"]

        headers_variations = [
            {"X-Product-Agreement-Consent-Id": consent_id},
            {"x-product-agreement-consent-id": consent_id},
            {"X-Consent-Id": consent_id},
        ]

        for url in urls_to_try:
            for header_variant in headers_variations:
                headers = {**common_headers, **header_variant}
                try:
                    response = await self._client.get(url, headers=headers, params=params)
                    if response.status_code in (400, 401, 403, 404):
                        logger.warning(
                            "Request to %s failed with status %s using header %s",
                            url,
                            response.status_code,
                            list(header_variant.keys())[0],
                        )
                        continue

                    response.raise_for_status()

                    all_agreements = await self._paginate(response, headers, params)
                    credits = [ag for ag in all_agreements if self._is_credit(ag)]

                    logger.info(
                        "Successfully fetched %d credits from %s using header %s",
                        len(credits),
                        url,
                        list(header_variant.keys())[0],
                    )
                    return credits
                except httpx.RequestError as e:
                    logger.error("Network error while fetching from %s: %s", url, e)
                    raise

        logger.error("All attempts to fetch credits/agreements failed for consent %s.", consent_id)
        return []

    async def _paginate(self, first_response: httpx.Response, headers: Dict[str, str], params: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Paginates through API results using the 'next' link."""
        body = first_response.json()
        items = self._extract_agreements(body) or self._extract_accounts(body)
        items = list(items) if items else []

        next_url = self._extract_next_link(body)
        while next_url:
            paginated_params = {k: v for k, v in (params or {}).items() if f"{k}=" not in next_url}

            response = await self._client.get(next_url, headers=headers, params=paginated_params or None)
            if response.status_code != 200:
                logger.warning("Pagination failed at URL %s with status %s", next_url, response.status_code)
                break

            body = response.json()
            items.extend(self._extract_agreements(body) or self._extract_accounts(body))
            next_url = self._extract_next_link(body)

        return items

    @staticmethod
    def _jget(d: Dict[str, Any], path: List[str], default: Any = None) -> Any:
        cur = d
        for p in path:
            if isinstance(cur, dict) and p in cur:
                cur = cur[p]
            else:
                return default
        return cur

    @staticmethod
    def _is_credit(agreement: Dict[str, Any]) -> bool:
        """Checks if a product agreement is a credit product."""
        prod_type = (agreement.get("product_type") or "").lower()
        name = (agreement.get("product_name") or "").lower()
        return "credit" in prod_type or "loan" in prod_type or "кредит" in name

    @staticmethod
    def _extract_accounts(payload: Any) -> List[Dict[str, Any]]:
        if isinstance(payload, dict):
            if isinstance(payload.get("accounts"), list):
                return payload["accounts"]
            data = payload.get("data")
            if isinstance(data, dict):
                if isinstance(data.get("accounts"), list):
                    return data["accounts"]
                if isinstance(data.get("account"), list):
                    return data["account"]
        return []

    @staticmethod
    def _extract_transactions(payload: Any) -> List[Dict[str, Any]]:
        if isinstance(payload, dict):
            if isinstance(payload.get("transactions"), list):
                return payload["transactions"]
            data = payload.get("data")
            if isinstance(data, dict):
                if isinstance(data.get("transactions"), list):
                    return data["transactions"]
                if isinstance(data.get("transaction"), list):
                    return data["transaction"]
        return []

    @staticmethod
    def _extract_agreements(payload: Any) -> List[Dict[str, Any]]:
        if isinstance(payload, dict):
            if isinstance(payload.get("agreements"), list):
                return payload["agreements"]
            if isinstance(payload.get("items"), list):
                return payload["items"]
            if isinstance(payload.get("credits"), list):
                return payload["credits"]
            data = payload.get("data")
            if isinstance(data, dict):
                if isinstance(data.get("agreements"), list):
                    return data["agreements"]
                if isinstance(data.get("credits"), list):
                    return data["credits"]
        return []

    @staticmethod
    def _extract_balance_entries(payload: Any) -> List[Dict[str, Any]]:
        if isinstance(payload, list):
            return [entry for entry in payload if isinstance(entry, dict)]
        if not isinstance(payload, dict):
            return []

        for candidate in ("balances", "items", "accountBalances", "account_balances"):
            section = payload.get(candidate)
            if isinstance(section, list):
                return [entry for entry in section if isinstance(entry, dict)]

        nested_data = payload.get("data")
        if isinstance(nested_data, dict):
            for candidate in ("balances", "accountBalances", "account_balances"):
                section = nested_data.get(candidate)
                if isinstance(section, list):
                    return [entry for entry in section if isinstance(entry, dict)]
        return []

    def _extract_next_link(self, payload: Any) -> Optional[str]:
        if not isinstance(payload, dict):
            return None

        next_url = (
            self._jget(payload, ["links", "next"])
            or self._jget(payload, ["Links", "next"])
            or self._jget(payload, ["data", "links", "next"])
        )

        if not next_url:
            return None

        # Поддержка относительных и абсолютных URL
        return urljoin(self.api_base_url + "/", str(next_url))

    @staticmethod
    def _extract_account_id(account_payload: Any) -> Optional[str]:
        if not isinstance(account_payload, dict):
            return None
        for key in ("accountId", "account_id", "id"):
            value = account_payload.get(key)
            if value:
                return str(value)
        return None

    @staticmethod
    def _parse_booking_datetime(raw_value: Any) -> Optional[datetime]:
        if not isinstance(raw_value, str):
            return None

        value = raw_value.strip()
        if not value:
            return None

        try:
            if value.endswith("Z"):
                value = value.replace("Z", "+00:00")
            return datetime.fromisoformat(value)
        except ValueError:
            try:
                return datetime.fromisoformat(value + "+00:00")
            except ValueError:
                return None

    @staticmethod
    def _safe_str(value: Any) -> Optional[str]:
        if value is None:
            return None
        text = str(value).strip()
        return text or None

    @staticmethod
    def _normalize_merchant_payload(raw: Any) -> Dict[str, Optional[str]]:
        if not isinstance(raw, dict):
            return {}
        merchant = {
            "merchantId": OBRAPIClient._safe_str(
                raw.get("merchantId") or raw.get("id") or raw.get("merchant_id")
            ),
            "name": OBRAPIClient._safe_str(raw.get("name")),
            "mccCode": OBRAPIClient._safe_str(raw.get("mccCode") or raw.get("mcc")),
            "category": OBRAPIClient._safe_str(raw.get("category")),
            "city": OBRAPIClient._safe_str(raw.get("city")),
            "country": OBRAPIClient._safe_str(raw.get("country")),
            "address": OBRAPIClient._safe_str(raw.get("address") or raw.get("street")),
        }
        return {key: value for key, value in merchant.items() if value}

    @staticmethod
    def _normalize_card_payload(raw: Any) -> Dict[str, Optional[str]]:
        if not isinstance(raw, dict):
            return {}
        card = {
            "maskedPan": OBRAPIClient._safe_str(raw.get("maskedPan") or raw.get("masked_pan")),
            "type": OBRAPIClient._safe_str(raw.get("type") or raw.get("scheme")),
            "name": OBRAPIClient._safe_str(raw.get("name")),
        }
        return {key: value for key, value in card.items() if value}

    @staticmethod
    def _extract_bank_transaction_code(raw: Any) -> Optional[str]:
        if raw is None:
            return None
        if isinstance(raw, str):
            return OBRAPIClient._safe_str(raw)
        if isinstance(raw, dict):
            code = OBRAPIClient._safe_str(raw.get("code"))
            subcode = OBRAPIClient._safe_str(raw.get("subCode") or raw.get("subcode"))
            if code and subcode:
                return f"{code}:{subcode}"
            return code or subcode
        return None

    def _to_transaction_model(self, raw: Any) -> Optional[Transaction]:
        if not isinstance(raw, dict):
            return None

        transaction_id = (
            raw.get("transactionId")
            or raw.get("transaction_id")
            or raw.get("id")
            or str(uuid.uuid4())
        )

        amount_payload = raw.get("amount") or raw.get("transactionAmount") or raw.get("transaction_amount")
        currency = "RUB"
        amount_value: Optional[str] = None
        if isinstance(amount_payload, dict):
            currency = amount_payload.get("currency", currency)
            amount_value = amount_payload.get("amount")
        elif amount_payload is not None:
            amount_value = amount_payload

        if amount_value is None:
            amount_value = raw.get("amount")
        if "currency" in raw and not isinstance(amount_payload, dict):
            currency = raw.get("currency") or currency

        try:
            amount = float(amount_value)
        except (TypeError, ValueError):
            return None

        indicator = raw.get("creditDebitIndicator") or raw.get("direction")
        if isinstance(indicator, str) and indicator.lower().startswith("debit"):
            amount = -abs(amount)
        elif isinstance(indicator, str) and indicator.lower().startswith("credit"):
            amount = abs(amount)

        booking_value = (
            raw.get("bookingDate")
            or raw.get("bookingDateTime")
            or raw.get("valueDate")
            or raw.get("valueDateTime")
        )
        booking_dt = self._parse_booking_datetime(booking_value)
        if booking_dt is None:
            return None

        description = (
            raw.get("transactionInformation")
            or raw.get("description")
            or raw.get("narration")
            or raw.get("statementDescription")
        )
        transaction_information = raw.get("transactionInformation")

        merchant_payload = self._normalize_merchant_payload(raw.get("merchant"))
        mcc_code = merchant_payload.get("mccCode") or self._safe_str(raw.get("mccCode") or raw.get("mcc_code"))

        bank_transaction_code = self._extract_bank_transaction_code(
            raw.get("bankTransactionCode") or raw.get("bank_transaction_code")
        )

        transaction_location = raw.get("transactionLocation") or raw.get("transaction_location") or raw.get("location")
        if not isinstance(transaction_location, dict):
            transaction_location = {}

        card_payload = self._normalize_card_payload(
            raw.get("card") or raw.get("cardInstrument") or raw.get("card_instrument")
        )

        category = self._safe_str(raw.get("category") or raw.get("transactionCategory") or raw.get("categoryCode"))

        return Transaction(
            transactionId=str(transaction_id),
            amount=amount,
            currency=str(currency),
            description=description,
            bookingDate=booking_dt.date(),
            creditDebitIndicator=self._safe_str(indicator),
            bankTransactionCode=bank_transaction_code,
            merchant=merchant_payload or {},
            mccCode=mcc_code,
            category=category,
            transactionInformation=transaction_information,
            transactionLocation=transaction_location or {},
            card=card_payload or {},
        )
</file>

<file path="src/api/client.js">
const API_BASE = import.meta.env.VITE_API_BASE ?? '';
async function fetchJson(path, options = {}) {
    const url = `${API_BASE}${path}`;
    const headers = new Headers(options.headers);
    if (options.body && !headers.get('Content-Type')) {
        headers.set('Content-Type', 'application/json');
    }
    const response = await fetch(url, { ...options, headers });
    if (!response.ok) {
        let message = `Request failed with status ${response.status}`;
        try {
            const payload = await response.json();
            if (payload?.detail) {
                message = Array.isArray(payload.detail) ? payload.detail[0]?.msg ?? message : payload.detail;
            }
        }
        catch {
            // ignore JSON parse errors
        }
        const error = new Error(message);
        error.status = response.status;
        throw error;
    }
    if (response.status === 204) {
        return {};
    }
    return (await response.json());
}
export const getBanks = (userId) => {
    const query = userId ? `?user_id=${encodeURIComponent(userId)}` : '';
    return fetchJson(`/api/banks${query}`);
};
export const startConsent = (payload) => fetchJson('/api/consents/start', { method: 'POST', body: JSON.stringify(payload) });
export const startProductConsent = (payload) => fetchJson('/api/consent/initiate/product', { method: 'POST', body: JSON.stringify(payload) });
export const pollConsent = (params) => {
    const query = new URLSearchParams({
        user_id: params.user_id,
        bank_id: params.bank_id,
        request_id: params.request_id,
    }).toString();
    return fetchJson(`/api/consents/status?${query}`);
};
export const getBankBootstrap = (bankId, userId) => fetchJson(`/api/banks/${bankId}/bootstrap?user_id=${encodeURIComponent(userId)}`);
export const getPreview = (payload) => fetchJson('/api/ingest/preview', { method: 'POST', body: JSON.stringify(payload) });
export const saveProductConsents = (payload) => fetchJson('/api/products/consent', { method: 'POST', body: JSON.stringify(payload) });
export const saveGoal = (payload) => fetchJson('/api/profile/goal', { method: 'POST', body: JSON.stringify(payload) });
export const runIngestion = (payload) => fetchJson('/api/ingest/run', { method: 'POST', body: JSON.stringify(payload) });
export const commitOnboarding = (payload) => fetchJson('/api/onboarding/commit', { method: 'POST', body: JSON.stringify(payload) });
export const getDashboard = (userId) => fetchJson(`/api/dashboard?user_id=${encodeURIComponent(userId)}`);
export const getCredits = (userId) => fetchJson(`/api/credits?user_id=${encodeURIComponent(userId)}`);
export const getFinancialPortrait = (payload) => fetchJson('/api/financial-portrait', { method: 'POST', body: JSON.stringify(payload) });
export { fetchJson };
</file>

<file path="src/api/client.ts">
import type { DashboardResponse } from '../types/dashboard';
const API_BASE = import.meta.env.VITE_API_BASE ?? '';

type FetchOptions = RequestInit & { skipAuth?: boolean };

async function fetchJson<T = any>(path: string, options: FetchOptions = {}): Promise<T> {
  const url = `${API_BASE}${path}`;
  const headers = new Headers(options.headers);
  if (options.body && !headers.get('Content-Type')) {
    headers.set('Content-Type', 'application/json');
  }

  const response = await fetch(url, { ...options, headers });
  if (!response.ok) {
    let message = `Request failed with status ${response.status}`;
    try {
      const payload = await response.json();
      if (payload?.detail) {
        message = Array.isArray(payload.detail) ? payload.detail[0]?.msg ?? message : payload.detail;
      }
    } catch {
      // ignore JSON parse errors
    }
    const error = new Error(message);
    (error as Error & { status?: number }).status = response.status;
    throw error;
  }
  if (response.status === 204) {
    return {} as T;
  }
  return (await response.json()) as T;
}

export type BankResponse = {
  banks: Array<{
    id: string;
    name: string;
    connected: boolean;
    baseUrl?: string | null;
    status?: string;
    error?: string;
  }>;
};

export const getBanks = (userId?: string) => {
  const query = userId ? `?user_id=${encodeURIComponent(userId)}` : '';
  return fetchJson<BankResponse>(`/api/banks${query}`);
};

export const startConsent = (payload: { user_id: string; bank_id: string }) =>
  fetchJson('/api/consents/start', { method: 'POST', body: JSON.stringify(payload) });

export const startProductConsent = (payload: { user_id: string; bank_id: string }) =>
  fetchJson('/api/consent/initiate/product', { method: 'POST', body: JSON.stringify(payload) });

export const pollConsent = (params: { user_id: string; bank_id: string; request_id: string }) => {
  const query = new URLSearchParams({
    user_id: params.user_id,
    bank_id: params.bank_id,
    request_id: params.request_id,
  }).toString();
  return fetchJson(`/api/consents/status?${query}`);
};

export const getBankBootstrap = (bankId: string, userId: string) =>
  fetchJson(`/api/banks/${bankId}/bootstrap?user_id=${encodeURIComponent(userId)}`);

export const getPreview = (payload: { user_id: string }) =>
  fetchJson('/api/ingest/preview', { method: 'POST', body: JSON.stringify(payload) });

export const saveProductConsents = (payload: {
  user_id: string;
  items: Array<{ bank_id: string; product_id: string; product_type?: string; consented: boolean }>;
}) => fetchJson('/api/products/consent', { method: 'POST', body: JSON.stringify(payload) });

export const saveGoal = (payload: { user_id: string; goal_type: string; goal_details: Record<string, unknown> }) =>
  fetchJson('/api/profile/goal', { method: 'POST', body: JSON.stringify(payload) });

export const runIngestion = (payload: { user_id: string }) =>
  fetchJson('/api/ingest/run', { method: 'POST', body: JSON.stringify(payload) });

export const commitOnboarding = (payload: { user_id: string }) =>
  fetchJson('/api/onboarding/commit', { method: 'POST', body: JSON.stringify(payload) });

export const getDashboard = (userId: string) =>
  fetchJson<DashboardResponse>(`/api/dashboard?user_id=${encodeURIComponent(userId)}`);

export const getCredits = (userId: string) =>
  fetchJson(`/api/credits?user_id=${encodeURIComponent(userId)}`);

export const getFinancialPortrait = (payload: { user_id: string }) =>
  fetchJson('/api/financial-portrait', { method: 'POST', body: JSON.stringify(payload) });

export type { DashboardResponse };

export { fetchJson };
</file>

<file path="src/components/__tests__/BanksList.test.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { render, screen } from '@testing-library/react';
import { describe, expect, it, vi } from 'vitest';
import { BanksList } from '../BanksList';
describe('BanksList', () => {
    it('renders empty state', () => {
        const onConnect = vi.fn();
        render(_jsx(BanksList, { banks: [], onConnect: onConnect }));
        expect(screen.getByText(/каталог банков пуст/i)).toBeInTheDocument();
    });
    it('disables button when already connected', () => {
        const onConnect = vi.fn();
        const banks = [{ id: 'demo', name: 'Demo', connected: true }];
        render(_jsx(BanksList, { banks: banks, onConnect: onConnect }));
        expect(screen.getByRole('button', { name: /готово/i })).toBeDisabled();
    });
});
</file>

<file path="src/components/__tests__/BanksList.test.tsx">
import { render, screen } from '@testing-library/react';
import { describe, expect, it, vi } from 'vitest';
import { BanksList } from '../BanksList';
import type { BankSummary } from '../../state/useUser';

describe('BanksList', () => {
  it('renders empty state', () => {
    const onConnect = vi.fn();
    render(<BanksList banks={[]} onConnect={onConnect} />);
    expect(screen.getByText(/каталог банков пуст/i)).toBeInTheDocument();
  });

  it('disables button when already connected', () => {
    const onConnect = vi.fn();
    const banks: BankSummary[] = [{ id: 'demo', name: 'Demo', connected: true }];
    render(<BanksList banks={banks} onConnect={onConnect} />);
    expect(screen.getByRole('button', { name: /готово/i })).toBeDisabled();
  });
});
</file>

<file path="src/components/__tests__/UserIdForm.test.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { fireEvent, render, screen } from '@testing-library/react';
import { describe, expect, it, vi } from 'vitest';
import { UserIdForm } from '../UserIdForm';
describe('UserIdForm', () => {
    it('validates demo-XXX format', () => {
        const handleSubmit = vi.fn();
        render(_jsx(UserIdForm, { onSubmit: handleSubmit }));
        const input = screen.getByLabelText(/user id/i);
        fireEvent.change(input, { target: { value: 'foo' } });
        fireEvent.click(screen.getByRole('button', { name: /продолжить/i }));
        expect(screen.getByRole('alert')).toHaveTextContent('demo-XXX');
        expect(handleSubmit).not.toHaveBeenCalled();
    });
});
</file>

<file path="src/components/__tests__/UserIdForm.test.tsx">
import { fireEvent, render, screen } from '@testing-library/react';
import { describe, expect, it, vi } from 'vitest';
import { UserIdForm } from '../UserIdForm';

describe('UserIdForm', () => {
  it('validates demo-XXX format', () => {
    const handleSubmit = vi.fn();
    render(<UserIdForm onSubmit={handleSubmit} />);

    const input = screen.getByLabelText(/user id/i);
    fireEvent.change(input, { target: { value: 'foo' } });
    fireEvent.click(screen.getByRole('button', { name: /продолжить/i }));

    expect(screen.getByRole('alert')).toHaveTextContent('demo-XXX');
    expect(handleSubmit).not.toHaveBeenCalled();
  });
});
</file>

<file path="src/components/BanksList.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
export const BanksList = ({ banks, onConnect, busyBankId }) => {
    if (!banks.length) {
        return (_jsx("div", { className: "card", children: _jsx("p", { children: "\u041A\u0430\u0442\u0430\u043B\u043E\u0433 \u0431\u0430\u043D\u043A\u043E\u0432 \u043F\u0443\u0441\u0442. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0431\u044D\u043A\u0435\u043D\u0434\u0430." }) }));
    }
    return (_jsx("div", { className: "grid grid-two", children: banks.map((bank) => (_jsxs("div", { className: "card", children: [_jsx("h3", { children: bank.name }), _jsxs("p", { style: { marginTop: 4, color: '#475569' }, children: ["Base URL: ", bank.baseUrl || 'не указан'] }), bank.error ? (_jsx("p", { style: { color: '#dc2626' }, children: bank.error })) : (_jsx("p", { style: { color: bank.connected ? '#16a34a' : '#475569' }, children: bank.connected ? 'Уже подключён' : 'Ожидает подключения' })), _jsx("button", { type: "button", className: "btn", disabled: !!bank.error || bank.connected || busyBankId === bank.id, onClick: () => onConnect(bank), children: bank.connected ? 'Готово' : busyBankId === bank.id ? 'Создание...' : 'Connect' })] }, bank.id))) }));
};
</file>

<file path="src/components/BanksList.tsx">
import React from 'react';
import type { BankSummary } from '../state/useUser';

type BanksListProps = {
  banks: BankSummary[];
  onConnect: (bank: BankSummary) => void;
  busyBankId?: string | null;
};

export const BanksList: React.FC<BanksListProps> = ({ banks, onConnect, busyBankId }) => {
  if (!banks.length) {
    return (
      <div className="card">
        <p>Каталог банков пуст. Проверьте настройки бэкенда.</p>
      </div>
    );
  }

  return (
    <div className="grid grid-two">
      {banks.map((bank) => (
        <div key={bank.id} className="card">
          <h3>{bank.name}</h3>
          <p style={{ marginTop: 4, color: '#475569' }}>Base URL: {bank.baseUrl || 'не указан'}</p>
          {bank.error ? (
            <p style={{ color: '#dc2626' }}>{bank.error}</p>
          ) : (
            <p style={{ color: bank.connected ? '#16a34a' : '#475569' }}>
              {bank.connected ? 'Уже подключён' : 'Ожидает подключения'}
            </p>
          )}
          <button
            type="button"
            className="btn"
            disabled={!!bank.error || bank.connected || busyBankId === bank.id}
            onClick={() => onConnect(bank)}
          >
            {bank.connected ? 'Готово' : busyBankId === bank.id ? 'Создание...' : 'Connect'}
          </button>
        </div>
      ))}
    </div>
  );
};
</file>

<file path="src/components/BanksOverviewCard.tsx">
import React from 'react';

type BankStatus = {
  bank_name: string;
  status: string;
  fetched_at: string | null;
};

type BanksOverviewCardProps = {
  totalBalance: number;
  bankStatuses: Record<string, BankStatus>;
};

const formatCurrency = (value?: number | null) => {
  if (value === null || value === undefined) return '—';
  return new Intl.NumberFormat('ru-RU', {
    style: 'currency',
    currency: 'RUB',
    maximumFractionDigits: 0,
  }).format(value);
};

const formatTimestamp = (value?: string | null) => {
  if (!value) return '—';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) return value;
  return date.toLocaleString('ru-RU', {
    hour: '2-digit',
    minute: '2-digit',
    day: 'numeric',
    month: 'long',
  });
};

const STATUS_LABELS: Record<string, { label: string; tone: 'ok' | 'error' }> = {
  ok: { label: 'OK', tone: 'ok' },
  error: { label: 'Ошибка', tone: 'error' },
};

const toneClass = (tone: 'ok' | 'error') => (tone === 'error' ? 'status-pill status-pill--error' : 'status-pill');

export const BanksOverviewCard: React.FC<BanksOverviewCardProps> = ({ totalBalance, bankStatuses }) => {
  const entries = Object.entries(bankStatuses ?? {}).map(([bankId, info]) => ({
    id: bankId,
    ...info,
  }));

  return (
    <div className="card banks-overview">
      <h2>Баланс и источники данных</h2>
      <p className="muted">Сумма на всех счетах в банках, которые успешно ответили на наш запрос.</p>
      <div className="banks-overview__summary">
        <div>
          <p className="muted">Текущий баланс</p>
          <p className="metric">{formatCurrency(totalBalance)}</p>
        </div>
      </div>

      <div className="banks-overview__list">
        {entries.length === 0 ? (
          <p className="muted">Нет подключённых банков.</p>
        ) : (
          entries.map((entry) => {
            const statusInfo = STATUS_LABELS[entry.status] ?? { label: 'НЕИЗВЕСТНО', tone: 'error' };
            return (
              <div key={entry.id} className="banks-overview__row">
                <div>
                  <p className="banks-overview__bank">{entry.bank_name}</p>
                  <p className="banks-overview__message">Обновлено: {formatTimestamp(entry.fetched_at)}</p>
                </div>
                <span className={toneClass(statusInfo.tone)}>{statusInfo.label}</span>
              </div>
            );
          })
        )}
      </div>
    </div>
  );
};

export default BanksOverviewCard;
</file>

<file path="src/components/UserIdForm.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState } from 'react';
export const USER_ID_PATTERN = /^team260-([1-9]|10)$/i;
export const validateUserId = (value) => USER_ID_PATTERN.test(value.trim());
export const UserIdForm = ({ defaultUserId = '', defaultUserName = '', onSubmit, isSubmitting, }) => {
    const [userId, setUserId] = useState(defaultUserId ?? '');
    const [userName, setUserName] = useState(defaultUserName ?? '');
    const [agreed, setAgreed] = useState(false);
    const [error, setError] = useState(null);
    const handleSubmit = async (event) => {
        event.preventDefault();
        const trimmedId = userId.trim();
        const trimmedName = userName.trim();
        if (!validateUserId(trimmedId)) {
            setError('ID должен быть в формате team260-X, где X от 1 до 10');
            return;
        }
        if (!trimmedName) {
            setError('Пожалуйста, введите ваше имя');
            return;
        }
        if (!agreed) {
            setError('Необходимо согласиться на обработку персональных данных');
            return;
        }
        setError(null);
        await onSubmit(trimmedId, trimmedName);
    };
    return (_jsxs("form", { className: "card", onSubmit: handleSubmit, children: [_jsx("h2", { children: "\u0428\u0430\u0433 1. \u0418\u0434\u0435\u043D\u0442\u0438\u0444\u0438\u043A\u0430\u0446\u0438\u044F" }), _jsx("p", { children: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u0448 ID \u0438 \u0438\u043C\u044F \u0434\u043B\u044F \u043D\u0430\u0447\u0430\u043B\u0430 \u0440\u0430\u0431\u043E\u0442\u044B." }), _jsx("label", { htmlFor: "user-id-input", children: "User ID" }), _jsx("input", { id: "user-id-input", value: userId, onChange: (e) => setUserId(e.target.value), placeholder: "team260-1", className: "text-input", disabled: isSubmitting }), _jsx("label", { htmlFor: "user-name-input", children: "\u0412\u0430\u0448\u0435 \u0438\u043C\u044F" }), _jsx("input", { id: "user-name-input", value: userName, onChange: (e) => setUserName(e.target.value), placeholder: "\u0418\u0432\u0430\u043D \u0418\u0432\u0430\u043D\u043E\u0432", className: "text-input", disabled: isSubmitting }), _jsxs("label", { style: { display: 'flex', gap: 12, alignItems: 'center', margin: '16px 0' }, children: [_jsx("input", { type: "checkbox", checked: agreed, onChange: (e) => setAgreed(e.target.checked) }), _jsx("span", { children: "\u042F \u0441\u043E\u0433\u043B\u0430\u0441\u0435\u043D \u043D\u0430 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0443 \u043F\u0435\u0440\u0441\u043E\u043D\u0430\u043B\u044C\u043D\u044B\u0445 \u0434\u0430\u043D\u043D\u044B\u0445" })] }), error ? (_jsx("p", { role: "alert", style: { color: '#dc2626', marginTop: 8 }, children: error })) : null, _jsx("button", { type: "submit", className: "btn", disabled: isSubmitting || !agreed, children: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C" })] }));
};
</file>

<file path="src/components/UserIdForm.tsx">
import React, { useState } from 'react';

export const USER_ID_PATTERN = /^team260-([1-9]|10)$/i;
export const validateUserId = (value: string): boolean => USER_ID_PATTERN.test(value.trim());

type UserIdFormProps = {
  defaultUserId?: string | null;
  defaultUserName?: string | null;
  onSubmit: (userId: string, userName: string) => void | Promise<void>;
  isSubmitting?: boolean;
};

export const UserIdForm: React.FC<UserIdFormProps> = ({
  defaultUserId = '',
  defaultUserName = '',
  onSubmit,
  isSubmitting,
}) => {
  const [userId, setUserId] = useState(defaultUserId ?? '');
  const [userName, setUserName] = useState(defaultUserName ?? '');
  const [agreed, setAgreed] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    const trimmedId = userId.trim();
    const trimmedName = userName.trim();

    if (!validateUserId(trimmedId)) {
      setError('ID должен быть в формате team260-X, где X от 1 до 10');
      return;
    }
    if (!trimmedName) {
      setError('Пожалуйста, введите ваше имя');
      return;
    }
    if (!agreed) {
      setError('Необходимо согласиться на обработку персональных данных');
      return;
    }
    setError(null);
    await onSubmit(trimmedId, trimmedName);
  };

  return (
    <form className="card" onSubmit={handleSubmit}>
      <h2>Шаг 1. Идентификация</h2>
      <p>Введите ваш ID и имя для начала работы.</p>

      <label htmlFor="user-id-input">User ID</label>
      <input
        id="user-id-input"
        value={userId}
        onChange={(e) => setUserId(e.target.value)}
        placeholder="team260-1"
        className="text-input"
        disabled={isSubmitting}
      />

      <label htmlFor="user-name-input">Ваше имя</label>
      <input
        id="user-name-input"
        value={userName}
        onChange={(e) => setUserName(e.target.value)}
        placeholder="Иван Иванов"
        className="text-input"
        disabled={isSubmitting}
      />

      <label style={{ display: 'flex', gap: 12, alignItems: 'center', margin: '16px 0' }}>
        <input type="checkbox" checked={agreed} onChange={(e) => setAgreed(e.target.checked)} />
        <span>Я согласен на обработку персональных данных</span>
      </label>

      {error ? (
        <p role="alert" style={{ color: '#dc2626', marginTop: 8 }}>
          {error}
        </p>
      ) : null}
      <button type="submit" className="btn" disabled={isSubmitting || !agreed}>
        Продолжить
      </button>
    </form>
  );
};
</file>

<file path="src/pages/__tests__/DashboardPage.test.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { render, screen, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { DashboardPage } from '../DashboardPage';
const dashboardStub = {
    current_balance: 120000,
    safe_to_spend_daily: 1500,
    goal_probability: 82,
    total_debt: 450000,
    health_score: 72,
    safe_to_spend_narrative: {
        cycle_start: '2024-05-01',
        cycle_end: '2024-05-15',
        days_in_cycle: 14,
        current_balance: 120000,
        obligations_total: 50000,
        goal_reserve: 12000,
        spendable_total: 30000,
        next_income_event: {
            label: 'Зарплата',
            next_occurrence: '2024-05-15',
            amount: 90000,
        },
    },
    safe_to_spend_context: {
        state: 'calculated',
    },
    balance_context: {
        state: 'ok',
        account_count: 2,
    },
    upcoming_events: [
        { name: 'Аренда', amount: 40000, date: '2024-05-05', is_income: false },
        { name: 'Кредитная выплата', amount: 12000, date: '2024-05-12', is_income: false },
    ],
    budget_breakdown: [
        { category: 'Продукты', amount: 10000 },
        { category: 'Транспорт', amount: 5000 },
    ],
    upcoming_payments: [
        { name: 'Аренда', amount: 40000, due_date: '2024-05-05' },
        { name: 'Кредитная выплата', amount: 12000, due_date: '2024-05-12' },
    ],
    recurring_events: [
        { name: 'Зарплата', amount: 90000, is_income: true, next_date: '2024-05-25' },
        { name: 'Коммунальные услуги', amount: -4000, is_income: false, next_date: '2024-05-07' },
    ],
};
vi.mock('../../state/useUser', () => ({
    useUser: () => ({
        userId: 'demo-user',
    }),
}));
const notifyError = vi.fn();
vi.mock('../../state/notifications', () => ({
    useNotifications: () => ({
        notifyError,
    }),
}));
const mockGetDashboard = vi.fn();
vi.mock('../../api/client', () => ({
    getDashboard: (...args) => mockGetDashboard(...args),
}));
describe('DashboardPage', () => {
    beforeEach(() => {
        mockGetDashboard.mockResolvedValue(dashboardStub);
    });
    afterEach(() => {
        vi.clearAllMocks();
    });
    it('renders Safe-to-Spend metric and goal probability', async () => {
        render(_jsx(DashboardPage, {}));
        await waitFor(() => expect(mockGetDashboard).toHaveBeenCalledWith('demo-user'));
        expect(screen.getByRole('heading', { name: /Safe-to-Spend/i })).toBeInTheDocument();
        expect(screen.getByText(/1.?500/)).toBeInTheDocument(); // formatted value (handles nbsp)
        expect(screen.getByText(/Бюджет действует до/)).toBeInTheDocument();
        expect(screen.getByText(/Всего доступно/)).toBeInTheDocument();
    });
    it('shows upcoming timeline and recurring events', async () => {
        render(_jsx(DashboardPage, {}));
        await waitFor(() => expect(mockGetDashboard).toHaveBeenCalled());
        expect(screen.getAllByText('Аренда')[0]).toBeInTheDocument();
        expect(screen.getAllByText('Кредитная выплата')[0]).toBeInTheDocument();
        expect(screen.getAllByText('Зарплата')[0]).toBeInTheDocument();
        expect(screen.getByText('Коммунальные услуги')).toBeInTheDocument();
    });
    it('falls back to error notification when request fails', async () => {
        const error = new Error('boom');
        mockGetDashboard.mockRejectedValueOnce(error);
        render(_jsx(DashboardPage, {}));
        await waitFor(() => expect(notifyError).toHaveBeenCalled());
    });
    it('shows warning callout when safe-to-spend is blocked', async () => {
        mockGetDashboard.mockResolvedValueOnce({
            ...dashboardStub,
            safe_to_spend_daily: null,
            safe_to_spend_context: {
                state: 'missing_balance',
                message: 'Подключите счёт, чтобы рассчитать лимит.',
            },
        });
        render(_jsx(DashboardPage, {}));
        await waitFor(() => expect(mockGetDashboard).toHaveBeenCalled());
        expect(screen.getByText(/Подключите счёт/)).toBeInTheDocument();
        expect(screen.getByText(/Нет оценки/)).toBeInTheDocument();
    });
});
</file>

<file path="src/pages/__tests__/DashboardPage.test.tsx">
import { render, screen, waitFor } from '@testing-library/react';
import React from 'react';
import { vi } from 'vitest';
import type { DashboardResponse } from '../../types/dashboard';
import { DashboardPage } from '../DashboardPage.tsx';

const dashboardStub: DashboardResponse = {
  total_balance: 150000,
  safe_to_spend_daily: 3500,
  next_income_date: '2025-12-25',
  days_until_next_income: 10,
  accounts: [{ accountId: 'acc1', nickname: 'Зарплатный' }],
  bank_statuses: {
    vbank: { bank_name: 'VBank', status: 'ok', fetched_at: new Date().toISOString() },
    abank: { bank_name: 'ABank', status: 'error', fetched_at: null },
  },
};

vi.mock('../../state/useUser', () => ({
  useUser: () => ({
    userId: 'demo-user',
  }),
}));

const notifyError = vi.fn();

vi.mock('../../state/notifications', () => ({
  useNotifications: () => ({
    notifyError,
  }),
}));

const mockGetDashboard = vi.fn();

vi.mock('../../api/client', () => ({
  getDashboard: (...args: unknown[]) => mockGetDashboard(...args),
}));

describe('DashboardPage', () => {
  beforeEach(() => {
    mockGetDashboard.mockResolvedValue(dashboardStub);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('renders the new Safe-to-Spend metric correctly', async () => {
    render(<DashboardPage />);
    await waitFor(() => expect(mockGetDashboard).toHaveBeenCalledWith('demo-user'));

    expect(screen.getByRole('heading', { name: /Safe-to-Spend/i })).toBeInTheDocument();
    expect(screen.getByText(/3.?500/)).toBeInTheDocument();
    expect(screen.getByText(/до следующей зарплаты/)).toBeInTheDocument();
  });

  it('renders the BanksOverviewCard with total balance and statuses', async () => {
    render(<DashboardPage />);
    await waitFor(() => expect(mockGetDashboard).toHaveBeenCalled());

    expect(screen.getByRole('heading', { name: /Баланс и источники данных/i })).toBeInTheDocument();
    expect(screen.getByText(/150.?000/)).toBeInTheDocument();
    expect(screen.getByText('VBank')).toBeInTheDocument();
    expect(screen.getByText('ABank')).toBeInTheDocument();
    expect(screen.getByText('OK')).toBeInTheDocument();
    expect(screen.getByText('Ошибка')).toBeInTheDocument();
  });

  it('shows an error notification if the API call fails', async () => {
    const error = new Error('API is down');
    mockGetDashboard.mockRejectedValueOnce(error);
    render(<DashboardPage />);
    await waitFor(() => expect(notifyError).toHaveBeenCalledWith('Не удалось загрузить данные для дашборда.'));
  });
});
</file>

<file path="src/pages/BanksCatalogPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';
export const BanksCatalogPage = () => {
    const { userId, banks, refreshBanks, isFetchingBanks } = useUser();
    const { notifyError } = useNotifications();
    const navigate = useNavigate();
    const [selectedBankIds, setSelectedBankIds] = useState(new Set());
    useEffect(() => {
        if (userId) {
            refreshBanks();
        }
    }, [userId, refreshBanks]);
    const handleToggleBank = (bankId) => {
        setSelectedBankIds((prev) => {
            const next = new Set(prev);
            if (next.has(bankId)) {
                next.delete(bankId);
            }
            else {
                next.add(bankId);
            }
            return next;
        });
    };
    const handleSubmit = () => {
        if (selectedBankIds.size === 0) {
            notifyError('Выберите хотя бы один банк');
            return;
        }
        const selectedBanks = banks.filter((bank) => selectedBankIds.has(bank.id));
        navigate('/onboarding/consent', { state: { selectedBanks } });
    };
    return (_jsxs("div", { className: "app-main", children: [_jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0428\u0430\u0433 2. \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0431\u0430\u043D\u043A\u0438" }), _jsx("p", { children: "\u041E\u0442\u043C\u0435\u0442\u044C\u0442\u0435 \u0431\u0430\u043D\u043A\u0438, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u0445\u043E\u0442\u0438\u0442\u0435 \u043F\u043E\u0434\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0434\u043B\u044F \u0430\u043D\u0430\u043B\u0438\u0437\u0430." })] }), isFetchingBanks && (_jsx("div", { className: "card", children: _jsx("p", { children: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u0441\u043F\u0438\u0441\u043A\u0430 \u0431\u0430\u043D\u043A\u043E\u0432..." }) })), !isFetchingBanks && banks.length === 0 && (_jsx("div", { className: "card", children: _jsx("p", { children: "\u041A\u0430\u0442\u0430\u043B\u043E\u0433 \u0431\u0430\u043D\u043A\u043E\u0432 \u043F\u0443\u0441\u0442. \u041F\u0440\u043E\u0432\u0435\u0440\u044C\u0442\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u0431\u044D\u043A\u0435\u043D\u0434\u0430." }) })), banks.length > 0 && (_jsx("div", { className: "card", children: banks.map((bank, index) => (_jsx("div", { style: { padding: '12px 0', borderBottom: index === banks.length - 1 ? 'none' : '1px solid #eee' }, children: _jsxs("label", { style: { display: 'flex', alignItems: 'center', gap: 12, cursor: 'pointer' }, children: [_jsx("input", { type: "checkbox", checked: selectedBankIds.has(bank.id), onChange: () => handleToggleBank(bank.id), disabled: bank.connected }), _jsxs("div", { children: [_jsx("strong", { children: bank.name }), _jsx("p", { style: { margin: 0, fontSize: 14, color: bank.connected ? '#16a34a' : '#475569' }, children: bank.connected ? 'Уже подключён' : 'Готов к подключению' })] })] }) }, bank.id))) })), _jsx("button", { className: "btn", onClick: handleSubmit, disabled: selectedBankIds.size === 0 || isFetchingBanks, children: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C" })] }));
};
</file>

<file path="src/pages/BanksCatalogPage.tsx">
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useNotifications } from '../state/notifications';
import { useUser, BankSummary } from '../state/useUser';

export const BanksCatalogPage: React.FC = () => {
  const { userId, banks, refreshBanks, isFetchingBanks } = useUser();
  const { notifyError } = useNotifications();
  const navigate = useNavigate();
  const [selectedBankIds, setSelectedBankIds] = useState<Set<string>>(new Set());

  useEffect(() => {
    if (userId) {
      refreshBanks();
    }
  }, [userId, refreshBanks]);

  const handleToggleBank = (bankId: string) => {
    setSelectedBankIds((prev) => {
      const next = new Set(prev);
      if (next.has(bankId)) {
        next.delete(bankId);
      } else {
        next.add(bankId);
      }
      return next;
    });
  };

  const handleSubmit = () => {
    if (selectedBankIds.size === 0) {
      notifyError('Выберите хотя бы один банк');
      return;
    }
    const selectedBanks: BankSummary[] = banks.filter((bank) => selectedBankIds.has(bank.id));
    navigate('/onboarding/consent', { state: { selectedBanks } });
  };

  return (
    <div className="app-main">
      <div className="card">
        <h2>Шаг 2. Выберите банки</h2>
        <p>Отметьте банки, которые хотите подключить для анализа.</p>
      </div>

      {isFetchingBanks && (
        <div className="card">
          <p>Загрузка списка банков...</p>
        </div>
      )}

      {!isFetchingBanks && banks.length === 0 && (
        <div className="card">
          <p>Каталог банков пуст. Проверьте настройки бэкенда.</p>
        </div>
      )}

      {banks.length > 0 && (
        <div className="card">
          {banks.map((bank, index) => (
            <div
              key={bank.id}
              style={{ padding: '12px 0', borderBottom: index === banks.length - 1 ? 'none' : '1px solid #eee' }}
            >
              <label style={{ display: 'flex', alignItems: 'center', gap: 12, cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={selectedBankIds.has(bank.id)}
                  onChange={() => handleToggleBank(bank.id)}
                  disabled={bank.connected}
                />
                <div>
                  <strong>{bank.name}</strong>
                  <p style={{ margin: 0, fontSize: 14, color: bank.connected ? '#16a34a' : '#475569' }}>
                    {bank.connected ? 'Уже подключён' : 'Готов к подключению'}
                  </p>
                </div>
              </label>
            </div>
          ))}
        </div>
      )}

      <button className="btn" onClick={handleSubmit} disabled={selectedBankIds.size === 0 || isFetchingBanks}>
        Продолжить
      </button>
    </div>
  );
};
</file>

<file path="src/pages/CallbackPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useLocation, useNavigate } from 'react-router-dom';
export const CallbackPage = () => {
    const { search } = useLocation();
    const navigate = useNavigate();
    const params = new URLSearchParams(search);
    const consentId = params.get('consent_id');
    return (_jsx("div", { className: "app-main", children: _jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0411\u0430\u043D\u043A \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u043B \u043A\u043E\u043D\u0441\u0435\u043D\u0442" }), _jsx("p", { children: "\u041C\u043E\u0436\u043D\u043E \u0437\u0430\u043A\u0440\u044B\u0442\u044C \u0432\u043A\u043B\u0430\u0434\u043A\u0443 \u0431\u0430\u043D\u043A\u0430 \u0438 \u0432\u0435\u0440\u043D\u0443\u0442\u044C\u0441\u044F \u0432 \u043F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u0435." }), consentId ? _jsxs("p", { children: ["Consent ID: ", consentId] }) : null, _jsx("button", { className: "btn", onClick: () => navigate('/banks/preview'), children: "\u0412\u0435\u0440\u043D\u0443\u0442\u044C\u0441\u044F" })] }) }));
};
</file>

<file path="src/pages/CallbackPage.tsx">
import React from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

export const CallbackPage: React.FC = () => {
  const { search } = useLocation();
  const navigate = useNavigate();
  const params = new URLSearchParams(search);
  const consentId = params.get('consent_id');

  return (
    <div className="app-main">
      <div className="card">
        <h2>Банк подтвердил консент</h2>
        <p>Можно закрыть вкладку банка и вернуться в приложение.</p>
        {consentId ? <p>Consent ID: {consentId}</p> : null}
        <button className="btn" onClick={() => navigate('/banks/preview')}>
          Вернуться
        </button>
      </div>
    </div>
  );
};
</file>

<file path="src/pages/ConsentProcessPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { startConsent, startProductConsent, pollConsent } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';
const POLL_INTERVAL_MS = 3000;
export const ConsentProcessPage = () => {
    const { state } = useLocation();
    const navigate = useNavigate();
    const { userId } = useUser();
    const { notifyError, notifySuccess } = useNotifications();
    const [bankStates, setBankStates] = useState([]);
    const [currentIndex, setCurrentIndex] = useState(0);
    useEffect(() => {
        const selectedBanks = state?.selectedBanks;
        if (!selectedBanks || selectedBanks.length === 0) {
            navigate('/banks');
        }
        else {
            setBankStates(selectedBanks.map((bank) => ({
                ...bank,
                accountsStatus: 'idle',
                productsStatus: 'idle',
                activeStepData: {},
            })));
        }
    }, [state, navigate]);
    const updateBankStatus = (index, newState) => {
        setBankStates((prev) => prev.map((bank, i) => (i === index ? { ...bank, ...newState } : bank)));
    };
    const finishBank = useCallback(() => {
        setTimeout(() => setCurrentIndex((prev) => prev + 1), 1200);
    }, []);
    const requestConsent = useCallback(async (index, step) => {
        const bank = bankStates[index];
        if (!bank || !userId) {
            return;
        }
        const statusField = step === 'accounts' ? 'accountsStatus' : 'productsStatus';
        updateBankStatus(index, { [statusField]: 'connecting', errorMessage: undefined, activeStepData: {} });
        try {
            const apiCall = step === 'accounts' ? startConsent : startProductConsent;
            const response = await apiCall({ user_id: userId, bank_id: bank.id });
            if (response.state === 'error') {
                const message = response.error_message ?? 'Не удалось инициировать согласие';
                notifyError(message);
                updateBankStatus(index, { [statusField]: 'error', errorMessage: message });
                return;
            }
            if (response.auto_approved || response.state === 'approved') {
                notifySuccess(`Доступ к ${step === 'accounts' ? 'счетам/транзакциям' : 'продуктам'} для ${bank.name} получен!`);
                updateBankStatus(index, { [statusField]: 'connected', activeStepData: {} });
                if (step === 'accounts') {
                    void requestConsent(index, 'products');
                }
                else {
                    finishBank();
                }
            }
            else {
                const pendingData = { approvalUrl: response.approval_url, requestId: response.request_id };
                updateBankStatus(index, {
                    [statusField]: 'pending_approval',
                    activeStepData: pendingData,
                });
            }
        }
        catch (error) {
            const message = error instanceof Error ? error.message : 'Неизвестная ошибка';
            notifyError(`Ошибка доступа к ${step === 'accounts' ? 'счетам' : 'продуктам'} для ${bank.name}`);
            updateBankStatus(index, { [statusField]: 'error', errorMessage: message });
        }
    }, [bankStates, finishBank, notifyError, notifySuccess, userId]);
    const handlePoll = useCallback(async (index, step, requestIdOverride) => {
        const bank = bankStates[index];
        const requestId = requestIdOverride ?? bank?.activeStepData?.requestId;
        if (!bank || !userId || !requestId)
            return;
        const statusField = step === 'accounts' ? 'accountsStatus' : 'productsStatus';
        updateBankStatus(index, { [statusField]: 'polling' });
        const poll = async () => {
            try {
                const payload = await pollConsent({ user_id: userId, bank_id: bank.id, request_id: requestId });
                if (payload.state === 'approved') {
                    notifySuccess(`Подтверждение на ${step === 'accounts' ? 'счета' : 'продукты'} от ${bank.name} получено!`);
                    updateBankStatus(index, { [statusField]: 'connected', activeStepData: {} });
                    if (step === 'accounts') {
                        void requestConsent(index, 'products');
                    }
                    else {
                        finishBank();
                    }
                    return true;
                }
                return false;
            }
            catch (error) {
                const message = error instanceof Error ? error.message : 'Ошибка опроса статуса';
                notifyError(message);
                updateBankStatus(index, { [statusField]: 'error', errorMessage: message });
                return true;
            }
        };
        const intervalId = setInterval(async () => {
            if (await poll()) {
                clearInterval(intervalId);
            }
        }, POLL_INTERVAL_MS);
        if (await poll()) {
            clearInterval(intervalId);
        }
    }, [bankStates, finishBank, notifyError, notifySuccess, requestConsent, userId]);
    useEffect(() => {
        if (bankStates.length === 0) {
            return;
        }
        if (currentIndex < bankStates.length) {
            const bank = bankStates[currentIndex];
            if (bank.accountsStatus === 'idle') {
                void requestConsent(currentIndex, 'accounts');
            }
        }
    }, [bankStates, currentIndex, requestConsent]);
    useEffect(() => {
        bankStates.forEach((bank, index) => {
            if (bank.accountsStatus === 'pending_approval' &&
                !bank.activeStepData?.approvalUrl &&
                bank.activeStepData?.requestId) {
                void handlePoll(index, 'accounts', bank.activeStepData.requestId);
            }
            if (bank.accountsStatus === 'connected' &&
                bank.productsStatus === 'pending_approval' &&
                !bank.activeStepData?.approvalUrl &&
                bank.activeStepData?.requestId) {
                void handlePoll(index, 'products', bank.activeStepData.requestId);
            }
        });
    }, [bankStates, handlePoll]);
    const retryBank = (index) => {
        const bank = bankStates[index];
        if (!bank)
            return;
        if (bank.accountsStatus !== 'connected') {
            void requestConsent(index, 'accounts');
        }
        else {
            void requestConsent(index, 'products');
        }
    };
    const isFinished = bankStates.length > 0 && currentIndex >= bankStates.length;
    const renderStepStatus = (label, status, bank, step, index) => (_jsxs("div", { style: { padding: '8px 0', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }, children: [_jsx("span", { children: label }), status === 'idle' && _jsx("span", { style: { color: '#94a3b8' }, children: "\u041E\u0436\u0438\u0434\u0430\u043D\u0438\u0435\u2026" }), (status === 'connecting' || status === 'polling') && _jsx("span", { children: "\u0412 \u043F\u0440\u043E\u0446\u0435\u0441\u0441\u0435 \u23F3" }), status === 'connected' && _jsx("span", { style: { color: '#16a34a', fontWeight: 600 }, children: "\u2705 \u041F\u043E\u043B\u0443\u0447\u0435\u043D" }), status === 'error' && _jsx("span", { style: { color: '#dc2626', fontWeight: 600 }, children: "\u274C \u041E\u0448\u0438\u0431\u043A\u0430" }), status === 'pending_approval' &&
                (bank.activeStepData?.approvalUrl ? (_jsxs("div", { style: { display: 'flex', gap: 8 }, children: [_jsx("a", { className: "btn-secondary btn", href: bank.activeStepData.approvalUrl, target: "_blank", rel: "noreferrer", children: "\u041F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u0442\u044C \u0432 \u0431\u0430\u043D\u043A\u0435" }), _jsx("button", { className: "btn", onClick: () => handlePoll(index, step), children: "\u042F \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u043B" })] })) : (_jsx("span", { children: "\u041E\u0436\u0438\u0434\u0430\u0435\u043C \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043D\u0438\u0435 \u043E\u0442 \u0431\u0430\u043D\u043A\u0430\u2026" })))] }));
    return (_jsxs("div", { className: "app-main", children: [_jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0428\u0430\u0433 3. \u041F\u043E\u0434\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0435 \u0431\u0430\u043D\u043A\u043E\u0432" }), _jsx("p", { children: "\u0414\u043B\u044F \u043A\u0430\u0436\u0434\u043E\u0433\u043E \u0431\u0430\u043D\u043A\u0430 \u043F\u043E\u043B\u0443\u0447\u0430\u0435\u043C \u0434\u043E\u0441\u0442\u0443\u043F \u043A \u0441\u0447\u0435\u0442\u0430\u043C \u0438 \u043E\u0442\u0434\u0435\u043B\u044C\u043D\u043E\u0435 \u0441\u043E\u0433\u043B\u0430\u0441\u0438\u0435 \u043D\u0430 \u0443\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u043F\u0440\u043E\u0434\u0443\u043A\u0442\u0430\u043C\u0438." })] }), bankStates.map((bank, index) => (_jsxs("div", { className: "card", style: { opacity: index === currentIndex ? 1 : 0.6 }, children: [_jsxs("h3", { children: [index + 1, ". ", bank.name] }), renderStepStatus('1. Доступ к счетам и транзакциям', bank.accountsStatus, bank, 'accounts', index), bank.accountsStatus === 'connected' &&
                        renderStepStatus('2. Доступ к продуктам (кредиты/вклады/карты)', bank.productsStatus, bank, 'products', index), (bank.accountsStatus === 'error' || bank.productsStatus === 'error') && (_jsx("button", { className: "btn-secondary btn", style: { marginTop: 12 }, onClick: () => retryBank(index), children: "\u041F\u043E\u0432\u0442\u043E\u0440\u0438\u0442\u044C" }))] }, bank.id))), isFinished && (_jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0412\u0441\u0435 \u0431\u0430\u043D\u043A\u0438 \u043E\u0431\u0440\u0430\u0431\u043E\u0442\u0430\u043D\u044B!" }), _jsx("p", { children: "\u0414\u043E\u0441\u0442\u0443\u043F\u044B \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u044B, \u043C\u043E\u0436\u043D\u043E \u043F\u0435\u0440\u0435\u0445\u043E\u0434\u0438\u0442\u044C \u043A \u0430\u043D\u0430\u043B\u0438\u0442\u0438\u043A\u0435." }), _jsx("button", { className: "btn", onClick: () => navigate('/dashboard'), children: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0430\u043D\u0430\u043B\u0438\u0442\u0438\u043A\u0435" })] }))] }));
};
</file>

<file path="src/pages/ConsentProcessPage.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { startConsent, startProductConsent, pollConsent } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser, BankSummary } from '../state/useUser';

type ConsentStep = 'accounts' | 'products';
type StepStatus = 'idle' | 'connecting' | 'pending_approval' | 'polling' | 'connected' | 'error';

type BankState = BankSummary & {
  accountsStatus: StepStatus;
  productsStatus: StepStatus;
  errorMessage?: string;
  activeStepData?: {
    approvalUrl?: string;
    requestId?: string;
  };
};

const POLL_INTERVAL_MS = 3000;

export const ConsentProcessPage: React.FC = () => {
  const { state } = useLocation();
  const navigate = useNavigate();
  const { userId } = useUser();
  const { notifyError, notifySuccess } = useNotifications();

  const [bankStates, setBankStates] = useState<BankState[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);

  useEffect(() => {
    const selectedBanks = state?.selectedBanks as BankSummary[] | undefined;
    if (!selectedBanks || selectedBanks.length === 0) {
      navigate('/banks');
    } else {
      setBankStates(
        selectedBanks.map((bank) => ({
          ...bank,
          accountsStatus: 'idle',
          productsStatus: 'idle',
          activeStepData: {},
        }))
      );
    }
  }, [state, navigate]);

  const updateBankStatus = (index: number, newState: Partial<BankState>) => {
    setBankStates((prev) => prev.map((bank, i) => (i === index ? { ...bank, ...newState } : bank)));
  };

  const finishBank = useCallback(() => {
    setTimeout(() => setCurrentIndex((prev) => prev + 1), 1200);
  }, []);

  const requestConsent = useCallback(
    async (index: number, step: ConsentStep) => {
      const bank = bankStates[index];
      if (!bank || !userId) {
        return;
      }

      const statusField = step === 'accounts' ? 'accountsStatus' : 'productsStatus';
      updateBankStatus(index, { [statusField]: 'connecting', errorMessage: undefined, activeStepData: {} });

      try {
        const apiCall = step === 'accounts' ? startConsent : startProductConsent;
        const response = await apiCall({ user_id: userId, bank_id: bank.id });
        if (response.state === 'error') {
          const message = response.error_message ?? 'Не удалось инициировать согласие';
          notifyError(message);
          updateBankStatus(index, { [statusField]: 'error', errorMessage: message });
          return;
        }

        if (response.auto_approved || response.state === 'approved') {
          notifySuccess(
            `Доступ к ${step === 'accounts' ? 'счетам/транзакциям' : 'продуктам'} для ${bank.name} получен!`
          );
          updateBankStatus(index, { [statusField]: 'connected', activeStepData: {} });
          if (step === 'accounts') {
            void requestConsent(index, 'products');
          } else {
            finishBank();
          }
        } else {
          const pendingData = { approvalUrl: response.approval_url, requestId: response.request_id };
          updateBankStatus(index, {
            [statusField]: 'pending_approval',
            activeStepData: pendingData,
          });
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Неизвестная ошибка';
        notifyError(`Ошибка доступа к ${step === 'accounts' ? 'счетам' : 'продуктам'} для ${bank.name}`);
        updateBankStatus(index, { [statusField]: 'error', errorMessage: message });
      }
    },
    [bankStates, finishBank, notifyError, notifySuccess, userId]
  );

  const handlePoll = useCallback(
    async (index: number, step: ConsentStep, requestIdOverride?: string) => {
      const bank = bankStates[index];
      const requestId = requestIdOverride ?? bank?.activeStepData?.requestId;
      if (!bank || !userId || !requestId) return;

      const statusField = step === 'accounts' ? 'accountsStatus' : 'productsStatus';
      updateBankStatus(index, { [statusField]: 'polling' });

      const poll = async (): Promise<boolean> => {
        try {
          const payload = await pollConsent({ user_id: userId, bank_id: bank.id, request_id: requestId });
          if (payload.state === 'approved') {
            notifySuccess(`Подтверждение на ${step === 'accounts' ? 'счета' : 'продукты'} от ${bank.name} получено!`);
            updateBankStatus(index, { [statusField]: 'connected', activeStepData: {} });
            if (step === 'accounts') {
              void requestConsent(index, 'products');
            } else {
              finishBank();
            }
            return true;
          }
          return false;
        } catch (error) {
          const message = error instanceof Error ? error.message : 'Ошибка опроса статуса';
          notifyError(message);
          updateBankStatus(index, { [statusField]: 'error', errorMessage: message });
          return true;
        }
      };

      const intervalId = setInterval(async () => {
        if (await poll()) {
          clearInterval(intervalId);
        }
      }, POLL_INTERVAL_MS);

      if (await poll()) {
        clearInterval(intervalId);
      }
    },
    [bankStates, finishBank, notifyError, notifySuccess, requestConsent, userId]
  );

  useEffect(() => {
    if (bankStates.length === 0) {
      return;
    }
    if (currentIndex < bankStates.length) {
      const bank = bankStates[currentIndex];
      if (bank.accountsStatus === 'idle') {
        void requestConsent(currentIndex, 'accounts');
      }
    }
  }, [bankStates, currentIndex, requestConsent]);

  useEffect(() => {
    bankStates.forEach((bank, index) => {
      if (
        bank.accountsStatus === 'pending_approval' &&
        !bank.activeStepData?.approvalUrl &&
        bank.activeStepData?.requestId
      ) {
        void handlePoll(index, 'accounts', bank.activeStepData.requestId);
      }
      if (
        bank.accountsStatus === 'connected' &&
        bank.productsStatus === 'pending_approval' &&
        !bank.activeStepData?.approvalUrl &&
        bank.activeStepData?.requestId
      ) {
        void handlePoll(index, 'products', bank.activeStepData.requestId);
      }
    });
  }, [bankStates, handlePoll]);

  const retryBank = (index: number) => {
    const bank = bankStates[index];
    if (!bank) return;
    if (bank.accountsStatus !== 'connected') {
      void requestConsent(index, 'accounts');
    } else {
      void requestConsent(index, 'products');
    }
  };

  const isFinished = bankStates.length > 0 && currentIndex >= bankStates.length;

  const renderStepStatus = (
    label: string,
    status: StepStatus,
    bank: BankState,
    step: ConsentStep,
    index: number
  ) => (
    <div style={{ padding: '8px 0', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
      <span>{label}</span>
      {status === 'idle' && <span style={{ color: '#94a3b8' }}>Ожидание…</span>}
      {(status === 'connecting' || status === 'polling') && <span>В процессе ⏳</span>}
      {status === 'connected' && <span style={{ color: '#16a34a', fontWeight: 600 }}>✅ Получен</span>}
      {status === 'error' && <span style={{ color: '#dc2626', fontWeight: 600 }}>❌ Ошибка</span>}
      {status === 'pending_approval' &&
        (bank.activeStepData?.approvalUrl ? (
          <div style={{ display: 'flex', gap: 8 }}>
            <a className="btn-secondary btn" href={bank.activeStepData.approvalUrl} target="_blank" rel="noreferrer">
              Подтвердить в банке
            </a>
            <button className="btn" onClick={() => handlePoll(index, step)}>
              Я подтвердил
            </button>
          </div>
        ) : (
          <span>Ожидаем подтверждение от банка…</span>
        ))}
    </div>
  );

  return (
    <div className="app-main">
      <div className="card">
        <h2>Шаг 3. Подключение банков</h2>
        <p>Для каждого банка получаем доступ к счетам и отдельное согласие на управление продуктами.</p>
      </div>
      {bankStates.map((bank, index) => (
        <div className="card" key={bank.id} style={{ opacity: index === currentIndex ? 1 : 0.6 }}>
          <h3>
            {index + 1}. {bank.name}
          </h3>
          {renderStepStatus('1. Доступ к счетам и транзакциям', bank.accountsStatus, bank, 'accounts', index)}
          {bank.accountsStatus === 'connected' &&
            renderStepStatus('2. Доступ к продуктам (кредиты/вклады/карты)', bank.productsStatus, bank, 'products', index)}
          {(bank.accountsStatus === 'error' || bank.productsStatus === 'error') && (
            <button className="btn-secondary btn" style={{ marginTop: 12 }} onClick={() => retryBank(index)}>
              Повторить
            </button>
          )}
        </div>
      ))}
      {isFinished && (
        <div className="card">
          <h2>Все банки обработаны!</h2>
          <p>Доступы получены, можно переходить к аналитике.</p>
          <button className="btn" onClick={() => navigate('/dashboard')}>
            Перейти к аналитике
          </button>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/pages/ConsentStatusPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useEffect, useState } from 'react';
import { useNavigate, useParams, useSearchParams } from 'react-router-dom';
import { pollConsent } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';
const POLL_INTERVAL_MS = 3500;
export const ConsentStatusPage = () => {
    const { bankId } = useParams();
    const [searchParams] = useSearchParams();
    const requestId = searchParams.get('requestId') || undefined;
    const bankName = searchParams.get('bankName') ?? bankId;
    const navigate = useNavigate();
    const { userId, upsertConsent } = useUser();
    const { notifyError } = useNotifications();
    const [status, setStatus] = useState(null);
    const [isPolling, setIsPolling] = useState(false);
    const runPoll = useCallback(async () => {
        if (!userId || !bankId || !requestId) {
            return null;
        }
        try {
            setIsPolling(true);
            const payload = await pollConsent({ user_id: userId, bank_id: bankId, request_id: requestId });
            setStatus(payload);
            upsertConsent({
                bankId,
                requestId,
                consentId: payload.consent_id,
                status: payload.state,
                approvalUrl: payload.approval_url,
            });
            return payload;
        }
        catch (error) {
            console.error(error);
            notifyError('Не удалось обновить статус');
            return null;
        }
        finally {
            setIsPolling(false);
        }
    }, [bankId, bankName, notifyError, requestId, upsertConsent, userId]);
    useEffect(() => {
        if (!userId || !bankId || !requestId)
            return;
        let timer;
        let cancelled = false;
        const schedule = () => {
            timer = window.setTimeout(async () => {
                if (cancelled)
                    return;
                const payload = await runPoll();
                if (!cancelled && payload?.state !== 'approved') {
                    schedule();
                }
            }, POLL_INTERVAL_MS);
        };
        runPoll().then((payload) => {
            if (!cancelled && payload?.state !== 'approved') {
                schedule();
            }
        });
        return () => {
            cancelled = true;
            window.clearTimeout(timer);
        };
    }, [bankId, requestId, runPoll, userId]);
    const canContinue = status?.state === 'approved';
    if (!bankId || !requestId) {
        return (_jsx("div", { className: "app-main", children: _jsxs("div", { className: "card", children: [_jsx("p", { children: "\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0437\u0430\u043F\u0440\u043E\u0441\u0430. \u0412\u0435\u0440\u043D\u0438\u0442\u0435\u0441\u044C \u043A \u0441\u043F\u0438\u0441\u043A\u0443 \u0431\u0430\u043D\u043A\u043E\u0432." }), _jsx("button", { className: "btn-secondary btn", onClick: () => navigate('/banks'), children: "\u041D\u0430\u0437\u0430\u0434 \u043A \u0431\u0430\u043D\u043A\u0430\u043C" })] }) }));
    }
    return (_jsx("div", { className: "app-main", children: _jsxs("div", { className: "card", children: [_jsxs("h2", { children: ["\u0421\u0442\u0430\u0442\u0443\u0441 \u0437\u0430\u043F\u0440\u043E\u0441\u0430 \u0432 ", bankName] }), _jsxs("p", { children: ["\u0421\u0442\u0430\u0442\u0443\u0441: ", status?.state ?? 'ожидание'] }), _jsxs("p", { children: ["\u041E\u0442\u0432\u0435\u0442 \u0431\u0430\u043D\u043A\u0430: ", status?.status ?? '...', " "] }), status?.approval_url ? (_jsxs("p", { children: ["\u0421\u0441\u044B\u043B\u043A\u0430: ", _jsx("a", { href: status.approval_url, children: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043F\u043E\u0440\u0442\u0430\u043B \u0431\u0430\u043D\u043A\u0430" })] })) : null, _jsxs("div", { style: { display: 'flex', gap: 12, marginTop: 16 }, children: [_jsx("button", { className: "btn", onClick: runPoll, disabled: isPolling, children: "\u042F \u043F\u043E\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u043B" }), _jsx("button", { className: "btn-secondary btn", onClick: () => navigate('/banks'), children: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0434\u0440\u0443\u0433\u043E\u0439 \u0431\u0430\u043D\u043A" })] }), canContinue ? (_jsx("button", { className: "btn", style: { marginTop: 16 }, onClick: () => navigate('/banks/preview'), children: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u043F\u0440\u043E\u0434\u0443\u043A\u0442\u0430\u043C" })) : null] }) }));
};
</file>

<file path="src/pages/ConsentStatusPage.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import { useNavigate, useParams, useSearchParams } from 'react-router-dom';
import { pollConsent } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';

type ConsentStatusPayload = {
  state: string;
  status: string;
  approval_url?: string;
  consent_id?: string;
  request_id?: string;
};

const POLL_INTERVAL_MS = 3500;

export const ConsentStatusPage: React.FC = () => {
  const { bankId } = useParams();
  const [searchParams] = useSearchParams();
  const requestId = searchParams.get('requestId') || undefined;
  const bankName = searchParams.get('bankName') ?? bankId;
  const navigate = useNavigate();
  const { userId, upsertConsent } = useUser();
  const { notifyError } = useNotifications();
  const [status, setStatus] = useState<ConsentStatusPayload | null>(null);
  const [isPolling, setIsPolling] = useState(false);

  const runPoll = useCallback(async (): Promise<ConsentStatusPayload | null> => {
    if (!userId || !bankId || !requestId) {
      return null;
    }
    try {
      setIsPolling(true);
      const payload = await pollConsent({ user_id: userId, bank_id: bankId, request_id: requestId });
      setStatus(payload);
      upsertConsent({
        bankId,
        requestId,
        consentId: payload.consent_id,
        status: payload.state,
        approvalUrl: payload.approval_url,
      });
      return payload;
    } catch (error) {
      console.error(error);
      notifyError('Не удалось обновить статус');
      return null;
    }
    finally {
      setIsPolling(false);
    }
  }, [bankId, bankName, notifyError, requestId, upsertConsent, userId]);

  useEffect(() => {
    if (!userId || !bankId || !requestId) return;
    let timer: number;
    let cancelled = false;
    const schedule = () => {
      timer = window.setTimeout(async () => {
        if (cancelled) return;
        const payload = await runPoll();
        if (!cancelled && payload?.state !== 'approved') {
          schedule();
        }
      }, POLL_INTERVAL_MS);
    };

    runPoll().then((payload) => {
      if (!cancelled && payload?.state !== 'approved') {
        schedule();
      }
    });
    return () => {
      cancelled = true;
      window.clearTimeout(timer);
    };
  }, [bankId, requestId, runPoll, userId]);

  const canContinue = status?.state === 'approved';

  if (!bankId || !requestId) {
    return (
      <div className="app-main">
        <div className="card">
          <p>Нет активного запроса. Вернитесь к списку банков.</p>
          <button className="btn-secondary btn" onClick={() => navigate('/banks')}>
            Назад к банкам
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="app-main">
      <div className="card">
        <h2>Статус запроса в {bankName}</h2>
        <p>Статус: {status?.state ?? 'ожидание'}</p>
        <p>Ответ банка: {status?.status ?? '...'} </p>
        {status?.approval_url ? (
          <p>
            Ссылка: <a href={status.approval_url}>Открыть портал банка</a>
          </p>
        ) : null}
        <div style={{ display: 'flex', gap: 12, marginTop: 16 }}>
          <button className="btn" onClick={runPoll} disabled={isPolling}>
            Я подтвердил
          </button>
          <button className="btn-secondary btn" onClick={() => navigate('/banks')}>
            Выбрать другой банк
          </button>
        </div>
        {canContinue ? (
          <button className="btn" style={{ marginTop: 16 }} onClick={() => navigate('/banks/preview')}>
            Перейти к продуктам
          </button>
        ) : null}
      </div>
    </div>
  );
};
</file>

<file path="src/pages/DashboardPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useState } from 'react';
import { getDashboard } from '../api/client';
import { useUser } from '../state/useUser';
import { useNotifications } from '../state/notifications';
const formatCurrency = (value) => {
    if (value === null || value === undefined) {
        return '—';
    }
    return new Intl.NumberFormat('ru-RU', {
        style: 'currency',
        currency: 'RUB',
        maximumFractionDigits: 0,
    }).format(value);
};
const formatDate = (value) => {
    if (!value)
        return '—';
    const parsed = new Date(value);
    if (Number.isNaN(parsed.getTime())) {
        return value;
    }
    return parsed.toLocaleDateString('ru-RU', {
        day: 'numeric',
        month: 'long',
    });
};
const STSCard = ({ data }) => {
    const context = data.safe_to_spend_context;
    const narrative = data.safe_to_spend_narrative;
    const hasValue = typeof data.safe_to_spend_daily === 'number' && !Number.isNaN(data.safe_to_spend_daily ?? NaN);
    const cycleEndLabel = narrative?.cycle_end ? formatDate(narrative.cycle_end) : null;
    const balanceValue = narrative?.current_balance ?? data.current_balance;
    const obligationsValue = narrative?.obligations_total ?? 0;
    const spendableValue = narrative?.spendable_total ?? null;
    const isBalanceLow = hasValue && typeof balanceValue === 'number' && typeof data.safe_to_spend_daily === 'number'
        ? balanceValue < data.safe_to_spend_daily
        : false;
    return (_jsxs("div", { className: "card", children: [_jsx("h2", { children: "Safe-to-Spend" }), _jsx("p", { className: "muted", children: "\u0420\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u043E\u0432\u0430\u043D\u043D\u044B\u0439 \u0434\u043D\u0435\u0432\u043D\u043E\u0439 \u043B\u0438\u043C\u0438\u0442 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439 \u0437\u0430\u0440\u043F\u043B\u0430\u0442\u044B." }), context?.message ? (_jsx("div", { className: `callout callout--${context.state === 'missing_balance' ? 'warning' : 'info'}`, children: context.message })) : null, _jsxs("p", { className: "metric", children: [hasValue ? formatCurrency(data.safe_to_spend_daily ?? undefined) : 'Нет оценки', _jsx("span", { children: " / \u0434\u0435\u043D\u044C" })] }), cycleEndLabel ? (_jsxs("p", { className: "muted", children: ["\u0411\u044E\u0434\u0436\u0435\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u0443\u0435\u0442 \u0434\u043E ", _jsx("strong", { children: cycleEndLabel }), "."] })) : null, isBalanceLow && (_jsxs("div", { className: "callout callout--warning", children: ["\u0411\u0430\u043B\u0430\u043D\u0441 (", formatCurrency(balanceValue), ") \u043D\u0438\u0436\u0435 \u0434\u043D\u0435\u0432\u043D\u043E\u0433\u043E \u043B\u0438\u043C\u0438\u0442\u0430. \u0421\u043E\u043A\u0440\u0430\u0442\u0438\u0442\u0435 \u0442\u0440\u0430\u0442\u044B \u0441\u0435\u0433\u043E\u0434\u043D\u044F."] })), _jsxs("div", { className: "safe-obligations", children: [_jsxs("div", { children: ["\u0411\u0430\u043B\u0430\u043D\u0441: ", formatCurrency(balanceValue)] }), _jsxs("div", { children: ["\u041E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u0441\u0442\u0432\u0430 \u0432 \u0433\u043E\u0440\u0438\u0437\u043E\u043D\u0442\u0435: ", formatCurrency(obligationsValue)] }), _jsxs("div", { children: ["\u0420\u0435\u0437\u0435\u0440\u0432 \u043D\u0430 \u0446\u0435\u043B\u044C: ", formatCurrency(narrative?.goal_reserve)] }), _jsxs("div", { children: ["\u0414\u043E\u0441\u0442\u0443\u043F\u043D\u043E \u043D\u0430 \u0446\u0438\u043A\u043B: ", formatCurrency(spendableValue)] })] })] }));
};
const UpcomingEventsCard = ({ events, narrative }) => {
    const cycleEndLabel = narrative?.cycle_end ? formatDate(narrative.cycle_end) : '—';
    const items = events ?? [];
    const nextIncome = narrative?.next_income_event;
    return (_jsxs("div", { className: "card", children: [_jsxs("h3", { children: ["\u0414\u043E \u0437\u0430\u0440\u043F\u043B\u0430\u0442\u044B (", cycleEndLabel, ")"] }), _jsxs("ul", { className: "list", children: [_jsx("li", { className: "event-row", children: _jsxs("div", { className: "event-row__header", children: [_jsxs("div", { children: [_jsx("p", { className: "event-row__title", children: "\u0422\u0435\u043A\u0443\u0449\u0438\u0439 \u0431\u0430\u043B\u0430\u043D\u0441" }), _jsx("p", { className: "event-row__subtitle", children: formatDate(narrative?.cycle_start) })] }), _jsx("div", { className: "event-row__amount", children: _jsx("span", { children: formatCurrency(narrative?.current_balance) }) })] }) }), items.length > 0 ? (items.map((event, index) => (_jsx("li", { className: `event-row ${event.is_income ? 'event-row--income' : 'event-row--expense'}`, children: _jsxs("div", { className: "event-row__header", children: [_jsxs("div", { children: [_jsx("p", { className: "event-row__title", children: event.name }), _jsx("p", { className: "event-row__subtitle", children: formatDate(event.date) })] }), _jsx("div", { className: "event-row__amount", children: _jsx("span", { children: formatCurrency(event.amount) }) })] }) }, `${event.name}-${index}`)))) : (_jsx("li", { className: "muted", children: "\u041D\u0435\u0442 \u0444\u0438\u043A\u0441\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0445 \u043F\u043B\u0430\u0442\u0435\u0436\u0435\u0439 \u0432 \u044D\u0442\u043E\u043C \u0433\u043E\u0440\u0438\u0437\u043E\u043D\u0442\u0435." })), nextIncome ? (_jsx("li", { className: "event-row event-row--income", children: _jsxs("div", { className: "event-row__header", children: [_jsxs("div", { children: [_jsx("p", { className: "event-row__title", children: nextIncome.label ?? 'Доход' }), _jsx("p", { className: "event-row__subtitle", children: formatDate(nextIncome.next_occurrence) })] }), _jsx("div", { className: "event-row__amount", children: _jsx("span", { children: formatCurrency(nextIncome.amount) }) })] }) })) : null] })] }));
};
const BudgetCard = ({ budget, narrative }) => (_jsxs("div", { className: "card", children: [_jsxs("h3", { children: ["\u0412\u0430\u0448 \u0431\u044E\u0434\u0436\u0435\u0442 \u043D\u0430 \u0436\u0438\u0437\u043D\u044C (", narrative?.days_in_cycle ?? 0, " \u0434.)"] }), _jsx("p", { className: "muted", children: "\u041F\u0440\u0435\u0434\u043B\u0430\u0433\u0430\u0435\u043C \u0442\u0430\u043A \u0440\u0430\u0441\u043F\u0440\u0435\u0434\u0435\u043B\u0438\u0442\u044C \u0441\u0432\u043E\u0431\u043E\u0434\u043D\u044B\u0435 \u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0430 \u0434\u043E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0439 \u0432\u044B\u043F\u043B\u0430\u0442\u044B." }), _jsxs("ul", { className: "list", children: [_jsx("li", { className: "event-row event-row--expense", children: _jsxs("div", { className: "event-row__header", children: [_jsx("div", { children: _jsx("p", { className: "event-row__title", children: "\u0412\u0441\u0435\u0433\u043E \u0434\u043E\u0441\u0442\u0443\u043F\u043D\u043E" }) }), _jsx("div", { className: "event-row__amount", children: _jsx("strong", { children: formatCurrency(narrative?.spendable_total) }) })] }) }), budget && budget.length > 0 ? (budget.map((item, index) => (_jsx("li", { className: "event-row event-row--expense", children: _jsxs("div", { className: "event-row__header", children: [_jsx("div", { children: _jsx("p", { className: "event-row__title", children: item.category }) }), _jsx("div", { className: "event-row__amount", children: _jsx("span", { children: formatCurrency(item.amount) }) })] }) }, `${item.category}-${index}`)))) : (_jsx("li", { className: "muted", children: "\u041D\u0435\u0442 \u043F\u0435\u0440\u0435\u043C\u0435\u043D\u043D\u044B\u0445 \u0442\u0440\u0430\u0442 \u0434\u043B\u044F \u0440\u0430\u0441\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u044F." })), _jsx("li", { className: "event-row event-row--income", children: _jsxs("div", { className: "event-row__header", children: [_jsx("div", { children: _jsx("p", { className: "event-row__title", children: "\u0420\u0435\u0437\u0435\u0440\u0432 \u043D\u0430 \u0446\u0435\u043B\u044C" }) }), _jsx("div", { className: "event-row__amount", children: _jsx("span", { children: formatCurrency(narrative?.goal_reserve) }) })] }) })] })] }));
const RecurringEventsCard = ({ events }) => (_jsxs("div", { className: "card", children: [_jsx("h3", { children: "\u0424\u0438\u043D\u0430\u043D\u0441\u043E\u0432\u044B\u0435 \u043F\u0440\u0438\u0432\u044B\u0447\u043A\u0438" }), _jsx("ul", { className: "list", children: events && events.length > 0 ? (events.map((event, index) => (_jsx("li", { className: `event-row ${event.is_income ? 'event-row--income' : 'event-row--expense'}`, children: _jsxs("div", { className: "event-row__header", children: [_jsxs("div", { children: [_jsx("p", { className: "event-row__title", children: event.name }), _jsxs("p", { className: "event-row__subtitle", children: ["\u0421\u043B\u0435\u0434\u0443\u044E\u0449\u0435\u0435: ", formatDate(event.next_date)] })] }), _jsx("div", { className: "event-row__amount", children: _jsx("span", { children: formatCurrency(event.amount) }) })] }) }, `${event.name}-${index}`)))) : (_jsx("li", { className: "muted", children: "\u041F\u043E\u043A\u0430 \u043D\u0435 \u043D\u0430\u0448\u043B\u0438 \u043F\u043E\u0432\u0442\u043E\u0440\u044F\u044E\u0449\u0438\u0445\u0441\u044F \u0441\u043E\u0431\u044B\u0442\u0438\u0439." })) })] }));
export const DashboardPage = () => {
    const { userId } = useUser();
    const { notifyError } = useNotifications();
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    useEffect(() => {
        if (!userId)
            return;
        const load = async () => {
            try {
                setLoading(true);
                const payload = await getDashboard(userId);
                setData(payload);
            }
            catch (error) {
                console.error(error);
                notifyError('Не удалось загрузить данные для дашборда.');
            }
            finally {
                setLoading(false);
            }
        };
        load();
    }, [notifyError, userId]);
    if (loading) {
        return (_jsx("div", { className: "app-main", children: _jsx("div", { className: "card", children: _jsx("p", { children: "\u0410\u043D\u0430\u043B\u0438\u0437\u0438\u0440\u0443\u0435\u043C \u0432\u0430\u0448\u0438 \u0444\u0438\u043D\u0430\u043D\u0441\u044B \u0438 \u0441\u0442\u0440\u043E\u0438\u043C \u043F\u0440\u043E\u0433\u043D\u043E\u0437\u044B..." }) }) }));
    }
    if (!data) {
        return (_jsx("div", { className: "app-main", children: _jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u041D\u0435\u0442 \u0434\u0430\u043D\u043D\u044B\u0445" }), _jsx("p", { children: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u0430\u043D\u0430\u043B\u0438\u0442\u0438\u043A\u0443. \u041F\u0440\u043E\u0439\u0434\u0438\u0442\u0435 \u043E\u043D\u0431\u043E\u0440\u0434\u0438\u043D\u0433 \u0435\u0449\u0451 \u0440\u0430\u0437." })] }) }));
    }
    return (_jsxs("div", { className: "app-main", children: [_jsx(STSCard, { data: data }), _jsxs("div", { className: "grid grid-two", children: [_jsx(UpcomingEventsCard, { events: data.upcoming_events, narrative: data.safe_to_spend_narrative }), _jsx(BudgetCard, { budget: data.budget_breakdown, narrative: data.safe_to_spend_narrative })] }), _jsx(RecurringEventsCard, { events: data.recurring_events })] }));
};
export default DashboardPage;
</file>

<file path="src/pages/DashboardPage.tsx">
import React, { useEffect, useState } from 'react';
import { getDashboard } from '../api/client';
import { useUser } from '../state/useUser';
import { useNotifications } from '../state/notifications';
import type { DashboardResponse } from '../types/dashboard';
import { BanksOverviewCard } from '../components/BanksOverviewCard';

const formatCurrency = (value?: number | null) => {
  if (value === null || value === undefined) return '—';
  return new Intl.NumberFormat('ru-RU', {
    style: 'currency',
    currency: 'RUB',
    maximumFractionDigits: 0,
  }).format(value);
};

const formatDate = (value?: string | null) => {
  if (!value) return '—';
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    return value;
  }
  return parsed.toLocaleDateString('ru-RU', { day: 'numeric', month: 'long' });
};

const STSCard: React.FC<{ data: DashboardResponse }> = ({ data }) => {
  const nextIncomeLabel = data.next_income_date ? formatDate(data.next_income_date) : 'в ближайшие 30 дней';

  return (
    <div className="card">
      <h2>Safe-to-Spend</h2>
      <p className="muted">Рекомендованный дневной лимит до следующей зарплаты ({nextIncomeLabel}).</p>
      <p className="metric">
        {formatCurrency(data.safe_to_spend_daily)}
        <span> / день</span>
      </p>
      <div className="safe-obligations">
        <div>
          Этот бюджет рассчитан на <strong>{data.days_until_next_income}</strong> дней.
        </div>
        <div>Он учитывает все обязательные платежи в этом периоде.</div>
      </div>
    </div>
  );
};

export const DashboardPage: React.FC = () => {
  const { userId } = useUser();
  const { notifyError } = useNotifications();
  const [data, setData] = useState<DashboardResponse | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!userId) return;
    const load = async () => {
      try {
        setLoading(true);
        const payload = await getDashboard(userId);
        setData(payload);
      } catch (error) {
        console.error(error);
        notifyError('Не удалось загрузить данные для дашборда.');
      } finally {
        setLoading(false);
      }
    };
    load();
  }, [notifyError, userId]);

  if (loading) {
    return (
      <div className="app-main">
        <div className="card">
          <p>Анализируем ваши финансы и строим прогнозы...</p>
        </div>
      </div>
    );
  }

  if (!data) {
    return (
      <div className="app-main">
        <div className="card">
          <h2>Нет данных</h2>
          <p>Не удалось загрузить аналитику. Возможно, нужно пройти онбординг заново.</p>
        </div>
      </div>
    );
  }

  return (
    <div className="app-main">
      <STSCard data={data} />
      <BanksOverviewCard totalBalance={data.total_balance} bankStatuses={data.bank_statuses} />
    </div>
  );
};

export default DashboardPage;
</file>

<file path="src/pages/DebtGoalPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { getCredits, saveGoal } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';
const paceOptions = [
    { value: 'conservative', label: 'Мягкий' },
    { value: 'optimal', label: 'Оптимальный' },
    { value: 'fast', label: 'Агрессивный' },
];
export const DebtGoalPage = () => {
    const { userId } = useUser();
    const { notifyError, notifySuccess } = useNotifications();
    const navigate = useNavigate();
    const [credits, setCredits] = useState([]);
    const [selected, setSelected] = useState({});
    const [pace, setPace] = useState('optimal');
    const [timeline, setTimeline] = useState('12');
    const [loading, setLoading] = useState(false);
    const [saving, setSaving] = useState(false);
    useEffect(() => {
        const load = async () => {
            if (!userId)
                return;
            try {
                setLoading(true);
                const response = await getCredits(userId);
                setCredits(response.credits ?? []);
            }
            catch (error) {
                console.error(error);
                notifyError('Не удалось получить список кредитов');
            }
            finally {
                setLoading(false);
            }
        };
        load();
    }, [notifyError, userId]);
    const toggle = (creditId) => {
        setSelected((prev) => ({ ...prev, [creditId]: !prev[creditId] }));
    };
    const handleSubmit = async (event) => {
        event.preventDefault();
        if (!userId)
            return;
        const chosen = Object.entries(selected)
            .filter(([, checked]) => checked)
            .map(([creditId]) => creditId);
        try {
            setSaving(true);
            await saveGoal({
                user_id: userId,
                goal_type: 'pay_debts',
                goal_details: {
                    close_speed: pace,
                    close_loan_ids: chosen,
                    timeline_months: Number(timeline),
                },
            });
            notifySuccess('Цель сохранена');
            navigate('/ingest');
        }
        catch (error) {
            console.error(error);
            notifyError('Не удалось сохранить цель');
        }
        finally {
            setSaving(false);
        }
    };
    return (_jsx("div", { className: "app-main", children: _jsxs("form", { className: "card", onSubmit: handleSubmit, children: [_jsx("h2", { children: "\u041A\u0430\u043A\u0438\u0435 \u043A\u0440\u0435\u0434\u0438\u0442\u044B \u0437\u0430\u043A\u0440\u044B\u0432\u0430\u0435\u043C?" }), loading ? _jsx("p", { children: "\u0417\u0430\u0433\u0440\u0443\u0437\u043A\u0430 \u043A\u0440\u0435\u0434\u0438\u0442\u043E\u0432..." }) : null, _jsx("ul", { className: "list", children: credits.map((credit, index) => {
                        const creditId = credit.id ?? `${credit.bank_id}-${index}`;
                        return (_jsx("li", { children: _jsxs("label", { style: { display: 'flex', gap: 12 }, children: [_jsx("input", { type: "checkbox", checked: selected[creditId] ?? false, onChange: () => toggle(creditId) }), _jsxs("div", { children: [_jsx("strong", { children: credit.name ?? `Кредит ${index + 1}` }), _jsxs("div", { style: { fontSize: 14, color: '#475569' }, children: ["\u0411\u0430\u043B\u0430\u043D\u0441: ", credit.balance ?? '—', " | \u041F\u043B\u0430\u0442\u0451\u0436: ", credit.min_payment ?? '—'] })] })] }) }, creditId));
                    }) }), _jsx("label", { children: "\u0422\u0435\u043C\u043F \u043F\u043E\u0433\u0430\u0448\u0435\u043D\u0438\u044F" }), _jsx("select", { value: pace, onChange: (event) => setPace(event.target.value), children: paceOptions.map((opt) => (_jsx("option", { value: opt.value, children: opt.label }, opt.value))) }), _jsx("label", { children: "\u0413\u043E\u0440\u0438\u0437\u043E\u043D\u0442, \u043C\u0435\u0441\u044F\u0446\u0435\u0432" }), _jsx("input", { value: timeline, onChange: (event) => setTimeline(event.target.value), className: "text-input" }), _jsx("button", { type: "submit", className: "btn", disabled: saving, children: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0438 \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C" })] }) }));
};
</file>

<file path="src/pages/DebtGoalPage.tsx">
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { getCredits, saveGoal } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';

type Credit = {
  name?: string;
  balance?: number;
  min_payment?: number;
  stress_score?: number;
  bank_id?: string;
  id?: string;
};

const paceOptions = [
  { value: 'conservative', label: 'Мягкий' },
  { value: 'optimal', label: 'Оптимальный' },
  { value: 'fast', label: 'Агрессивный' },
];

export const DebtGoalPage: React.FC = () => {
  const { userId } = useUser();
  const { notifyError, notifySuccess } = useNotifications();
  const navigate = useNavigate();
  const [credits, setCredits] = useState<Credit[]>([]);
  const [selected, setSelected] = useState<Record<string, boolean>>({});
  const [pace, setPace] = useState('optimal');
  const [timeline, setTimeline] = useState('12');
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);

  useEffect(() => {
    const load = async () => {
      if (!userId) return;
      try {
        setLoading(true);
        const response = await getCredits(userId);
        setCredits(response.credits ?? []);
      } catch (error) {
        console.error(error);
        notifyError('Не удалось получить список кредитов');
      } finally {
        setLoading(false);
      }
    };
    load();
  }, [notifyError, userId]);

  const toggle = (creditId: string) => {
    setSelected((prev) => ({ ...prev, [creditId]: !prev[creditId] }));
  };

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (!userId) return;
    const chosen = Object.entries(selected)
      .filter(([, checked]) => checked)
      .map(([creditId]) => creditId);
    try {
      setSaving(true);
      await saveGoal({
        user_id: userId,
        goal_type: 'pay_debts',
        goal_details: {
          close_speed: pace,
          close_loan_ids: chosen,
          timeline_months: Number(timeline),
        },
      });
      notifySuccess('Цель сохранена');
      navigate('/ingest');
    } catch (error) {
      console.error(error);
      notifyError('Не удалось сохранить цель');
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="app-main">
      <form className="card" onSubmit={handleSubmit}>
        <h2>Какие кредиты закрываем?</h2>
        {loading ? <p>Загрузка кредитов...</p> : null}
        <ul className="list">
          {credits.map((credit, index) => {
            const creditId = credit.id ?? `${credit.bank_id}-${index}`;
            return (
              <li key={creditId}>
                <label style={{ display: 'flex', gap: 12 }}>
                  <input type="checkbox" checked={selected[creditId] ?? false} onChange={() => toggle(creditId)} />
                  <div>
                    <strong>{credit.name ?? `Кредит ${index + 1}`}</strong>
                    <div style={{ fontSize: 14, color: '#475569' }}>
                      Баланс: {credit.balance ?? '—'} | Платёж: {credit.min_payment ?? '—'}
                    </div>
                  </div>
                </label>
              </li>
            );
          })}
        </ul>
        <label>Темп погашения</label>
        <select value={pace} onChange={(event) => setPace(event.target.value)}>{paceOptions.map((opt) => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}</select>
        <label>Горизонт, месяцев</label>
        <input value={timeline} onChange={(event) => setTimeline(event.target.value)} className="text-input" />
        <button type="submit" className="btn" disabled={saving}>
          Сохранить и продолжить
        </button>
      </form>
    </div>
  );
};
</file>

<file path="src/pages/GoalsLandingPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useNavigate } from 'react-router-dom';
export const GoalsLandingPage = () => {
    const navigate = useNavigate();
    return (_jsxs("div", { className: "app-main", children: [_jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0428\u0430\u0433 5. \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0446\u0435\u043B\u044C" }), _jsx("p", { children: "\u0426\u0435\u043B\u044C \u0432\u043B\u0438\u044F\u0435\u0442 \u043D\u0430 \u0430\u043D\u0430\u043B\u0438\u0442\u0438\u043A\u0443 \u0438 \u0440\u0435\u043A\u043E\u043C\u0435\u043D\u0434\u0430\u0446\u0438\u0438." })] }), _jsxs("div", { className: "grid grid-two", children: [_jsxs("div", { className: "card", children: [_jsx("h3", { children: "\u041D\u0430\u043A\u043E\u043F\u0438\u0442\u044C \u0441\u0431\u0435\u0440\u0435\u0436\u0435\u043D\u0438\u044F" }), _jsx("p", { children: "\u041F\u043B\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u043F\u043E\u0434\u0443\u0448\u043A\u0438 \u0431\u0435\u0437\u043E\u043F\u0430\u0441\u043D\u043E\u0441\u0442\u0438 \u0438 \u043F\u0440\u043E\u0433\u043D\u043E\u0437 \u0432\u0435\u0440\u043E\u044F\u0442\u043D\u043E\u0441\u0442\u0438 \u043D\u0430\u043A\u043E\u043F\u043B\u0435\u043D\u0438\u044F." }), _jsx("button", { className: "btn", onClick: () => navigate('/goals/save'), children: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C" })] }), _jsxs("div", { className: "card", children: [_jsx("h3", { children: "\u0417\u0430\u043A\u0440\u044B\u0442\u044C \u043A\u0440\u0435\u0434\u0438\u0442\u044B" }), _jsx("p", { children: "\u041E\u0442\u0441\u043B\u0435\u0436\u0438\u0432\u0430\u043D\u0438\u0435 \u043A\u0440\u0435\u0434\u0438\u0442\u043E\u0432, \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0438 \u0432\u044B\u043F\u043B\u0430\u0442 \u0438 \u043F\u0440\u0438\u043E\u0440\u0438\u0442\u0438\u0437\u0430\u0446\u0438\u044F." }), _jsx("button", { className: "btn", onClick: () => navigate('/goals/debts'), children: "\u041F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C" })] })] })] }));
};
</file>

<file path="src/pages/GoalsLandingPage.tsx">
import React from 'react';
import { useNavigate } from 'react-router-dom';

export const GoalsLandingPage: React.FC = () => {
  const navigate = useNavigate();

  return (
    <div className="app-main">
      <div className="card">
        <h2>Шаг 5. Выберите цель</h2>
        <p>Цель влияет на аналитику и рекомендации.</p>
      </div>
      <div className="grid grid-two">
        <div className="card">
          <h3>Накопить сбережения</h3>
          <p>Планирование подушки безопасности и прогноз вероятности накопления.</p>
          <button className="btn" onClick={() => navigate('/goals/save')}>
            Продолжить
          </button>
        </div>
        <div className="card">
          <h3>Закрыть кредиты</h3>
          <p>Отслеживание кредитов, сценарии выплат и приоритизация.</p>
          <button className="btn" onClick={() => navigate('/goals/debts')}>
            Продолжить
          </button>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/pages/IngestionPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { commitOnboarding, runIngestion } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';
export const IngestionPage = () => {
    const { userId } = useUser();
    const { notifyError, notifySuccess } = useNotifications();
    const navigate = useNavigate();
    const [ingesting, setIngesting] = useState(false);
    const [committing, setCommitting] = useState(false);
    const [statuses, setStatuses] = useState([]);
    const [ingestDone, setIngestDone] = useState(false);
    const [commitDone, setCommitDone] = useState(false);
    const handleIngest = async () => {
        if (!userId)
            return;
        try {
            setIngesting(true);
            const response = await runIngestion({ user_id: userId });
            setStatuses(response.bank_statuses ?? []);
            setIngestDone(true);
            notifySuccess('Загрузка транзакций завершена');
        }
        catch (error) {
            console.error(error);
            notifyError('Ошибка при загрузке транзакций');
        }
        finally {
            setIngesting(false);
        }
    };
    const handleCommit = async () => {
        if (!userId)
            return;
        try {
            setCommitting(true);
            await commitOnboarding({ user_id: userId });
            setCommitDone(true);
            notifySuccess('Онбординг завершён');
        }
        catch (error) {
            console.error(error);
            notifyError('Не удалось завершить онбординг');
        }
        finally {
            setCommitting(false);
        }
    };
    return (_jsx("div", { className: "app-main", children: _jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0428\u0430\u0433 8. \u0418\u043D\u0436\u0435\u0441\u0442 \u0438 \u043A\u043E\u043C\u043C\u0438\u0442" }), _jsx("p", { children: "\u0421\u043E\u0431\u0438\u0440\u0430\u0435\u043C \u0442\u0440\u0430\u043D\u0437\u0430\u043A\u0446\u0438\u0438 \u0441\u043E \u0432\u0441\u0435\u0445 \u0431\u0430\u043D\u043A\u043E\u0432 \u0438 \u0444\u0438\u043A\u0441\u0438\u0440\u0443\u0435\u043C \u0441\u0435\u0441\u0441\u0438\u044E." }), _jsx("button", { className: "btn", onClick: handleIngest, disabled: ingesting || ingestDone, children: ingestDone ? 'Готово' : 'Загрузить данные' }), statuses.length ? (_jsx("ul", { className: "list", children: statuses.map((status) => (_jsxs("li", { children: [status.bank_name, ": ", status.status, " \u2014 ", status.message] }, status.bank_name))) })) : null, ingestDone ? (_jsx("button", { className: "btn", onClick: handleCommit, disabled: committing || commitDone, children: commitDone ? 'Сохранено' : 'Commit onboarding' })) : null, commitDone ? (_jsx("button", { className: "btn", style: { marginTop: 12 }, onClick: () => navigate('/dashboard'), children: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0430\u043D\u0430\u043B\u0438\u0442\u0438\u043A\u0435" })) : null] }) }));
};
</file>

<file path="src/pages/IngestionPage.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { commitOnboarding, runIngestion } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';

type BankStatus = {
  bank_name: string;
  status: string;
  message?: string;
};

export const IngestionPage: React.FC = () => {
  const { userId } = useUser();
  const { notifyError, notifySuccess } = useNotifications();
  const navigate = useNavigate();
  const [ingesting, setIngesting] = useState(false);
  const [committing, setCommitting] = useState(false);
  const [statuses, setStatuses] = useState<BankStatus[]>([]);
  const [ingestDone, setIngestDone] = useState(false);
  const [commitDone, setCommitDone] = useState(false);

  const handleIngest = async () => {
    if (!userId) return;
    try {
      setIngesting(true);
      const response = await runIngestion({ user_id: userId });
      setStatuses(response.bank_statuses ?? []);
      setIngestDone(true);
      notifySuccess('Загрузка транзакций завершена');
    } catch (error) {
      console.error(error);
      notifyError('Ошибка при загрузке транзакций');
    } finally {
      setIngesting(false);
    }
  };

  const handleCommit = async () => {
    if (!userId) return;
    try {
      setCommitting(true);
      await commitOnboarding({ user_id: userId });
      setCommitDone(true);
      notifySuccess('Онбординг завершён');
    } catch (error) {
      console.error(error);
      notifyError('Не удалось завершить онбординг');
    } finally {
      setCommitting(false);
    }
  };

  return (
    <div className="app-main">
      <div className="card">
        <h2>Шаг 8. Инжест и коммит</h2>
        <p>Собираем транзакции со всех банков и фиксируем сессию.</p>
        <button className="btn" onClick={handleIngest} disabled={ingesting || ingestDone}>
          {ingestDone ? 'Готово' : 'Загрузить данные'}
        </button>
        {statuses.length ? (
          <ul className="list">
            {statuses.map((status) => (
              <li key={status.bank_name}>
                {status.bank_name}: {status.status} — {status.message}
              </li>
            ))}
          </ul>
        ) : null}
        {ingestDone ? (
          <button className="btn" onClick={handleCommit} disabled={committing || commitDone}>
            {commitDone ? 'Сохранено' : 'Commit onboarding'}
          </button>
        ) : null}
        {commitDone ? (
          <button className="btn" style={{ marginTop: 12 }} onClick={() => navigate('/dashboard')}>
            Перейти к аналитике
          </button>
        ) : null}
      </div>
    </div>
  );
};
</file>

<file path="src/pages/SaveGoalPage.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { saveGoal } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';
const paceOptions = [
    { value: 'conservative', label: 'Консервативный' },
    { value: 'optimal', label: 'Оптимальный' },
    { value: 'fast', label: 'Быстрый' },
];
export const SaveGoalPage = () => {
    const { userId } = useUser();
    const { notifyError, notifySuccess } = useNotifications();
    const navigate = useNavigate();
    const [amount, setAmount] = useState('100000');
    const [pace, setPace] = useState('optimal');
    const [monthly, setMonthly] = useState('20000');
    const [saving, setSaving] = useState(false);
    const handleSubmit = async (event) => {
        event.preventDefault();
        if (!userId)
            return;
        try {
            setSaving(true);
            await saveGoal({
                user_id: userId,
                goal_type: 'save_money',
                goal_details: {
                    save_amount: Number(amount),
                    save_speed: pace,
                    monthly_contribution: Number(monthly),
                },
            });
            notifySuccess('Цель сохранена');
            navigate('/ingest');
        }
        catch (error) {
            console.error(error);
            notifyError('Не удалось сохранить цель');
        }
        finally {
            setSaving(false);
        }
    };
    return (_jsx("div", { className: "app-main", children: _jsxs("form", { className: "card", onSubmit: handleSubmit, children: [_jsx("h2", { children: "\u0421\u043A\u043E\u043B\u044C\u043A\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u043E\u0442\u043B\u043E\u0436\u0438\u0442\u044C?" }), _jsx("label", { children: "\u0426\u0435\u043B\u0435\u0432\u0430\u044F \u0441\u0443\u043C\u043C\u0430, \u20BD" }), _jsx("input", { value: amount, onChange: (event) => setAmount(event.target.value), className: "text-input" }), _jsx("label", { children: "\u0422\u0435\u043C\u043F \u043D\u0430\u043A\u043E\u043F\u043B\u0435\u043D\u0438\u044F" }), _jsx("select", { value: pace, onChange: (event) => setPace(event.target.value), children: paceOptions.map((opt) => (_jsx("option", { value: opt.value, children: opt.label }, opt.value))) }), _jsx("label", { children: "\u0415\u0436\u0435\u043C\u0435\u0441\u044F\u0447\u043D\u044B\u0439 \u0432\u043A\u043B\u0430\u0434, \u20BD" }), _jsx("input", { value: monthly, onChange: (event) => setMonthly(event.target.value), className: "text-input" }), _jsx("button", { type: "submit", className: "btn", disabled: saving, children: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0438 \u043F\u0440\u043E\u0434\u043E\u043B\u0436\u0438\u0442\u044C" })] }) }));
};
</file>

<file path="src/pages/SaveGoalPage.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { saveGoal } from '../api/client';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';

const paceOptions = [
  { value: 'conservative', label: 'Консервативный' },
  { value: 'optimal', label: 'Оптимальный' },
  { value: 'fast', label: 'Быстрый' },
];

export const SaveGoalPage: React.FC = () => {
  const { userId } = useUser();
  const { notifyError, notifySuccess } = useNotifications();
  const navigate = useNavigate();
  const [amount, setAmount] = useState('100000');
  const [pace, setPace] = useState('optimal');
  const [monthly, setMonthly] = useState('20000');
  const [saving, setSaving] = useState(false);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    if (!userId) return;
    try {
      setSaving(true);
      await saveGoal({
        user_id: userId,
        goal_type: 'save_money',
        goal_details: {
          save_amount: Number(amount),
          save_speed: pace,
          monthly_contribution: Number(monthly),
        },
      });
      notifySuccess('Цель сохранена');
      navigate('/ingest');
    } catch (error) {
      console.error(error);
      notifyError('Не удалось сохранить цель');
    } finally {
      setSaving(false);
    }
  };

  return (
    <div className="app-main">
      <form className="card" onSubmit={handleSubmit}>
        <h2>Сколько хотите отложить?</h2>
        <label>Целевая сумма, ₽</label>
        <input value={amount} onChange={(event) => setAmount(event.target.value)} className="text-input" />
        <label>Темп накопления</label>
        <select value={pace} onChange={(event) => setPace(event.target.value)}>
          {paceOptions.map((opt) => (
            <option key={opt.value} value={opt.value}>
              {opt.label}
            </option>
          ))}
        </select>
        <label>Ежемесячный вклад, ₽</label>
        <input value={monthly} onChange={(event) => setMonthly(event.target.value)} className="text-input" />
        <button type="submit" className="btn" disabled={saving}>
          Сохранить и продолжить
        </button>
      </form>
    </div>
  );
};
</file>

<file path="src/pages/UserIdPage.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { UserIdForm } from '../components/UserIdForm';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';
export const UserIdPage = () => {
    const { userId, userName, setInitialUserData } = useUser();
    const { notifySuccess, notifyError } = useNotifications();
    const navigate = useNavigate();
    const [isSubmitting, setIsSubmitting] = useState(false);
    const handleSubmit = async (nextId, nextName) => {
        try {
            setIsSubmitting(true);
            setInitialUserData(nextId.toLowerCase(), nextName);
            notifySuccess('ID и имя сохранены');
            navigate('/banks');
        }
        catch (error) {
            console.error(error);
            notifyError('Не удалось сохранить данные');
        }
        finally {
            setIsSubmitting(false);
        }
    };
    return (_jsx("div", { className: "app-main", children: _jsx(UserIdForm, { defaultUserId: userId, defaultUserName: userName, onSubmit: handleSubmit, isSubmitting: isSubmitting }) }));
};
</file>

<file path="src/pages/UserIdPage.tsx">
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { UserIdForm } from '../components/UserIdForm';
import { useNotifications } from '../state/notifications';
import { useUser } from '../state/useUser';

export const UserIdPage: React.FC = () => {
  const { userId, userName, setInitialUserData } = useUser();
  const { notifySuccess, notifyError } = useNotifications();
  const navigate = useNavigate();
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (nextId: string, nextName: string) => {
    try {
      setIsSubmitting(true);
      setInitialUserData(nextId.toLowerCase(), nextName);
      notifySuccess('ID и имя сохранены');
      navigate('/banks');
    } catch (error) {
      console.error(error);
      notifyError('Не удалось сохранить данные');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="app-main">
      <UserIdForm
        defaultUserId={userId}
        defaultUserName={userName}
        onSubmit={handleSubmit}
        isSubmitting={isSubmitting}
      />
    </div>
  );
};
</file>

<file path="src/state/notifications.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useMemo, useState } from 'react';
const NotificationsContext = createContext(undefined);
export const NotificationsProvider = ({ children }) => {
    const [items, setItems] = useState([]);
    const dismiss = useCallback((id) => {
        setItems((prev) => prev.filter((item) => item.id !== id));
    }, []);
    const notify = useCallback((message, type = 'info') => {
        const id = `${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
        setItems((prev) => [...prev, { id, message, type }]);
        window.setTimeout(() => dismiss(id), 5000);
    }, [dismiss]);
    const contextValue = useMemo(() => ({
        notify,
        notifyError: (msg) => notify(msg, 'error'),
        notifySuccess: (msg) => notify(msg, 'success'),
    }), [notify]);
    return (_jsxs(NotificationsContext.Provider, { value: contextValue, children: [children, _jsx("div", { className: "toast-stack", role: "status", "aria-live": "polite", children: items.map((item) => (_jsx("div", { className: `toast toast-${item.type}`, children: item.message }, item.id))) })] }));
};
export const useNotifications = () => {
    const ctx = useContext(NotificationsContext);
    if (!ctx) {
        throw new Error('useNotifications must be used inside NotificationsProvider');
    }
    return ctx;
};
</file>

<file path="src/state/notifications.tsx">
import React, { createContext, useCallback, useContext, useMemo, useState } from 'react';

type Notification = {
  id: string;
  message: string;
  type: 'info' | 'error' | 'success';
};

type NotificationsContextValue = {
  notify: (message: string, type?: Notification['type']) => void;
  notifyError: (message: string) => void;
  notifySuccess: (message: string) => void;
};

const NotificationsContext = createContext<NotificationsContextValue | undefined>(undefined);

export const NotificationsProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const [items, setItems] = useState<Notification[]>([]);

  const dismiss = useCallback((id: string) => {
    setItems((prev) => prev.filter((item) => item.id !== id));
  }, []);

  const notify = useCallback(
    (message: string, type: Notification['type'] = 'info') => {
      const id = `${Date.now()}-${Math.random().toString(36).slice(2, 6)}`;
      setItems((prev) => [...prev, { id, message, type }]);
      window.setTimeout(() => dismiss(id), 5000);
    },
    [dismiss]
  );

  const contextValue = useMemo<NotificationsContextValue>(
    () => ({
      notify,
      notifyError: (msg: string) => notify(msg, 'error'),
      notifySuccess: (msg: string) => notify(msg, 'success'),
    }),
    [notify]
  );

  return (
    <NotificationsContext.Provider value={contextValue}>
      {children}
      <div className="toast-stack" role="status" aria-live="polite">
        {items.map((item) => (
          <div key={item.id} className={`toast toast-${item.type}`}>
            {item.message}
          </div>
        ))}
      </div>
    </NotificationsContext.Provider>
  );
};

export const useNotifications = (): NotificationsContextValue => {
  const ctx = useContext(NotificationsContext);
  if (!ctx) {
    throw new Error('useNotifications must be used inside NotificationsProvider');
  }
  return ctx;
};
</file>

<file path="src/state/useUser.js">
import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';
import { getBanks } from '../api/client';
const STORAGE_KEY = 'finpulse:userId';
const USER_NAME_KEY = 'finpulse:userName';
const CONSENTS_KEY = 'finpulse:consents';
const UserContext = createContext(undefined);
const parseStoredConsents = () => {
    try {
        const serialized = localStorage.getItem(CONSENTS_KEY);
        if (!serialized) {
            return [];
        }
        const raw = JSON.parse(serialized);
        if (Array.isArray(raw)) {
            return raw.filter((item) => item && typeof item.bankId === 'string');
        }
        return [];
    }
    catch {
        return [];
    }
};
export const UserProvider = ({ children }) => {
    const [userId, setUserIdState] = useState(() => localStorage.getItem(STORAGE_KEY));
    const [userName, setUserNameState] = useState(() => localStorage.getItem(USER_NAME_KEY));
    const [consents, setConsents] = useState(parseStoredConsents);
    const [banks, setBanks] = useState([]);
    const [isFetchingBanks, setIsFetchingBanks] = useState(false);
    const setInitialUserData = useCallback((nextId, nextName) => {
        localStorage.setItem(STORAGE_KEY, nextId);
        setUserIdState(nextId);
        localStorage.setItem(USER_NAME_KEY, nextName);
        setUserNameState(nextName);
    }, []);
    const clearUser = useCallback(() => {
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(USER_NAME_KEY);
        localStorage.removeItem(CONSENTS_KEY);
        setUserIdState(null);
        setUserNameState(null);
        setConsents([]);
        setBanks([]);
    }, []);
    const upsertConsent = useCallback((update) => {
        setConsents((prev) => {
            const next = [...prev];
            const index = next.findIndex((item) => item.bankId === update.bankId);
            const payload = {
                ...(index >= 0 ? next[index] : {}),
                ...update,
                lastUpdated: Date.now(),
            };
            if (index >= 0) {
                next[index] = payload;
            }
            else {
                next.push(payload);
            }
            localStorage.setItem(CONSENTS_KEY, JSON.stringify(next));
            return next;
        });
    }, []);
    const refreshBanks = useCallback(async () => {
        if (!userId) {
            setBanks([]);
            return;
        }
        try {
            setIsFetchingBanks(true);
            const response = await getBanks(userId);
            setBanks(response.banks ?? []);
        }
        catch (error) {
            console.error('Failed to fetch banks', error);
        }
        finally {
            setIsFetchingBanks(false);
        }
    }, [userId]);
    useEffect(() => {
        if (userId) {
            refreshBanks();
        }
    }, [userId, refreshBanks]);
    const value = useMemo(() => ({
        userId,
        userName,
        setInitialUserData,
        clearUser,
        consents,
        upsertConsent,
        banks,
        refreshBanks,
        isFetchingBanks,
    }), [banks, clearUser, consents, isFetchingBanks, refreshBanks, upsertConsent, setInitialUserData, userId, userName]);
    return _jsx(UserContext.Provider, { value: value, children: children });
};
export const useUser = () => {
    const ctx = useContext(UserContext);
    if (!ctx) {
        throw new Error('useUser must be used inside UserProvider');
    }
    return ctx;
};
</file>

<file path="src/state/useUser.tsx">
import React, { createContext, useCallback, useContext, useEffect, useMemo, useState } from 'react';
import { getBanks } from '../api/client';

export type ConsentState = {
  bankId: string;
  requestId?: string;
  consentId?: string;
  status?: string;
  approvalUrl?: string;
  lastUpdated: number;
};

export type BankSummary = {
  id: string;
  name: string;
  connected: boolean;
  baseUrl?: string | null;
  status?: string;
  error?: string;
};

type UserContextValue = {
  userId: string | null;
  userName: string | null;
  setInitialUserData: (nextId: string, nextName: string) => void;
  clearUser: () => void;
  consents: ConsentState[];
  upsertConsent: (consent: Omit<ConsentState, 'lastUpdated'>) => void;
  banks: BankSummary[];
  refreshBanks: () => Promise<void>;
  isFetchingBanks: boolean;
};

const STORAGE_KEY = 'finpulse:userId';
const USER_NAME_KEY = 'finpulse:userName';
const CONSENTS_KEY = 'finpulse:consents';

const UserContext = createContext<UserContextValue | undefined>(undefined);

const parseStoredConsents = (): ConsentState[] => {
  try {
    const serialized = localStorage.getItem(CONSENTS_KEY);
    if (!serialized) {
      return [];
    }
    const raw = JSON.parse(serialized);
    if (Array.isArray(raw)) {
      return raw.filter(
        (item) => item && typeof item.bankId === 'string'
      ) as ConsentState[];
    }
    return [];
  } catch {
    return [];
  }
};

export const UserProvider: React.FC<React.PropsWithChildren> = ({ children }) => {
  const [userId, setUserIdState] = useState<string | null>(() => localStorage.getItem(STORAGE_KEY));
  const [userName, setUserNameState] = useState<string | null>(() => localStorage.getItem(USER_NAME_KEY));
  const [consents, setConsents] = useState<ConsentState[]>(parseStoredConsents);
  const [banks, setBanks] = useState<BankSummary[]>([]);
  const [isFetchingBanks, setIsFetchingBanks] = useState(false);

  const setInitialUserData = useCallback((nextId: string, nextName: string) => {
    localStorage.setItem(STORAGE_KEY, nextId);
    setUserIdState(nextId);
    localStorage.setItem(USER_NAME_KEY, nextName);
    setUserNameState(nextName);
  }, []);

  const clearUser = useCallback(() => {
    localStorage.removeItem(STORAGE_KEY);
    localStorage.removeItem(USER_NAME_KEY);
    localStorage.removeItem(CONSENTS_KEY);
    setUserIdState(null);
    setUserNameState(null);
    setConsents([]);
    setBanks([]);
  }, []);

  const upsertConsent = useCallback(
    (update: Omit<ConsentState, 'lastUpdated'>) => {
      setConsents((prev) => {
        const next = [...prev];
        const index = next.findIndex((item) => item.bankId === update.bankId);
        const payload = {
          ...(index >= 0 ? next[index] : {}),
          ...update,
          lastUpdated: Date.now(),
        };
        if (index >= 0) {
          next[index] = payload as ConsentState;
        } else {
          next.push(payload as ConsentState);
        }
        localStorage.setItem(CONSENTS_KEY, JSON.stringify(next));
        return next;
      });
    },
    []
  );

  const refreshBanks = useCallback(async () => {
    if (!userId) {
      setBanks([]);
      return;
    }
    try {
      setIsFetchingBanks(true);
      const response = await getBanks(userId);
      setBanks(response.banks ?? []);
    } catch (error) {
      console.error('Failed to fetch banks', error);
    } finally {
      setIsFetchingBanks(false);
    }
  }, [userId]);

  useEffect(() => {
    if (userId) {
      refreshBanks();
    }
  }, [userId, refreshBanks]);

  const value = useMemo<UserContextValue>(
    () => ({
      userId,
      userName,
      setInitialUserData,
      clearUser,
      consents,
      upsertConsent,
      banks,
      refreshBanks,
      isFetchingBanks,
    }),
    [banks, clearUser, consents, isFetchingBanks, refreshBanks, upsertConsent, setInitialUserData, userId, userName]
  );

  return <UserContext.Provider value={value}>{children}</UserContext.Provider>;
};

export const useUser = (): UserContextValue => {
  const ctx = useContext(UserContext);
  if (!ctx) {
    throw new Error('useUser must be used inside UserProvider');
  }
  return ctx;
};
</file>

<file path="src/styles/global.css">
:root {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  color: #0f172a;
  background-color: #f5f7fb;
  --color-surface: #fff;
  --color-border: rgba(15, 23, 42, 0.08);
  --color-muted: #64748b;
  --color-chip-credit: #eef2ff;
  --color-chip-income: #dcfce7;
  --color-chip-debit: #fee2e2;
  --color-chip-neutral: #e2e8f0;
  --color-chip-balance: #dbeafe;
  --radius-pill: 999px;
  --radius-md: 16px;
  --space-xxs: 4px;
  --space-xs: 8px;
  --space-sm: 12px;
  --space-md: 16px;
  --space-lg: 20px;
}

* {
  box-sizing: border-box;
}

body,
#root {
  margin: 0;
  min-height: 100vh;
}

body {
  background: linear-gradient(180deg, #f5f7fb 0%, #edf0f9 100%);
}

a {
  color: #2563eb;
  text-decoration: none;
}

.app-shell {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-main {
  flex: 1;
  padding: 24px;
  max-width: 900px;
  margin: 0 auto;
}

.card {
  background: var(--color-surface);
  border-radius: var(--radius-md);
  border: 1px solid var(--color-border);
  padding: var(--space-lg);
  margin-bottom: 16px;
  box-shadow: 0 12px 30px rgba(15, 23, 42, 0.08);
}

.card h2 {
  margin-top: 0;
}

.btn {
  border: none;
  border-radius: 999px;
  padding: 10px 18px;
  cursor: pointer;
  font-weight: 600;
  background: #2563eb;
  color: #fff;
  transition: opacity 0.2s ease;
}

.btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.btn-secondary {
  background: #fff;
  color: #0f172a;
  border: 1px solid rgba(15, 23, 42, 0.2);
}

.toast-stack {
  position: fixed;
  top: 16px;
  right: 16px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 999;
}

.toast {
  padding: 12px 16px;
  border-radius: 8px;
  color: #fff;
  box-shadow: 0 12px 20px rgba(0, 0, 0, 0.15);
}

.toast-info {
  background: #2563eb;
}

.toast-success {
  background: #16a34a;
}

.toast-error {
  background: #dc2626;
}

.grid {
  display: grid;
  gap: 16px;
}

.grid-two {
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
}

.list {
  list-style: none;
  padding: 0;
  margin: 0;
}

.list li {
  padding: 12px 0;
  border-bottom: 1px solid rgba(15, 23, 42, 0.08);
}

.list--dense li {
  padding: 12px 0;
}

.card-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: var(--space-sm);
  flex-wrap: wrap;
}

.muted {
  color: var(--color-muted);
  margin: 4px 0;
}

.chip {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  border-radius: var(--radius-pill);
  font-size: 13px;
  padding: 4px 10px;
  background: var(--color-chip-neutral);
  color: #0f172a;
  border: 1px solid rgba(15, 23, 42, 0.06);
}

.chip--balance {
  background: var(--color-chip-balance);
}

.chip--credit {
  background: var(--color-chip-credit);
}

.chip--derived {
  background: #fde68a;
}

.chip--neutral {
  background: var(--color-chip-neutral);
}

.chip--source.chip--income {
  background: var(--color-chip-income);
}

.chip--source.chip--debit {
  background: var(--color-chip-debit);
}

.chip--source.chip--credit {
  background: var(--color-chip-credit);
}

.metadata-badges {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-xs);
  margin-top: var(--space-xs);
}

.metadata-badge {
  padding: 4px 8px;
  border-radius: 10px;
  font-size: 13px;
  background: var(--color-chip-neutral);
  border: 1px solid rgba(15, 23, 42, 0.06);
}

.metadata-badge--merchant {
  background: #e0f2fe;
}

.metadata-badge--mcc {
  background: #ede9fe;
}

.metadata-badge--code {
  background: #fee2e2;
}

.metadata-badge--obligation {
  background: #fef3c7;
}

.metadata-badge--muted {
  background: transparent;
  border-style: dashed;
  color: var(--color-muted);
}

.event-row {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.event-row__header {
  display: flex;
  justify-content: space-between;
  gap: var(--space-sm);
}

.event-row__title {
  font-weight: 600;
  margin: 0 0 4px;
}

.event-row__subtitle {
  margin: 0;
  color: var(--color-muted);
  font-size: 14px;
}

.event-row__amount {
  min-width: 160px;
  text-align: right;
}

.obligation-row {
  border-left: 3px solid transparent;
  padding-left: var(--space-sm);
}

.obligation-row--derived {
  border-left-color: #f59e0b;
}

.filter-row {
  display: flex;
  gap: var(--space-sm);
  flex-wrap: wrap;
}

.filter-row label {
  display: flex;
  flex-direction: column;
  font-size: 13px;
  color: var(--color-muted);
}

.safe-card {
  position: relative;
  overflow: hidden;
}

.safe-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: var(--space-md);
  margin: var(--space-md) 0;
}

.metric {
  font-size: 2.5rem;
  font-weight: 700;
  margin: 8px 0;
}

.metric span {
  font-size: 1rem;
  font-weight: 400;
  color: var(--color-muted);
}

.safe-recommendation {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-xs);
  align-items: baseline;
  padding: 8px 12px;
  background: #ecfccb;
  border-radius: 8px;
  margin-bottom: 12px;
}

.safe-obligations {
  border-top: 1px solid var(--color-border);
  margin-top: var(--space-md);
  padding-top: var(--space-sm);
  font-size: 14px;
  display: grid;
  gap: 4px;
}

.callout {
  border-radius: var(--radius-md);
  border: 1px solid;
  padding: var(--space-sm);
  font-size: 0.9rem;
  margin: var(--space-sm) 0;
}

.callout--warning {
  background: #fef3c7;
  border-color: #f97316;
  color: #7c2d12;
}

.callout--info {
  background: #ecfeff;
  border-color: #0ea5e9;
  color: #0f172a;
}

.snapshot-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: var(--space-sm);
  margin-top: var(--space-sm);
}

.snapshot-item {
  padding: var(--space-sm);
  border: 1px solid var(--color-border);
  border-radius: var(--radius-md);
  background: #f9fafb;
}

.credit-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--space-sm);
}

.credit-row__metrics {
  display: flex;
  flex-direction: column;
  gap: 4px;
  text-align: right;
}

.metadata-transactions {
  list-style: none;
  padding-left: 0;
  display: grid;
  gap: 4px;
}

.metadata-transactions li {
  display: grid;
  grid-template-columns: minmax(80px, 120px) 80px 1fr;
  gap: 8px;
  font-size: 13px;
  border-bottom: 1px dashed rgba(15, 23, 42, 0.08);
  padding-bottom: 4px;
}

.portrait-summary {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-xs);
  margin-bottom: var(--space-sm);
}

.portrait-event {
  padding-bottom: var(--space-sm);
}

.portrait-event__header {
  display: flex;
  justify-content: space-between;
  gap: var(--space-sm);
}

.portrait-panel {
  border: 1px solid rgba(15, 23, 42, 0.08);
  border-radius: 12px;
  padding: var(--space-sm);
}

@media (max-width: 640px) {
  .event-row__header {
    flex-direction: column;
    align-items: flex-start;
  }

  .event-row__amount {
    text-align: left;
  }

  .filter-row {
    flex-direction: column;
  }

  .metadata-badges {
    flex-direction: column;
    align-items: flex-start;
  }

  .metadata-transactions li {
    grid-template-columns: repeat(2, minmax(80px, 1fr));
  }

  .safe-grid {
    grid-template-columns: 1fr;
  }
}

.text-input,
select,
textarea {
  width: 100%;
  padding: 10px 12px;
  border-radius: 10px;
  border: 1px solid rgba(15, 23, 42, 0.2);
  font-size: 16px;
  margin: 8px 0 16px;
  font-family: inherit;
  background: #fff;
}
</file>

<file path="src/test/setup.js">
import '@testing-library/jest-dom';
</file>

<file path="src/test/setup.ts">
import '@testing-library/jest-dom';
</file>

<file path="src/types/dashboard.js">
// Файл: src/types/dashboard.ts
export {};
</file>

<file path="src/types/dashboard.ts">
export type BankStatus = {
  bank_name: string;
  status: string;
  fetched_at: string | null;
};

export type Account = {
  accountId: string;
  nickname?: string;
  balance?: number;
  [key: string]: unknown;
};

export type DashboardResponse = {
  total_balance: number;
  accounts: Account[];
  bank_statuses: Record<string, BankStatus>;
  safe_to_spend_daily: number;
  next_income_date: string | null;
  days_until_next_income: number;
};
</file>

<file path="src/App.js">
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import React from 'react';
import { Navigate, Outlet, Route, Routes, useLocation, useNavigate } from 'react-router-dom';
import { useNotifications } from './state/notifications';
import { useUser } from './state/useUser';
import { BanksCatalogPage } from './pages/BanksCatalogPage';
import { CallbackPage } from './pages/CallbackPage';
import { ConsentStatusPage } from './pages/ConsentStatusPage';
import { DashboardPage } from './pages/DashboardPage';
import { DebtGoalPage } from './pages/DebtGoalPage';
import { GoalsLandingPage } from './pages/GoalsLandingPage';
import { IngestionPage } from './pages/IngestionPage';
import { SaveGoalPage } from './pages/SaveGoalPage';
import { UserIdPage } from './pages/UserIdPage';
import { ConsentProcessPage } from './pages/ConsentProcessPage';
const ProtectedRoute = () => {
    const { userId } = useUser();
    const location = useLocation();
    if (!userId) {
        return _jsx(Navigate, { to: "/", replace: true, state: { from: location } });
    }
    return _jsx(Outlet, {});
};
class AppErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }
    static getDerivedStateFromError(error) {
        return { hasError: true, message: error.message };
    }
    componentDidCatch(error, errorInfo) {
        console.error('App crashed', error, errorInfo);
    }
    render() {
        if (this.state.hasError) {
            return (_jsx("div", { className: "app-main", children: _jsxs("div", { className: "card", children: [_jsx("h2", { children: "\u0427\u0442\u043E-\u0442\u043E \u043F\u043E\u0448\u043B\u043E \u043D\u0435 \u0442\u0430\u043A" }), _jsx("p", { children: this.state.message }), _jsx("button", { className: "btn", onClick: () => this.setState({ hasError: false }), children: "\u041F\u043E\u043F\u0440\u043E\u0431\u043E\u0432\u0430\u0442\u044C \u0441\u043D\u043E\u0432\u0430" })] }) }));
        }
        return this.props.children;
    }
}
const Header = () => {
    const { userId, clearUser } = useUser();
    const navigate = useNavigate();
    const { notify } = useNotifications();
    return (_jsxs("header", { style: { padding: '16px 24px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }, children: [_jsxs("div", { children: [_jsx("strong", { children: "FinPulse MPA" }), userId ? _jsxs("span", { style: { marginLeft: 12, color: '#475569' }, children: ["User: ", userId] }) : null] }), _jsxs("div", { style: { display: 'flex', gap: 12 }, children: [_jsx("button", { className: "btn-secondary btn", onClick: () => navigate('/dashboard'), children: "\u0414\u0430\u0448\u0431\u043E\u0440\u0434" }), userId ? (_jsx("button", { className: "btn-secondary btn", onClick: () => {
                            clearUser();
                            notify('Сессия очищена');
                            navigate('/');
                        }, children: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C" })) : null] })] }));
};
export const App = () => (_jsx(AppErrorBoundary, { children: _jsxs("div", { className: "app-shell", children: [_jsx(Header, {}), _jsxs(Routes, { children: [_jsx(Route, { path: "/", element: _jsx(UserIdPage, {}) }), _jsxs(Route, { element: _jsx(ProtectedRoute, {}), children: [_jsx(Route, { path: "/banks", element: _jsx(BanksCatalogPage, {}) }), _jsx(Route, { path: "/banks/:bankId/status", element: _jsx(ConsentStatusPage, {}) }), _jsx(Route, { path: "/onboarding/consent", element: _jsx(ConsentProcessPage, {}) }), _jsx(Route, { path: "/goals", element: _jsx(GoalsLandingPage, {}) }), _jsx(Route, { path: "/goals/save", element: _jsx(SaveGoalPage, {}) }), _jsx(Route, { path: "/goals/debts", element: _jsx(DebtGoalPage, {}) }), _jsx(Route, { path: "/ingest", element: _jsx(IngestionPage, {}) }), _jsx(Route, { path: "/dashboard", element: _jsx(DashboardPage, {}) })] }), _jsx(Route, { path: "/callback", element: _jsx(CallbackPage, {}) }), _jsx(Route, { path: "*", element: _jsx(Navigate, { to: "/", replace: true }) })] })] }) }));
export default App;
</file>

<file path="src/App.tsx">
import React from 'react';
import { Navigate, Outlet, Route, Routes, useLocation, useNavigate } from 'react-router-dom';
import { useNotifications } from './state/notifications';
import { useUser } from './state/useUser';
import { BanksCatalogPage } from './pages/BanksCatalogPage';
import { CallbackPage } from './pages/CallbackPage';
import { ConsentStatusPage } from './pages/ConsentStatusPage';
import { DashboardPage } from './pages/DashboardPage';
import { DebtGoalPage } from './pages/DebtGoalPage';
import { GoalsLandingPage } from './pages/GoalsLandingPage';
import { IngestionPage } from './pages/IngestionPage';
import { SaveGoalPage } from './pages/SaveGoalPage';
import { UserIdPage } from './pages/UserIdPage';
import { ConsentProcessPage } from './pages/ConsentProcessPage';

const ProtectedRoute: React.FC = () => {
  const { userId } = useUser();
  const location = useLocation();
  if (!userId) {
    return <Navigate to="/" replace state={{ from: location }} />;
  }
  return <Outlet />;
};

class AppErrorBoundary extends React.Component<React.PropsWithChildren, { hasError: boolean; message?: string }> {
  constructor(props: React.PropsWithChildren) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, message: error.message };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('App crashed', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="app-main">
          <div className="card">
            <h2>Что-то пошло не так</h2>
            <p>{this.state.message}</p>
            <button className="btn" onClick={() => this.setState({ hasError: false })}>
              Попробовать снова
            </button>
          </div>
        </div>
      );
    }
    return this.props.children;
  }
}

const Header: React.FC = () => {
  const { userId, clearUser } = useUser();
  const navigate = useNavigate();
  const { notify } = useNotifications();

  return (
    <header style={{ padding: '16px 24px', display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
      <div>
        <strong>FinPulse MPA</strong>
        {userId ? <span style={{ marginLeft: 12, color: '#475569' }}>User: {userId}</span> : null}
      </div>
      <div style={{ display: 'flex', gap: 12 }}>
        <button className="btn-secondary btn" onClick={() => navigate('/dashboard')}>
          Дашборд
        </button>
        {userId ? (
          <button
            className="btn-secondary btn"
            onClick={() => {
              clearUser();
              notify('Сессия очищена');
              navigate('/');
            }}
          >
            Сбросить
          </button>
        ) : null}
      </div>
    </header>
  );
};

export const App: React.FC = () => (
  <AppErrorBoundary>
    <div className="app-shell">
      <Header />
      <Routes>
        <Route path="/" element={<UserIdPage />} />
        <Route element={<ProtectedRoute />}>
          <Route path="/banks" element={<BanksCatalogPage />} />
          <Route path="/banks/:bankId/status" element={<ConsentStatusPage />} />
          <Route path="/onboarding/consent" element={<ConsentProcessPage />} />
          <Route path="/goals" element={<GoalsLandingPage />} />
          <Route path="/goals/save" element={<SaveGoalPage />} />
          <Route path="/goals/debts" element={<DebtGoalPage />} />
          <Route path="/ingest" element={<IngestionPage />} />
          <Route path="/dashboard" element={<DashboardPage />} />
        </Route>
        <Route path="/callback" element={<CallbackPage />} />
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </div>
  </AppErrorBoundary>
);

export default App;
</file>

<file path="src/main.js">
import { jsx as _jsx } from "react/jsx-runtime";
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './styles/global.css';
import { UserProvider } from './state/useUser';
import { NotificationsProvider } from './state/notifications';
ReactDOM.createRoot(document.getElementById('root')).render(_jsx(React.StrictMode, { children: _jsx(NotificationsProvider, { children: _jsx(UserProvider, { children: _jsx(BrowserRouter, { children: _jsx(App, {}) }) }) }) }));
</file>

<file path="src/main.tsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './styles/global.css';
import { UserProvider } from './state/useUser';
import { NotificationsProvider } from './state/notifications';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <NotificationsProvider>
      <UserProvider>
        <BrowserRouter>
          <App />
        </BrowserRouter>
      </UserProvider>
    </NotificationsProvider>
  </React.StrictMode>
);
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tests/test_api_aliases.py">
import sys
from datetime import date, timedelta
from pathlib import Path
from types import SimpleNamespace

PROJECT_DIR = Path(__file__).resolve().parents[1]
REPO_ROOT = PROJECT_DIR.parent
sys.path.append(str(PROJECT_DIR))
sys.path.append(str(REPO_ROOT))

import numpy as np
import pytest
from fastapi.testclient import TestClient

import core.database as database
from hktn.backend.services.analytics import get_dashboard_metrics
from hktn.backend_app import BANK_CONFIGS, app
from hktn.core.analytics_engine import UserGoal, build_financial_portrait
from hktn.core.data_models import AnalysisResult, Transaction
from hktn.core.obr_client import OBRAPIClient


@pytest.fixture(autouse=True)
def temp_db(tmp_path, monkeypatch):
    test_db = tmp_path / "consents.db"
    monkeypatch.setattr(database, "DB_FILE", str(test_db))
    database.init_db()
    yield


def test_list_banks_exposes_base_url(monkeypatch):
    BANK_CONFIGS["vbank"]["url"] = "http://mock-bank.local"
    with TestClient(app) as client:
        response = client.get("/api/banks")
    assert response.status_code == 200
    payload = response.json()
    assert any(bank["baseUrl"] == "http://mock-bank.local" for bank in payload["banks"])
    statuses = {bank["status"] for bank in payload["banks"]}
    assert "configured" in statuses


def test_consents_start_alias(monkeypatch):
    BANK_CONFIGS["vbank"]["url"] = "http://mock-bank.local"
    monkeypatch.setattr("hktn.backend.config.settings.team_client_id", "team-id", raising=False)
    monkeypatch.setattr("hktn.backend.config.settings.team_client_secret", "team-secret", raising=False)

    class DummyClient:
        def __init__(self, *args, **kwargs):
            self._closed = False

        async def initiate_consent(self, user_id: str):
            assert user_id == "demo-123"
            return SimpleNamespace(
                consent_id="consent-1",
                request_id="req-1",
                status="AwaitingAuthorization",
                approval_url="http://bank/approve",
                auto_approved=False,
            )

        async def close(self):
            self._closed = True

    monkeypatch.setattr("hktn.backend.services.banking.OBRAPIClient", DummyClient)

    with TestClient(app) as client:
        response = client.post("/api/consents/start", json={"user_id": "demo-123", "bank_id": "vbank"})

    assert response.status_code == 200
    data = response.json()
    assert data["bank_id"] == "vbank"
    assert data["request_id"] == "req-1"
    assert data["state"] == "pending"


def test_transaction_parsing_enriches_metadata():
    client = object.__new__(OBRAPIClient)
    setattr(client, "api_base_url", "https://bank.test")
    raw_tx = {
        "transactionId": "tx-001",
        "amount": {"currency": "RUB", "amount": "250.0"},
        "creditDebitIndicator": "Debit",
        "bookingDate": "2024-05-10",
        "transactionInformation": "POS Purchase",
        "bankTransactionCode": {"code": "POS", "subCode": "PURCHASE"},
        "merchant": {
            "merchantId": "m-1",
            "name": "Electro Shop",
            "mccCode": "5732",
            "category": "electronics",
            "city": "Moscow",
            "country": "RU",
            "address": "Lenina 1",
        },
        "transactionLocation": {"city": "Moscow"},
        "card": {"maskedPan": "1234****", "type": "Visa", "name": "Demo Card"},
    }

    tx = client._to_transaction_model(raw_tx)

    assert tx is not None
    assert tx.amount < 0
    assert tx.creditDebitIndicator == "Debit"
    assert tx.bankTransactionCode == "POS:PURCHASE"
    assert tx.merchant["name"] == "Electro Shop"
    assert tx.mccCode == "5732"
    assert tx.card["maskedPan"] == "1234****"
    assert tx.transactionLocation["city"] == "Moscow"


def test_financial_portrait_includes_event_obligations():
    base_date = date.today() - timedelta(days=60)
    transactions = [
        Transaction(transactionId="income-1", amount=4000, currency="RUB", description="Salary", bookingDate=base_date),
        Transaction(
            transactionId="income-2",
            amount=4000,
            currency="RUB",
            description="Salary",
            bookingDate=base_date + timedelta(days=30),
        ),
        Transaction(
            transactionId="bill-1",
            amount=-250,
            currency="RUB",
            description="Utility Bill",
            bookingDate=base_date + timedelta(days=5),
            merchant={"name": "Utility Co", "mccCode": "4900", "category": "utilities"},
            mccCode="4900",
            category="utilities",
        ),
        Transaction(
            transactionId="bill-2",
            amount=-255,
            currency="RUB",
            description="Utility Bill",
            bookingDate=base_date + timedelta(days=35),
            merchant={"name": "Utility Co", "mccCode": "4900", "category": "utilities"},
            mccCode="4900",
            category="utilities",
        ),
    ]

    portrait = build_financial_portrait(
        transactions=transactions,
        credits=[],
        accounts=[{"balance": 5000}],
        user_goal=UserGoal(),
    )

    recurring_debits = [item for item in portrait["upcoming_payments"] if item["source"] == "recurring_debit"]
    assert recurring_debits
    assert recurring_debits[0]["mcc_code"] == "4900"
    assert portrait["current_balance"] == 5000


@pytest.mark.asyncio
async def test_dashboard_metrics_use_real_balance(monkeypatch):
    consent = database.StoredConsent(bank_id="demo-bank", consent_id="consent-1")
    monkeypatch.setattr(
        "hktn.backend.services.analytics.find_approved_consents",
        lambda user_id, consent_type="accounts": [consent],
    )
    monkeypatch.setattr("hktn.backend.services.analytics.get_user_goal", lambda user_id: None)
    monkeypatch.setattr("hktn.backend.services.analytics.compose_user_goal", lambda *args, **kwargs: UserGoal())

    sample_tx = Transaction(
        transactionId="t-1",
        amount=120.0,
        currency="RUB",
        description="Coffee",
        bookingDate=date.today() - timedelta(days=1),
    )

    async def fake_fetch_bank_data(bank_id, consent_id, user_id):
        return {"bank_id": bank_id, "status": "ok", "message": "", "transactions": [sample_tx]}

    async def fake_fetch_bank_credits(bank_id, consent_id, user_id, create_product_consent=False):
        credit = {"name": "Loan A", "min_payment": 100, "next_payment_date": (date.today() + timedelta(days=5))}
        return {"bank_id": bank_id, "status": "ok", "message": "", "credits": [credit]}

    async def fake_fetch_bank_accounts(bank_id, consent_id, user_id):
        accounts = [{"balance": 600}, {"current_balance": 400}]
        return {"bank_id": bank_id, "status": "ok", "message": "", "accounts": accounts}

    async def fake_fetch_bank_balances(bank_id, consent_id, user_id):
        balances = [{"availableBalance": {"amount": 1000}}]
        return {"bank_id": bank_id, "status": "ok", "message": "", "balances": balances}

    monkeypatch.setattr("hktn.backend.services.analytics.fetch_bank_data_with_consent", fake_fetch_bank_data)
    monkeypatch.setattr("hktn.backend.services.analytics.fetch_bank_credits", fake_fetch_bank_credits)
    monkeypatch.setattr("hktn.backend.services.analytics.fetch_bank_accounts_with_consent", fake_fetch_bank_accounts)
    monkeypatch.setattr(
        "hktn.backend.services.analytics.fetch_bank_balances_with_consent",
        fake_fetch_bank_balances,
    )

    captured = {}

    def fake_run_analysis_with_details(transactions, current_balance, payment_date, payment_amount):
        captured["balance"] = current_balance
        analysis = AnalysisResult(
            payment_date=payment_date,
            payment_amount=payment_amount,
            success_probability_percent=80,
            recommendation="ok",
            color_zone="green",
        )
        trajectories = np.zeros((1, 1))
        forecast_dates = [date.today()]
        noise_profile = {}
        event_profiles = [
            {
                "cluster_id": 1,
                "label": "Salary",
                "mu_amount": 1000.0,
                "sigma_amount": 5.0,
                "mu_day": 1.0,
                "sigma_day": 1.0,
                "frequency_days": 30,
                "last_date": date.today(),
                "is_income": True,
                "coherence": 0.9,
                "sample_size": 2,
                "descriptions": ["Salary"],
                "metadata": {},
                "source": "income_event",
            },
            {
                "cluster_id": 2,
                "label": "Utilities",
                "mu_amount": -200.0,
                "sigma_amount": 5.0,
                "mu_day": 5.0,
                "sigma_day": 1.0,
                "frequency_days": 30,
                "last_date": date.today() - timedelta(days=7),
                "is_income": False,
                "coherence": 0.9,
                "sample_size": 3,
                "descriptions": ["Utility Bill"],
                "mcc_code": "4900",
                "merchant_name": "Utility Co",
                "merchant_category": "utilities",
                "bank_transaction_code": "POS",
                "metadata": {
                    "dominant_mcc_code": "4900",
                    "dominant_bank_transaction_code": "POS",
                    "dominant_merchant": "Utility Co",
                    "merchant_category": "utilities",
                    "transaction_category": "utilities",
                    "mcc_consistency": 1.0,
                },
                "source": "expense_event",
            },
        ]
        return analysis, trajectories, forecast_dates, noise_profile, event_profiles

    monkeypatch.setattr("hktn.backend.services.analytics.run_analysis_with_details", fake_run_analysis_with_details)

    metrics = await get_dashboard_metrics("demo-user")

    assert captured["balance"] == pytest.approx(1000.0)
    assert metrics["current_balance"] == pytest.approx(1000.0)
    assert any(item["source"] == "recurring_debit" for item in metrics["upcoming_payments"])
    assert any(item.get("mcc_code") == "4900" for item in metrics["upcoming_payments"])
</file>

<file path="tests/test_consents.py">
from pathlib import Path
import sys

import pytest

sys.path.append(str(Path(__file__).resolve().parents[1]))

import core.database as database  # noqa: E402


@pytest.fixture(autouse=True)
def _temp_db(tmp_path, monkeypatch):
    test_db = tmp_path / "consents.db"
    monkeypatch.setattr(database, "DB_FILE", str(test_db))
    database.init_db()
    yield


def test_find_approved_consents_filters_account_scope():
    database.save_consent("user-1", "vbank", "consent-accounts", "APPROVED")
    database.save_consent("user-1", "vbank", "consent-products", "APPROVED", consent_type="products")

    accounts_only = database.find_approved_consents("user-1", consent_type="accounts")
    assert len(accounts_only) == 1
    assert accounts_only[0].consent_id == "consent-accounts"
    assert accounts_only[0].consent_type == "accounts"

    all_consents = database.find_approved_consents("user-1")
    assert {entry.consent_type for entry in all_consents} == {"accounts", "products"}
    assert {entry.consent_id for entry in all_consents} == {"consent-accounts", "consent-products"}
</file>

<file path="backend_app.py">
"""Compatibility wrapper for legacy imports.

This module keeps the historical `hktn.backend_app:app` entrypoint working
while the real FastAPI application lives inside `hktn.backend`.
"""

try:  # pragma: no cover - compatibility for direct module import
    from .backend.app import app, create_app
    from .backend.config import settings
except ImportError:  # pragma: no cover
    from backend.app import app, create_app  # type: ignore
    from backend.config import settings  # type: ignore

from hktn.core.obr_client import OBRAPIClient  # re-exported for legacy tests

BANK_CONFIGS = settings.banks
TEAM_CLIENT_ID = settings.team_client_id
TEAM_CLIENT_SECRET = settings.team_client_secret

__all__ = ["app", "create_app", "BANK_CONFIGS", "TEAM_CLIENT_ID", "TEAM_CLIENT_SECRET", "OBRAPIClient"]
</file>

<file path="index.html">
<!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Main screens</title>
    </head>

    <body>
      <div id="root"></div>
      <script type="module" src="/src/main.tsx"></script>
    </body>
  </html>
</file>

<file path="jest.config.ts">
import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  roots: ['<rootDir>/src', '<rootDir>/tests'],
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
  transform: {
    '^.+\\.(ts|tsx)$': [
      'ts-jest',
      {
        tsconfig: '<rootDir>/tsconfig.json',
      },
    ],
  },
};

export default config;
</file>

<file path="package.json">
{
  "name": "finpulse-open-banking-ui",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest run"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.22.3"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.1.2",
    "@testing-library/user-event": "^14.4.3",
    "@types/jest": "^29.5.12",
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@vitejs/plugin-react": "^4.2.1",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "jsdom": "^24.1.3",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.2",
    "typescript": "^5.3.3",
    "vite": "^5.1.4",
    "vitest": "^1.6.1"
  }
}
</file>

<file path="README.md">
# Main screens

  This is a code bundle for Main screens. The original project is available at https://www.figma.com/design/g2lq6y3UolIAHaAuvnYRaz/Main-screens.

  ## Running the code

  Run `npm i` to install the dependencies.

  Run `npm run dev` to start the development server.

  ## Analytics flow updates

  - Bank transactions now retain merchant, MCC, bank transaction code, and card metadata so the clustering engine can reason about actual merchants instead of generic descriptions.
  - The analytics engine derives deterministic obligations from both credit agreements and highly coherent recurring debit clusters (tagged with their MCC/category/source), which flow into `/api/dashboard` and `/api/financial-portrait`.
  - Safe-to-spend calculations now use real-time balances summed from linked accounts, so probability estimates and explanations reflect actual cash instead of placeholder values.
  - Dashboard UI consumes the enriched payload and surfaces badges for MCC/category, merchant, transaction codes and obligation sources. Upcoming-payment filters allow PMs to slice by source or MCC to verify data quality quickly.
  - The “Financial Portrait” inspector lazy-loads the `/api/financial-portrait` response, links recurring events back to `transactions_sample`, and displays MCC coverage percentages so onboarding engineers can confirm clustering quality without leaving the UI.
  - Design tokens (`--color-chip-*`, `--space-*`, etc.) were added to `src/styles/global.css` to keep badges/chips responsive. Metadata stacks collapse vertically under 640px widths, so screenshots captured via `npm run dev` → `localhost:5173/dashboard` at 360px and 1440px widths remain legible.

  ## Testing & QA

  - Run `npm run test -- DashboardPage` to execute the new vitest suite at `src/pages/__tests__/DashboardPage.test.tsx`, which covers metadata rendering, filter behavior, and the lazy portrait fetch contract.
  - Accessibility: All metadata badges expose ARIA labels/tooltips (e.g., `SourceChip`, bank transaction code titles). When adding new badges, reuse the `.metadata-badge` classes to inherit focus contrast.
  - Localization: strings for badges/tooltips live inside `DashboardPage.tsx`. To localize, extract them into a shared dictionary and update the tests accordingly.
  - Screenshot/regression coverage: capture updated dashboard states after major API changes and drop PNGs into `docs/main_screens`. Mention which dataset (e.g., `data/260-1_account.json`) produced the snapshot so analysts can reproduce it.
</file>

<file path="requirements.txt">
# -- Backend Framework --
# FastAPI для создания REST API и Uvicorn для его запуска.
fastapi
uvicorn[standard]
python-multipart

# -- Data Science & Analytics --
# Основные библиотеки для аналитического движка "Финансовый Пульс".
pandas
numpy
scikit-learn
scipy

# -- Core Utilities & API Communication --
# Библиотеки для HTTP-запросов, работы с JWT, .env файлами и моделями данных.
httpx[http2]
pydantic
python-dotenv
pyjwt[crypto]
tenacity
cachetools
pytest
pytest-asyncio
pytest-mock
respx
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ES2020"],
    "module": "ESNext",
    "moduleResolution": "Node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
/// <reference types="vitest" />
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// Я убрал root: 'src', как мы и договаривались
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
  },
  test: { // Теперь эта секция валидна!
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
  },
});
</file>

</files>
